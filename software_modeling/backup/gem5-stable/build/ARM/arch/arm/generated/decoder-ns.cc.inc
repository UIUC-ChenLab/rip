// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   arm/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

    Movz::Movz(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movz", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Movk::Movk(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movk", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Movn::Movn(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movn", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ4::LOAD_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ4::LOAD_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ4::LOAD_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ4::LOAD_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ4::LOAD_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ4::LOAD_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ4::LOAD_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ4::LOAD_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ4::LOAD_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ4::LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ4::LOAD_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ4::LOAD_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ4::LOAD_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ4::LOAD_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ4::LOAD_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ4::LOAD_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ4::LOAD_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ4::LOAD_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ4::LOAD_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ4::LOAD_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ4::LOAD_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ4::LOAD_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ4::LOAD_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ1::LOAD_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ1::LOAD_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ1::LOAD_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ1::LOAD_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ1::LOAD_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ1::LOAD_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ1::LOAD_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ1::LOAD_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ1::LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ1::LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ1::LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ1::LOAD_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ1::LOAD_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ1::LOAD_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ1::LOAD_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ1::LOAD_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ1::LOAD_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ1::LOAD_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ1::LOAD_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ1::LOAD_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ1::LOAD_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ1::LOAD_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ1::LOAD_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ1::LOAD_IMM_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ1::LOAD_REG_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ1::LOAD_IMM_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ1::LOAD_REG_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ1::LOAD_IMM_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ1::LOAD_REG_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ1::LOAD_IMM_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ1::LOAD_REG_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WN_SZ1::LOAD_IMM_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WN_SZ1::LOAD_REG_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WN_SZ1::LOAD_IMM_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WN_SZ1::LOAD_REG_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ1::LOAD_IMM_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ1::LOAD_REG_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ1::LOAD_IMM_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ1::LOAD_REG_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ1::LOAD_IMM_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ1::LOAD_REG_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ1::LOAD_IMM_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ1::LOAD_REG_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WN_SZ1::LOAD_IMM_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WN_SZ1::LOAD_REG_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WN_SZ1::LOAD_IMM_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WN_SZ1::LOAD_REG_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ2::LOAD_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ2::LOAD_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ2::LOAD_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ2::LOAD_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ2::LOAD_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ2::LOAD_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ2::LOAD_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ2::LOAD_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ2::LOAD_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ2::LOAD_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ2::LOAD_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ2::LOAD_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ2::LOAD_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ2::LOAD_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ2::LOAD_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ2::LOAD_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ2::LOAD_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ2::LOAD_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ2::LOAD_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ2::LOAD_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ2::LOAD_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ2::LOAD_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ2::LOAD_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ2::LOAD_IMM_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ2::LOAD_REG_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ2::LOAD_IMM_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ2::LOAD_REG_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ2::LOAD_IMM_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ2::LOAD_REG_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ2::LOAD_IMM_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ2::LOAD_REG_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WN_SZ2::LOAD_IMM_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WN_SZ2::LOAD_REG_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WN_SZ2::LOAD_IMM_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WN_SZ2::LOAD_REG_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ2::LOAD_IMM_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ2::LOAD_REG_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ2::LOAD_IMM_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ2::LOAD_REG_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ2::LOAD_IMM_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ2::LOAD_REG_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ2::LOAD_IMM_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ2::LOAD_REG_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WN_SZ2::LOAD_IMM_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WN_SZ2::LOAD_REG_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WN_SZ2::LOAD_IMM_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WN_SZ2::LOAD_REG_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AY_PY_SN_UN_WY_SZ4::LOAD_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AN_PY_SN_UN_WY_SZ4::LOAD_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WY_SZ4::LOAD_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WY_SZ4::LOAD_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WN_SZ4::LOAD_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WN_SZ4::LOAD_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrex", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrexd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_IMM::LDRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PREAcc::LDRB64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PRE::LDRB64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POSTAcc::LDRB64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POST::LDRB64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_REG::LDRB64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_IMM::LDRSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PREAcc::LDRSBW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PRE::LDRSBW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POSTAcc::LDRSBW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POST::LDRSBW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_REG::LDRSBW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_IMM::LDRSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PREAcc::LDRSBX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PRE::LDRSBX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POSTAcc::LDRSBX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POST::LDRSBX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_REG::LDRSBX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_IMM::LDRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PREAcc::LDRH64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PRE::LDRH64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POSTAcc::LDRH64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POST::LDRH64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_REG::LDRH64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_IMM::LDRSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PREAcc::LDRSHW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PRE::LDRSHW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POSTAcc::LDRSHW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POST::LDRSHW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_REG::LDRSHW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_IMM::LDRSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PREAcc::LDRSHX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PRE::LDRSHX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POSTAcc::LDRSHX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POST::LDRSHX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_REG::LDRSHX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_IMM::LDRSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PREAcc::LDRSW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PRE::LDRSW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsw", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POSTAcc::LDRSW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POST::LDRSW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsw", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_REG::LDRSW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsw", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_IMM::LDRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PREAcc::LDRW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PRE::LDRW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POSTAcc::LDRW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POST::LDRW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_REG::LDRW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_IMM::LDRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PREAcc::LDRX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PRE::LDRX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POSTAcc::LDRX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POST::LDRX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_REG::LDRX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_IMM::LDRBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PREAcc::LDRBFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PRE::LDRBFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POSTAcc::LDRBFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POST::LDRBFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_REG::LDRBFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_IMM::LDRHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PREAcc::LDRHFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PRE::LDRHFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POSTAcc::LDRHFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POST::LDRHFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_REG::LDRHFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_IMM::LDRSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PREAcc::LDRSFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PRE::LDRSFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POSTAcc::LDRSFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POST::LDRSFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_REG::LDRSFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_IMM::LDRDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PREAcc::LDRDFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PRE::LDRDFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POSTAcc::LDRDFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POST::LDRDFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_REG::LDRDFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_IMM::PRFM64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("prfm", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_REG::PRFM64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("prfm", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_LIT::PRFM64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("prfm", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsDataPrefetch] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFUM64_IMM::PRFUM64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("prfum", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFUM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURB64_IMM::LDURB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldurb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBW64_IMM::LDURSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBX64_IMM::LDURSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURH64_IMM::LDURH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldurh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHW64_IMM::LDURSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHX64_IMM::LDURSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSW64_IMM::LDURSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURW64_IMM::LDURW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURX64_IMM::LDURX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURBFP64_IMM::LDURBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURHFP64_IMM::LDURHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSFP64_IMM::LDURSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURDFP64_IMM::LDURDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRB64_IMM::LDTRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBW64_IMM::LDTRSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBX64_IMM::LDTRSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRH64_IMM::LDTRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHW64_IMM::LDTRSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHX64_IMM::LDTRSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSW64_IMM::LDTRSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRW64_IMM::LDTRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRX64_IMM::LDTRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSWL64_LIT::LDRSWL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRWL64_LIT::LDRWL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRXL64_LIT::LDRXL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRXL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_LIT::LDRSFP64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_LIT::LDRDFP64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDARX64::LDARX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARW64::LDARW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARH64::LDARH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldarh", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARB64::LDARB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldarb", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRX64::LDAXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRW64::LDAXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRH64::LDAXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxrh", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRB64::LDAXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxrb", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDXRX64::LDXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRW64::LDXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRH64::LDXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxrh", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRB64::LDXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxrb", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    MicroLdPairUop::MicroLdPairUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldp_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdPairFp8Uop::MicroLdPairFp8Uop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldp_fp8_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16Uop::MicroLdFp16Uop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldfp16_uop", machInst, MemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16RegUop::MicroLdFp16RegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldfp16reg_uop", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new MicroLdFp16RegUop(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDAXPW64::LDAXPW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDAXPX64::LDAXPX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPW64::LDXPW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPX64::LDXPX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXImmUop::MicroLdrXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldrxi_uop", machInst, MemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXRegUop::MicroLdrXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("ldrxr_uop", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXLitUop::MicroLdrXLitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldrxl_uop", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXImmUop::MicroLdrFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldrfpxi_uop", machInst, MemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXRegUop::MicroLdrFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("ldrfpxr_uop", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXLitUop::MicroLdrFpXLitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldrfpxl_uop", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16LitUop::MicroLdFp16LitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldfp16_lit__uop", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDUXImmUop::MicroLdrDUXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrduxi_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDSXImmUop::MicroLdrDSXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrdsxi_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDFpXImmUop::MicroLdrDFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrdfpxi_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    Svc::Svc(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("svc", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Smc::Smc(ExtMachInst machInst)  : PredOp("smc", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Hvc::Hvc(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("hvc", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Eret::Eret(ExtMachInst machInst)  : PredOp("eret", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_ELR_HYP + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    MrsCpsr::MrsCpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MrsSpsr::MrsSpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MrsBankedReg::MrsBankedReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint8_t     _sysM,
                                          bool        _r)
        : MrsOp("mrs", machInst, IntAluOp, _dest),
          byteMask(_sysM), r(_r)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = decodeMrsMsrBankedIntRegIndex(byteMask, r);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrBankedReg::MsrBankedReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t     _sysM,
                                          bool        _r)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, _sysM),
          r(_r)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = decodeMrsMsrBankedIntRegIndex(byteMask, r);
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrCpsrReg::MsrCpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrSpsrReg::MsrSpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrCpsrImm::MsrCpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrSpsrImm::MsrSpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rev::Rev(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rev16::Rev16(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Revsh::Revsh(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("revsh", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rbit::Rbit(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Clz::Clz(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Ssat::Ssat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("ssat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usat::Usat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("usat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Ssat16::Ssat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("ssat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usat16::Usat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("usat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtb::Sxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtab::Sxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtb16::Sxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtab16::Sxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxth::Sxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtah::Sxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtb::Uxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtab::Uxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtb16::Uxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtab16::Uxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxth::Uxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtah::Uxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sel::Sel(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sel", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usad8::Usad8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("usad8", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usada8::Usada8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : RegRegRegRegOp("usada8", machInst, IntAluOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        BkptInst::BkptInst(ExtMachInst machInst)  : PredOp("bkpt", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        NopInst::NopInst(ExtMachInst machInst)  : ArmStaticInst("nop", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNop] = true;;
        }

        YieldInst::YieldInst(ExtMachInst machInst)  : PredOp("yield", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfeInst::WfeInst(ExtMachInst machInst)  : PredOp("wfe", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfiInst::WfiInst(ExtMachInst machInst)  : PredOp("wfi", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        SevInst::SevInst(ExtMachInst machInst)  : PredOp("sev", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        SevlInst::SevlInst(ExtMachInst machInst)  : PredOp("sevl", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        ItInst::ItInst(ExtMachInst machInst)  : PredOp("it", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Unknown::Unknown(ExtMachInst machInst)  : UnknownOp("unknown", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Ubfx::Ubfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("ubfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sbfx::Sbfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("sbfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Bfc::Bfc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfc", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Bfi::Bfi(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfi", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrc14::Mrc14(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : RegRegImmOp("mrc", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcr14::Mcr14(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : RegRegImmOp("mcr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrc15::Mrc15(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          MiscRegIndex _op1,
                                          uint64_t _imm)
        : RegMiscRegImmOp("mrc", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcr15::Mcr15(ExtMachInst machInst,
                                          MiscRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : MiscRegRegImmOp("mcr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrrc15::Mrrc15(ExtMachInst machInst,
                                          MiscRegIndex op1,
                                          IntRegIndex dest,
                                          IntRegIndex dest2,
                                          uint32_t    imm)
        : MrrcOp("mrrc", machInst, IntAluOp, op1, dest,
                         dest2, imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcrr15::Mcrr15(ExtMachInst machInst,
                                          IntRegIndex op1,
                                          IntRegIndex op2,
                                          MiscRegIndex dest,
                                          uint32_t    imm)
        : McrrOp("mcrr", machInst, IntAluOp, op1, op2,
                         dest, imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Enterx::Enterx(ExtMachInst machInst)  : PredOp("enterx", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Leavex::Leavex(ExtMachInst machInst)  : PredOp("leavex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Setend::Setend(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("setend", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Clrex::Clrex(ExtMachInst machInst)  : PredOp("clrex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Isb::Isb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("isb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Dsb::Dsb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("dsb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsMemBarrier] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Dmb::Dmb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("dmb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsMemBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Dbg::Dbg(ExtMachInst machInst)  : PredOp("dbg", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Cps::Cps(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("cps", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Svc64::Svc64(ExtMachInst machInst)  : ArmStaticInst("svc", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        }

        Smc64::Smc64(ExtMachInst machInst)  : ArmStaticInst("smc", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        }

    Bfm64::Bfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("bfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Ubfm64::Ubfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("ubfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Sbfm64::Sbfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("sbfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Extr64::Extr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp64("extr", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

        Unknown64::Unknown64(ExtMachInst machInst)  : UnknownOp64("unknown", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
        }

        Isb64::Isb64(ExtMachInst machInst)  : ArmStaticInst("isb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsSerializeAfter] = true;;
        }

        Dsb64::Dsb64(ExtMachInst machInst)  : ArmStaticInst("dsb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMemBarrier] = true;
	flags[IsSerializeAfter] = true;;
        }

        Dmb64::Dmb64(ExtMachInst machInst)  : ArmStaticInst("dmb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMemBarrier] = true;;
        }

        Clrex64::Clrex64(ExtMachInst machInst)  : ArmStaticInst("clrex", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;;
        }

#endif
#if __SPLIT == 2

    STRB64_IMM::STRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PREAcc::STRB64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PRE::STRB64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POSTAcc::STRB64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POST::STRB64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_REG::STRB64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("strb", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_IMM::STRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PREAcc::STRH64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PRE::STRH64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POSTAcc::STRH64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POST::STRH64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_REG::STRH64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("strh", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_IMM::STRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PREAcc::STRW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PRE::STRW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POSTAcc::STRW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POST::STRW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_REG::STRW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_IMM::STRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PREAcc::STRX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PRE::STRX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POSTAcc::STRX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POST::STRX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_REG::STRX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_IMM::STRBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PREAcc::STRBFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PRE::STRBFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POSTAcc::STRBFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POST::STRBFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_REG::STRBFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_IMM::STRHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PREAcc::STRHFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PRE::STRHFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POSTAcc::STRHFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POST::STRHFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_REG::STRHFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_IMM::STRSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PREAcc::STRSFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PRE::STRSFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POSTAcc::STRSFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POST::STRSFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_REG::STRSFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_IMM::STRDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PREAcc::STRDFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PRE::STRDFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POSTAcc::STRDFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POST::STRDFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_REG::STRDFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURB64_IMM::STURB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sturb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURH64_IMM::STURH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sturh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURW64_IMM::STURW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURX64_IMM::STURX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURBFP64_IMM::STURBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURHFP64_IMM::STURHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURSFP64_IMM::STURSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURDFP64_IMM::STURDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRB64_IMM::STTRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttrb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRH64_IMM::STTRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttrh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRW64_IMM::STTRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRX64_IMM::STTRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLRX64::STLRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRW64::STLRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRH64::STLRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlrh", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRB64::STLRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlrb", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRX64::STLXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRW64::STLXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRH64::STLXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxrh", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRB64::STLXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxrb", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STXRX64::STXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRW64::STXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRH64::STXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxrh", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRB64::STXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxrb", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STLXPW64::STLXPW64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STLXPX64::STLXPX64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STXPW64::STXPW64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    STXPX64::STXPX64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    MicroStrXImmUop::MicroStrXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strxi_uop", machInst, MemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrXRegUop::MicroStrXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strxr_uop", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXImmUop::MicroStrFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strfpxi_uop", machInst, MemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXRegUop::MicroStrFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strfpxr_uop", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXImmUop::MicroStrQBFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strqbfpxi_uop", machInst, MemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXRegUop::MicroStrQBFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strqbfpxr_uop", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXImmUop::MicroStrQTFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strqtfpxi_uop", machInst, MemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXRegUop::MicroStrQTFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strqtfpxr_uop", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDXImmUop::MicroStrDXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("strdxi_uop", machInst, MemWriteOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDFpXImmUop::MicroStrDFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("strdfpxi_uop", machInst, MemWriteOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ4::STORE_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ4::STORE_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ4::STORE_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ4::STORE_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ4::STORE_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ4::STORE_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ4::STORE_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ4::STORE_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ4::STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ4::STORE_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ4::STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ4::STORE_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ4::STORE_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ4::STORE_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ4::STORE_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ4::STORE_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ4::STORE_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ4::STORE_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ4::STORE_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ4::STORE_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ4::STORE_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ4::STORE_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ4::STORE_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ4::STORE_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ1::STORE_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ1::STORE_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ1::STORE_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ1::STORE_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ1::STORE_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ1::STORE_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ1::STORE_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ1::STORE_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ1::STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ1::STORE_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ1::STORE_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ1::STORE_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ1::STORE_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ1::STORE_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ1::STORE_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ1::STORE_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ1::STORE_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ1::STORE_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ1::STORE_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ1::STORE_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ1::STORE_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ1::STORE_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ1::STORE_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ1::STORE_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ2::STORE_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ2::STORE_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ2::STORE_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ2::STORE_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ2::STORE_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ2::STORE_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ2::STORE_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ2::STORE_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ2::STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ2::STORE_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ2::STORE_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ2::STORE_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ2::STORE_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ2::STORE_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ2::STORE_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ2::STORE_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ2::STORE_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ2::STORE_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ2::STORE_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ2::STORE_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ2::STORE_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ2::STORE_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ2::STORE_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ2::STORE_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PY_SN_UN_WY_SZ4::STORE_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PY_SN_UN_WY_SZ4::STORE_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PY_SN_UN_WY_SZ4::STORE_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PY_SN_UN_WY_SZ4::STORE_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WY_SZ4::STORE_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WY_SZ4::STORE_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WY_SZ4::STORE_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WY_SZ4::STORE_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WN_SZ4::STORE_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WN_SZ4::STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WN_SZ4::STORE_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strex", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexh", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexb", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryExDImm>("strexd", machInst, MemWriteOp,
                 (IntRegIndex)_result,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest, _dest2,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    Swp::Swp(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swp", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Swpb::Swpb(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swpb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrUop::MicroLdrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrRetUop::MicroLdrRetUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_ret_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrFpUop::MicroLdrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDBFpUop::MicroLdrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDTFpUop::MicroLdrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrUop::MicroStrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("str_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrFpUop::MicroStrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDBFpUop::MicroStrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDTFpUop::MicroStrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdr2Uop::MicroLdr2Uop(ExtMachInst machInst,
                                   RegIndex _dreg1,
                                   RegIndex _dreg2,
                                   RegIndex _base,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemPairOp("ldr2_uop", machInst, MemReadOp,
                         _dreg1, _dreg2, _base, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddiUop::MicroAddiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("addi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddXiUop::MicroAddXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddXiSpAlignUop::MicroAddXiSpAlignUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroSubiUop::MicroSubiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("subi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubXiUop::MicroSubXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("subxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddUop::MicroAddUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("add_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubUop::MicroSubUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("sub_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddXERegUop::MicroAddXERegUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   ArmExtendType _type, uint32_t _shiftAmt)
        : MicroIntRegXOp("addxr_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroUopRegMov::MicroUopRegMov(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("uopReg_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopRegMovRet::MicroUopRegMovRet(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("movret_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopSetPCCPSR::MicroUopSetPCCPSR(ExtMachInst machInst,
                                   IntRegIndex _ura,
                                   IntRegIndex _urb,
                                   IntRegIndex _urc)
          : MicroSetPCCPSR("uopSet_uop", machInst, IntAluOp,
                           _ura, _urb, _urc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urc;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            flags[IsCondControl] = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        } else {
            flags[IsUncondControl] = true;
        }
    }

LdmStm::LdmStm(ExtMachInst machInst, IntRegIndex rn,
        bool index, bool up, bool user, bool writeback, bool load,
        uint32_t reglist)
    : MacroMemOp("ldmstm", machInst, IntAluOp, rn,
                     index, up, user, writeback, load, reglist)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


LdpStp::LdpStp(const char *mnemonic, ExtMachInst machInst,
        uint32_t size, bool fp, bool load, bool noAlloc, bool signExt,
        bool exclusive, bool acrel, uint32_t imm, AddrMode mode,
        IntRegIndex rn, IntRegIndex rt, IntRegIndex rt2)
    : PairMemOp(mnemonic, machInst, IntAluOp, size,
                     fp, load, noAlloc, signExt, exclusive, acrel,
                     imm, mode, rn, rt, rt2)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemImm::BigFpMemImm(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemImmOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemPre::BigFpMemPre(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemPreOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemPost::BigFpMemPost(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemPostOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemReg::BigFpMemReg(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base,
        IntRegIndex offset, ArmExtendType type, int64_t imm)
    : BigFpMemRegOp(mnemonic, machInst, IntAluOp, load, dest, base,
                     offset, type, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemLit::BigFpMemLit(const char *mnemonic, ExtMachInst machInst,
        IntRegIndex dest, int64_t imm)
    : BigFpMemLitOp(mnemonic, machInst, IntAluOp, dest, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

VldMult::VldMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VldMultOp("vldmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VldSingle::VldSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VldSingleOp("vldsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstMult::VstMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VstMultOp("vstmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstSingle::VstSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VstSingleOp("vstsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VLdmStm::VLdmStm(ExtMachInst machInst, IntRegIndex rn,
        RegIndex vd, bool single, bool up, bool writeback, bool load,
        uint32_t offset)
    : MacroVFPMemOp("vldmstm", machInst, IntAluOp, rn,
                     vd, single, up, writeback, load, offset)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


    AndImm::AndImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("and", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndImmCc::AndImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndReg::AndReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegCc::AndRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegReg::AndRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AndRegRegCc::AndRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AndsImmPclr::AndsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndsRegPclr::AndsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorImm::EorImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eor", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorImmCc::EorImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorReg::EorReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegCc::EorRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegReg::EorRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    EorRegRegCc::EorRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    EorsImmPclr::EorsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorsRegPclr::EorsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubImm::SubImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sub", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubImmCc::SubImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubReg::SubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegCc::SubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegReg::SubRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SubRegRegCc::SubRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SubsImmPclr::SubsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubsRegPclr::SubsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbImm::RsbImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbImmCc::RsbImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbReg::RsbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegCc::RsbRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegReg::RsbRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RsbRegRegCc::RsbRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RsbsImmPclr::RsbsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbsRegPclr::RsbsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddImm::AddImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("add", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddImmCc::AddImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddReg::AddReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegCc::AddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegReg::AddRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AddRegRegCc::AddRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AddsImmPclr::AddsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddsRegPclr::AddsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrImm::AdrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdrImmCc::AdrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImm::AdcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImmCc::AdcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcReg::AdcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegCc::AdcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegReg::AdcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AdcRegRegCc::AdcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AdcsImmPclr::AdcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcsRegPclr::AdcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcImm::SbcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcImmCc::SbcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcReg::SbcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegCc::SbcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegReg::SbcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SbcRegRegCc::SbcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SbcsImmPclr::SbcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcsRegPclr::SbcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscImm::RscImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscImmCc::RscImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscReg::RscReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegCc::RscRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegReg::RscRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RscRegRegCc::RscRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RscsImmPclr::RscsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscsRegPclr::RscsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstImm::TstImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tst", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstImmCc::TstImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstReg::TstReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegCc::TstRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegReg::TstRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TstRegRegCc::TstRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TstsImmPclr::TstsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstsRegPclr::TstsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqImm::TeqImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teq", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqImmCc::TeqImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqReg::TeqReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegCc::TeqRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegReg::TeqRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TeqRegRegCc::TeqRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TeqsImmPclr::TeqsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqsRegPclr::TeqsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpImm::CmpImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpImmCc::CmpImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpReg::CmpReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegCc::CmpRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegReg::CmpRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmpRegRegCc::CmpRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmpsImmPclr::CmpsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpsRegPclr::CmpsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnImm::CmnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnImmCc::CmnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnReg::CmnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegCc::CmnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegReg::CmnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmnRegRegCc::CmnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmnsImmPclr::CmnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnsRegPclr::CmnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrImm::OrrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrImmCc::OrrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrReg::OrrReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegCc::OrrRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegReg::OrrRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrrRegRegCc::OrrRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrrsImmPclr::OrrsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrsRegPclr::OrrsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnImm::OrnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnImmCc::OrnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnReg::OrnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegCc::OrnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegReg::OrnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrnRegRegCc::OrnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrnsImmPclr::OrnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnsRegPclr::OrnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovImm::MovImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mov", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovImmCc::MovImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovReg::MovReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegCc::MovRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegReg::MovRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovRegRegCc::MovRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovsImmPclr::MovsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovsRegPclr::MovsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicImm::BicImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bic", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicImmCc::BicImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicReg::BicReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegCc::BicRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegReg::BicRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    BicRegRegCc::BicRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    BicsImmPclr::BicsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicsRegPclr::BicsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnImm::MvnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnImmCc::MvnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnReg::MvnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegCc::MvnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegReg::MvnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MvnRegRegCc::MvnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MvnsImmPclr::MvnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnsRegPclr::MvnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtImm::MovtImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movt", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtImmCc::MovtImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtReg::MovtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegCc::MovtRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegReg::MovtRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovtRegRegCc::MovtRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovtsImmPclr::MovtsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtsRegPclr::MovtsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QaddRegCc::QaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd16Reg::Qadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd8Reg::Qadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdaddRegCc::QdaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubReg::QsubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubRegCc::QsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub16Reg::Qsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub8Reg::Qsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdsubRegCc::QdsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QasxReg::QasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsaxReg::QsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd8RegCc::Sadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd16RegCc::Sadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub8RegCc::Ssub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub16RegCc::Ssub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxReg::SasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxRegCc::SasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxReg::SsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxRegCc::SsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd8Reg::Shadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd16Reg::Shadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub8Reg::Shsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub16Reg::Shsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxReg::ShasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxRegCc::ShasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxReg::ShsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxRegCc::ShsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd16Reg::Uqadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd8Reg::Uqadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub16Reg::Uqsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub8Reg::Uqsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqasxReg::UqasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqsaxReg::UqsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd16RegCc::Uadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd8RegCc::Uadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub16RegCc::Usub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub8RegCc::Usub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UasxRegCc::UasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UsaxRegCc::UsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd16Reg::Uhadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd8Reg::Uhadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub16Reg::Uhsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub8Reg::Uhsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhasxReg::UhasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhsaxReg::UhsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhbtReg::PkhbtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhbt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhtbReg::PkhtbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhtb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrXImm::AdrXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    AdrpXImm::AdrpXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adrp", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXImm::AndXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("and", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXImmCc::AndXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXSReg::AndXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXSRegCc::AndXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXEReg::AndXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXERegCc::AndXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    EorXImm::EorXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("eor", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EorXSReg::EorXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EorXEReg::EorXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EonXSReg::EonXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("eon", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXImm::SubXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("sub", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXImmCc::SubXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SubXSReg::SubXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXSRegCc::SubXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SubXEReg::SubXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXERegCc::SubXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXImm::AddXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("add", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXImmCc::AddXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXSReg::AddXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXSRegCc::AddXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXEReg::AddXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXERegCc::AddXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AdcXSReg::AdcXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	flags[IsInteger] = true;;
    }

    AdcXSRegCc::AdcXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SbcXSReg::SbcXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	flags[IsInteger] = true;;
    }

    SbcXSRegCc::SbcXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    OrrXImm::OrrXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("orr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrrXSReg::OrrXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrrXEReg::OrrXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrnXSReg::OrnXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    BicXSReg::BicXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    BicXSRegCc::BicXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    Madd64::Madd64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("madd", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Msub64::Msub64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("msub", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smaddl64::Smaddl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("smaddl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smsubl64::Smsubl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("smsubl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smulh64::Smulh64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("smulh", machInst, IntMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Umaddl64::Umaddl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("umaddl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Umsubl64::Umsubl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("umsubl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Umulh64::Umulh64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("umulh", machInst, IntMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Asrv64::Asrv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("asrv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Lslv64::Lslv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("lslv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Lsrv64::Lsrv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("lsrv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Rorv64::Rorv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("rorv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Sdiv64::Sdiv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("sdiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Udiv64::Udiv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("udiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Cls64::Cls64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("cls", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Clz64::Clz64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Rbit64::Rbit64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Rev64::Rev64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Rev1664::Rev1664(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Rev3264::Rev3264(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev32", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Mrs64::Mrs64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("mrs", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
    }

    MrsNZCV64::MrsNZCV64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("mrsNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Msr64::Msr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrNZCV64::MsrNZCV64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("msrNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    Dczva::Dczva(ExtMachInst machInst, IntRegIndex _base, IntRegIndex _dest, uint64_t _imm)
         : SysDC64("dczva", machInst, MemWriteOp,
                 (IntRegIndex)_base, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_DCZID_EL0 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    MsrSP64::MsrSP64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrSP", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrDAIFSet64::MsrDAIFSet64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrDAIFSet", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrDAIFClr64::MsrDAIFClr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrDAIFClr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    CcmnImm64::CcmnImm64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompImmOp("ccmn", machInst, IntAluOp,
                         _op1, _imm, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmpImm64::CcmpImm64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompImmOp("ccmp", machInst, IntAluOp,
                         _op1, _imm, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmnReg64::CcmnReg64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompRegOp("ccmn", machInst, IntAluOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmpReg64::CcmpReg64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompRegOp("ccmp", machInst, IntAluOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Csel64::Csel64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csel", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csinc64::Csinc64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csinc", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csinv64::Csinv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csinv", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csneg64::Csneg64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csneg", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    B::B(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("b", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    B::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Bl::Bl(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("bl", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    Bl::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    BlxImm::BlxImm(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("blx", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    BlxImm::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.nextThumb(!branchPC.thumb());

            pcs.instNPC((uint32_t)(branchPC.thumb() ? (roundDown(branchPC.instPC(),4) + imm) :
                                (branchPC.instPC() + imm)));
            
        pcs.advance();
        return pcs;
    }

    BlxReg::BlxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("blx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (0)
            flags[IsReturn] = true;
    }

    BxReg::BxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("bx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == INTREG_LR)
            flags[IsReturn] = true;
    }

    BxjReg::BxjReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("bxj", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == INTREG_LR)
            flags[IsReturn] = true;
    }

    Cbz::Cbz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    ArmISA::PCState
    Cbz::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Cbnz::Cbnz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    ArmISA::PCState
    Cbnz::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Tbb::Tbb(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbb", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    Tbh::Tbh(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbh", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    B64::B64(ExtMachInst machInst,
                                          int64_t _imm)
        : BranchImm64("b", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
    }

    Bl64::Bl64(ExtMachInst machInst,
                                          int64_t _imm)
        : BranchImm64("bl", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = INTREG_X30;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Br64::Br64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchReg64("br", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blr64::Blr64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchReg64("blr", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_X30;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    BCond64::BCond64(ExtMachInst machInst,
                                          int64_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond64("b", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
    }

    Ret64::Ret64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchRet64("ret", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

        Eret64::Eret64(ExtMachInst machInst)  : BranchEret64("eret", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        }

    Cbz64::Cbz64(ExtMachInst machInst,
                                          int64_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg64("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Cbnz64::Cbnz64(ExtMachInst machInst,
                                          int64_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg64("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbz64::Tbz64(ExtMachInst machInst,
                                          int64_t _imm1, int64_t _imm2,
                                          IntRegIndex _op1)
        : BranchImmImmReg64("tbz", machInst, IntAluOp,
                         _imm1, _imm2, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbnz64::Tbnz64(ExtMachInst machInst,
                                          int64_t _imm1, int64_t _imm2,
                                          IntRegIndex _op1)
        : BranchImmImmReg64("tbnz", machInst, IntAluOp,
                         _imm1, _imm2, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Mla::Mla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MlaCc::MlaCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mlas", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mls::Mls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mul::Mul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("mul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MulCc::MulCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("muls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlabbCc::SmlabbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlabtCc::SmlabtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlatbCc::SmlatbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlattCc::SmlattCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmladCc::SmladCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmladxCc::SmladxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smladxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlal::Smlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlalCc::SmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlalbb::Smlalbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlalbt::Smlalbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaltb::Smlaltb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaltt::Smlaltt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlald::Smlald(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlald", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaldx::Smlaldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlawbCc::SmlawbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlawtCc::SmlawtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlsdCc::SmlsdCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsds", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlsdxCc::SmlsdxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsdxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlsld::Smlsld(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsld", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlsldx::Smlsldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmla::Smmla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmlar::Smmlar(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlar", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmls::Smmls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmlsr::Smmlsr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlsr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmul::Smmul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmulr::Smmulr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmulr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmuadCc::SmuadCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmuadxCc::SmuadxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuadxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulbb::Smulbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulbt::Smulbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smultb::Smultb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smultt::Smultt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smull::Smull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmullCc::SmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulwb::Smulwb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulwt::Smulwt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smusd::Smusd(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusd", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smusdx::Smusdx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusdx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umaal::Umaal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umaal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umlal::Umlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    UmlalCc::UmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umull::Umull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    UmullCc::UmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sdiv::Sdiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sdiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Udiv::Udiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("udiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmsr::Vmsr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmsr", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmsrFpscr::VmsrFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmsr", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmrs::Vmrs(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmrs", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmrsFpscr::VmrsFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmrs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_FP + CC_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        VmrsApsrFpscr::VmrsApsrFpscr(ExtMachInst machInst)  : PredOp("vmrs", machInst, SimdFloatMiscOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_FP + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    VmovImmS::VmovImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovImmD::VmovImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovImmQ::VmovImmQ(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegS::VmovRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegD::VmovRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegQ::VmovRegQ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegB::VmovCoreRegB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegH::VmovCoreRegH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegW::VmovCoreRegW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreUB::VmovRegCoreUB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreUH::VmovRegCoreUH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreSB::VmovRegCoreSB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreSH::VmovRegCoreSH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreW::VmovRegCoreW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmov2Reg2Core::Vmov2Reg2Core(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmov2Core2Reg::Vmov2Core2Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = op1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmaS::VfmaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmaD::VfmaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmsS::VfmsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmsD::VfmsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmaS::VfnmaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmaD::VfnmaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmsS::VfnmsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmsD::VfnmsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VaddS::VaddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vadds", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VaddD::VaddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vaddd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsubS::VsubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubs", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsubD::VsubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VdivS::VdivS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivs", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VdivD::VdivD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivd", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmulS::VmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmulD::VmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsqrtS::VsqrtS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrts", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsqrtD::VsqrtD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrtd", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnegS::VnegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnegD::VnegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VabsS::VabsS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabss", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VabsD::VabsD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabsd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlaS::VmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlaD::VmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlsS::VmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlsD::VmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlaS::VnmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlaD::VnmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlsS::VnmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlsD::VnmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmulS::VnmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmulD::VnmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUIntFpS::VcvtUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUIntFpD::VcvtUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSIntFpS::VcvtSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSIntFpD::VcvtSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntSR::VcvtFpUIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntDR::VcvtFpUIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntSR::VcvtFpSIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntDR::VcvtFpSIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntS::VcvtFpUIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntD::VcvtFpUIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntS::VcvtFpSIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntD::VcvtFpSIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpD::VcvtFpSFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpDFpS::VcvtFpDFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpHTFpS::VcvtFpHTFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpHBFpS::VcvtFpHBFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpHT::VcvtFpSFpHT(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpHB::VcvtFpSFpHB(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpS::VcmpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmps", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpD::VcmpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpd", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpZeroS::VcmpZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpZeroD::VcmpZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeS::VcmpeS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpes", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeD::VcmpeD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmped", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeZeroS::VcmpeZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeZeroD::VcmpeZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFixedS::VcvtFpSFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFixedD::VcvtFpSFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUFixedS::VcvtFpUFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUFixedD::VcvtFpUFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSFixedFpS::VcvtSFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSFixedFpD::VcvtSFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUFixedFpS::VcvtUFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUFixedFpD::VcvtUFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSHFixedS::VcvtFpSHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSHFixedD::VcvtFpSHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUHFixedS::VcvtFpUHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUHFixedD::VcvtFpUHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSHFixedFpS::VcvtSHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSHFixedFpD::VcvtSHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUHFixedFpS::VcvtUHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUHFixedFpD::VcvtUHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FmovImmS::FmovImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FmovImmD::FmovImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovRegS::FmovRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovRegD::FmovRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovCoreRegW::FmovCoreRegW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovCoreRegX::FmovCoreRegX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovUCoreRegX::FmovUCoreRegX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovRegCoreW::FmovRegCoreW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovRegCoreX::FmovRegCoreX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovURegCoreX::FmovURegCoreX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FMAddD::FMAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmadd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMAddS::FMAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmadd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMSubD::FMSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmsub", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMSubS::FMSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmsub", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMAddD::FNMAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmadd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMAddS::FNMAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmadd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMSubD::FNMSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmsub", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMSubS::FNMSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmsub", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAddS::FAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAddD::FAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSubS::FSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSubD::FSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FDivS::FDivS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fdiv", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FDivD::FDivD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fdiv", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMulS::FMulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMulD::FMulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMulS::FNMulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fnmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMulD::FNMulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fnmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinS::FMinS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinD::FMinD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxS::FMaxS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxD::FMaxD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinNMS::FMinNMS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fminnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinNMD::FMinNMD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fminnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxNMS::FMaxNMS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmaxnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxNMD::FMaxNMD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmaxnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSqrtS::FSqrtS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fsqrt", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSqrtD::FSqrtD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fsqrt", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNegS::FNegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fneg", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNegD::FNegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fneg", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAbsS::FAbsS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fabs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAbsD::FAbsD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fabs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntNS::FRIntNS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintn", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntND::FRIntND(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintn", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntPS::FRIntPS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintp", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntPD::FRIntPD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintp", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntMS::FRIntMS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintm", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntMD::FRIntMD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintm", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntZS::FRIntZS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintz", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntZD::FRIntZD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintz", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntAS::FRIntAS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinta", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntAD::FRIntAD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinta", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntIS::FRIntIS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinti", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntID::FRIntID(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinti", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntXS::FRIntXS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintx", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntXD::FRIntXD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintx", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtWUIntFpD::FcvtWUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWSIntFpD::FcvtWSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWUIntFpS::FcvtWUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWSIntFpS::FcvtWSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXUIntFpD::FcvtXUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXSIntFpD::FcvtXSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXUIntFpS::FcvtXUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXSIntFpS::FcvtXSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtFpSIntXDN::FcvtFpSIntXDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDP::FcvtFpSIntXDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDM::FcvtFpSIntXDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDZ::FcvtFpSIntXDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDA::FcvtFpSIntXDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDN::FcvtFpSIntWDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDP::FcvtFpSIntWDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDM::FcvtFpSIntWDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDZ::FcvtFpSIntWDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDA::FcvtFpSIntWDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDN::FcvtFpUIntXDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDP::FcvtFpUIntXDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDM::FcvtFpUIntXDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDZ::FcvtFpUIntXDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDA::FcvtFpUIntXDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDN::FcvtFpUIntWDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDP::FcvtFpUIntWDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDM::FcvtFpUIntWDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDZ::FcvtFpUIntWDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDA::FcvtFpUIntWDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSN::FcvtFpSIntXSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSP::FcvtFpSIntXSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSM::FcvtFpSIntXSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSZ::FcvtFpSIntXSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSA::FcvtFpSIntXSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSN::FcvtFpSIntWSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSP::FcvtFpSIntWSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSM::FcvtFpSIntWSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSZ::FcvtFpSIntWSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSA::FcvtFpSIntWSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSN::FcvtFpUIntXSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSP::FcvtFpUIntXSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSM::FcvtFpUIntXSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSZ::FcvtFpUIntXSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSA::FcvtFpUIntXSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSN::FcvtFpUIntWSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSP::FcvtFpUIntWSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSM::FcvtFpUIntWSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSZ::FcvtFpUIntWSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSA::FcvtFpUIntWSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FCvtFpSFpD::FCvtFpSFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpDFpS::FcvtFpDFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpHFpD::FcvtFpHFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpHFpS::FcvtFpHFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpDFpH::FcvtFpDFpH(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpSFpH::FcvtFpSFpH(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpImmD::FCmpImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmp", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpRegD::FCmpRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmp", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpImmS::FCmpImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmp", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpRegS::FCmpRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmp", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpEImmD::FCmpEImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmpe", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpERegD::FCmpERegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmpe", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpEImmS::FCmpEImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmpe", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpERegS::FCmpERegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmpe", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpRegD::FCCmpRegD(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmp", machInst, SimdFloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpRegS::FCCmpRegS(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmp", machInst, SimdFloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpERegD::FCCmpERegD(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmpe", machInst, SimdFloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpERegS::FCCmpERegS(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmpe", machInst, SimdFloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpSFixedDX::FcvtFpSFixedDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpDX::FcvtSFixedFpDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedDX::FcvtFpUFixedDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpDX::FcvtUFixedFpDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedSX::FcvtFpSFixedSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpSX::FcvtSFixedFpSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedSX::FcvtFpUFixedSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpSX::FcvtUFixedFpSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedDW::FcvtFpSFixedDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpDW::FcvtSFixedFpDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedDW::FcvtFpUFixedDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpDW::FcvtUFixedFpDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedSW::FcvtFpSFixedSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpSW::FcvtSFixedFpSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedSW::FcvtFpUFixedSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpSW::FcvtUFixedFpSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FCSelD::FCSelD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : FpCondSelOp("fcsel", machInst, FloatAddOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FCSelS::FCSelS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : FpCondSelOp("fcsel", machInst, FloatAddOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    NVtbl1::NVtbl1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl2::NVtbl2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl3::NVtbl3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl4::NVtbl4(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx1::NVtbx1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx2::NVtbx2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx3::NVtbx3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx4::NVtbx4(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

#endif
#if __SPLIT == 3

    VldMult64::VldMult64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _numRegs, bool _wb) :
            VldMultOp64(
                "vldmult64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _numRegs, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

    VstMult64::VstMult64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _numRegs, bool _wb) :
            VstMultOp64(
                "vstmult64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _numRegs, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

    VldSingle64::VldSingle64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _index, bool _wb, bool _replicate) :
            VldSingleOp64(
                "vldsingle64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _index, _wb,
                _replicate)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

    VstSingle64::VstSingle64(
        ExtMachInst machInst, RegIndex rn, RegIndex vd, RegIndex rm,
        uint8_t _eSize, uint8_t _dataSize, uint8_t _numStructElems,
        uint8_t _index, bool _wb, bool _replicate) :
            VstSingleOp64(
                "vstsingle64", machInst, IntAluOp, rn, vd, rm,
                _eSize, _dataSize, _numStructElems, _index, _wb,
                _replicate)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    }

    uint64_t join32to64(uint32_t r1, uint32_t r0)
    {
        uint64_t r = r1;
        r <<= 32;
        r |= r0;
        return r;
    }
    
        Arm::Arm(ExtMachInst machInst)  : PredOp("arm", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Quiesce::Quiesce(ExtMachInst machInst)  : PredOp("quiesce", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceNs::QuiesceNs(ExtMachInst machInst)  : PredOp("quiesceNs", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceNs64::QuiesceNs64(ExtMachInst machInst)  : PredOp("quiesceNs", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceCycles::QuiesceCycles(ExtMachInst machInst)  : PredOp("quiesceCycles", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceCycles64::QuiesceCycles64(ExtMachInst machInst)  : PredOp("quiesceCycles", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceTime::QuiesceTime(ExtMachInst machInst)  : PredOp("quiesceTime", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceTime64::QuiesceTime64(ExtMachInst machInst)  : PredOp("quiesceTime", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Rpns::Rpns(ExtMachInst machInst)  : PredOp("rpns", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Rpns64::Rpns64(ExtMachInst machInst)  : PredOp("rpns", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WakeCPU::WakeCPU(ExtMachInst machInst)  : PredOp("wakeCPU", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WakeCPU64::WakeCPU64(ExtMachInst machInst)  : PredOp("wakeCPU", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_ivlb::Deprecated_ivlb(ExtMachInst machInst)  : PredOp("deprecated_ivlb", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_ivle::Deprecated_ivle(ExtMachInst machInst)  : PredOp("deprecated_ivle", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_exit::Deprecated_exit(ExtMachInst machInst)  : PredOp("deprecated_exit", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5exit::M5exit(ExtMachInst machInst)  : PredOp("m5exit", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5fail::M5fail(ExtMachInst machInst)  : PredOp("m5fail", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5exit64::M5exit64(ExtMachInst machInst)  : PredOp("m5exit", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Loadsymbol::Loadsymbol(ExtMachInst machInst)  : PredOp("loadsymbol", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Initparam::Initparam(ExtMachInst machInst)  : PredOp("initparam", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Initparam64::Initparam64(ExtMachInst machInst)  : PredOp("initparam", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Resetstats::Resetstats(ExtMachInst machInst)  : PredOp("resetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Resetstats64::Resetstats64(ExtMachInst machInst)  : PredOp("resetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpstats::Dumpstats(ExtMachInst machInst)  : PredOp("dumpstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpstats64::Dumpstats64(ExtMachInst machInst)  : PredOp("dumpstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpresetstats::Dumpresetstats(ExtMachInst machInst)  : PredOp("dumpresetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpresetstats64::Dumpresetstats64(ExtMachInst machInst)  : PredOp("dumpresetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5checkpoint::M5checkpoint(ExtMachInst machInst)  : PredOp("m5checkpoint", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5checkpoint64::M5checkpoint64(ExtMachInst machInst)  : PredOp("m5checkpoint", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5readfile::M5readfile(ExtMachInst machInst)  : PredOp("m5readfile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5readfile64::M5readfile64(ExtMachInst machInst)  : PredOp("m5readfile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5writefile::M5writefile(ExtMachInst machInst)  : PredOp("m5writefile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5writefile64::M5writefile64(ExtMachInst machInst)  : PredOp("m5writefile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5break::M5break(ExtMachInst machInst)  : PredOp("m5break", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5switchcpu::M5switchcpu(ExtMachInst machInst)  : PredOp("m5switchcpu", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5addsymbol::M5addsymbol(ExtMachInst machInst)  : PredOp("m5addsymbol", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5addsymbol64::M5addsymbol64(ExtMachInst machInst)  : PredOp("m5addsymbol", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5panic::M5panic(ExtMachInst machInst)  : PredOp("m5panic", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workbegin::M5workbegin(ExtMachInst machInst)  : PredOp("m5workbegin", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workbegin64::M5workbegin64(ExtMachInst machInst)  : PredOp("m5workbegin", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workend::M5workend(ExtMachInst machInst)  : PredOp("m5workend", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workend64::M5workend64(ExtMachInst machInst)  : PredOp("m5workend", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

namespace Aarch64
{
    StaticInstPtr
    decodeDataProcImm(ExtMachInst machInst)
    {
        IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
        IntRegIndex rdsp = makeSP(rd);
        IntRegIndex rdzr = makeZero(rd);
        IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
        IntRegIndex rnsp = makeSP(rn);

        uint8_t opc = bits(machInst, 30, 29);
        bool sf = bits(machInst, 31);
        bool n = bits(machInst, 22);
        uint8_t immr = bits(machInst, 21, 16);
        uint8_t imms = bits(machInst, 15, 10);
        switch (bits(machInst, 25, 23)) {
          case 0x0:
          case 0x1:
          {
            uint64_t immlo = bits(machInst, 30, 29);
            uint64_t immhi = bits(machInst, 23, 5);
            uint64_t imm = (immlo << 0) | (immhi << 2);
            if (bits(machInst, 31) == 0)
                return new AdrXImm(machInst, rdzr, INTREG_ZERO, sext<21>(imm));
            else
                return new AdrpXImm(machInst, rdzr, INTREG_ZERO,
                                    sext<33>(imm << 12));
          }
          case 0x2:
          case 0x3:
          {
            uint32_t imm12 = bits(machInst, 21, 10);
            uint8_t shift = bits(machInst, 23, 22);
            uint32_t imm;
            if (shift == 0x0)
                imm = imm12 << 0;
            else if (shift == 0x1)
                imm = imm12 << 12;
            else
                return new Unknown64(machInst);
            switch (opc) {
              case 0x0:
                return new AddXImm(machInst, rdsp, rnsp, imm);
              case 0x1:
                return new AddXImmCc(machInst, rdzr, rnsp, imm);
              case 0x2:
                return new SubXImm(machInst, rdsp, rnsp, imm);
              case 0x3:
                return new SubXImmCc(machInst, rdzr, rnsp, imm);
            }
          }
          case 0x4:
          {
            if (!sf && n)
                return new Unknown64(machInst);
            // len = MSB(n:NOT(imms)), len < 1 is undefined.
            uint8_t len = 0;
            if (n) {
                len = 6;
            } else if (imms == 0x3f || imms == 0x3e) {
                return new Unknown64(machInst);
            } else {
                len = findMsbSet(imms ^ 0x3f);
            }
            // Generate r, s, and size.
            uint64_t r = bits(immr, len - 1, 0);
            uint64_t s = bits(imms, len - 1, 0);
            uint8_t size = 1 << len;
            if (s == size - 1)
                return new Unknown64(machInst);
            // Generate the pattern with s 1s, rotated by r, with size bits.
            uint64_t pattern = mask(s + 1);
            if (r) {
                pattern = (pattern >> r) | (pattern << (size - r));
                pattern &= mask(size);
            }
            uint8_t width = sf ? 64 : 32;
            // Replicate that to fill up the immediate.
            for (unsigned i = 1; i < (width / size); i *= 2)
                pattern |= (pattern << (i * size));
            uint64_t imm = pattern;

            switch (opc) {
              case 0x0:
                return new AndXImm(machInst, rdsp, rn, imm);
              case 0x1:
                return new OrrXImm(machInst, rdsp, rn, imm);
              case 0x2:
                return new EorXImm(machInst, rdsp, rn, imm);
              case 0x3:
                return new AndXImmCc(machInst, rdzr, rn, imm);
            }
          }
          case 0x5:
          {
            IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
            IntRegIndex rdzr = makeZero(rd);
            uint32_t imm16 = bits(machInst, 20, 5);
            uint32_t hw = bits(machInst, 22, 21);
            switch (opc) {
              case 0x0:
                return new Movn(machInst, rdzr, imm16, hw * 16);
              case 0x1:
                return new Unknown64(machInst);
              case 0x2:
                return new Movz(machInst, rdzr, imm16, hw * 16);
              case 0x3:
                return new Movk(machInst, rdzr, imm16, hw * 16);
            }
          }
          case 0x6:
            if ((sf != n) || (!sf && (bits(immr, 5) || bits(imms, 5))))
                return new Unknown64(machInst);
            switch (opc) {
              case 0x0:
                return new Sbfm64(machInst, rdzr, rn, immr, imms);
              case 0x1:
                return new Bfm64(machInst, rdzr, rn, immr, imms);
              case 0x2:
                return new Ubfm64(machInst, rdzr, rn, immr, imms);
              case 0x3:
                return new Unknown64(machInst);
            }
          case 0x7:
          {
            IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
            if (opc || bits(machInst, 21))
                return new Unknown64(machInst);
            else
                return new Extr64(machInst, rdzr, rn, rm, imms);
          }
        }
        return new FailUnimplemented("Unhandled Case8", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeBranchExcSys(ExtMachInst machInst)
    {
        switch (bits(machInst, 30, 29)) {
          case 0x0:
          {
            int64_t imm = sext<26>(bits(machInst, 25, 0)) << 2;
            if (bits(machInst, 31) == 0)
                return new B64(machInst, imm);
            else
                return new Bl64(machInst, imm);
          }
          case 0x1:
          {
            IntRegIndex rt = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
            if (bits(machInst, 25) == 0) {
                int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
                if (bits(machInst, 24) == 0)
                    return new Cbz64(machInst, imm, rt);
                else
                    return new Cbnz64(machInst, imm, rt);
            } else {
                uint64_t bitmask = 0x1;
                bitmask <<= bits(machInst, 23, 19);
                int64_t imm = sext<14>(bits(machInst, 18, 5)) << 2;
                if (bits(machInst, 31))
                    bitmask <<= 32;
                if (bits(machInst, 24) == 0)
                    return new Tbz64(machInst, bitmask, imm, rt);
                else
                    return new Tbnz64(machInst, bitmask, imm, rt);
            }
          }
          case 0x2:
            // bit 30:26=10101
            if (bits(machInst, 31) == 0) {
                if (bits(machInst, 25, 24) || bits(machInst, 4))
                    return new Unknown64(machInst);
                int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
                ConditionCode condCode =
                    (ConditionCode)(uint8_t)(bits(machInst, 3, 0));
                return new BCond64(machInst, imm, condCode);
            } else if (bits(machInst, 25, 24) == 0x0) {
                if (bits(machInst, 4, 2))
                    return new Unknown64(machInst);
                uint8_t decVal = (bits(machInst, 1, 0) << 0) |
                                 (bits(machInst, 23, 21) << 2);
                switch (decVal) {
                  case 0x01:
                    return new Svc64(machInst);
                  case 0x02:
                    return new FailUnimplemented("hvc", machInst);
                  case 0x03:
                    return new Smc64(machInst);
                  case 0x04:
                    return new FailUnimplemented("brk", machInst);
                  case 0x08:
                    return new FailUnimplemented("hlt", machInst);
                  case 0x15:
                    return new FailUnimplemented("dcps1", machInst);
                  case 0x16:
                    return new FailUnimplemented("dcps2", machInst);
                  case 0x17:
                    return new FailUnimplemented("dcps3", machInst);
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 25, 22) == 0x4) {
                // bit 31:22=1101010100
                bool l = bits(machInst, 21);
                uint8_t op0 = bits(machInst, 20, 19);
                uint8_t op1 = bits(machInst, 18, 16);
                uint8_t crn = bits(machInst, 15, 12);
                uint8_t crm = bits(machInst, 11, 8);
                uint8_t op2 = bits(machInst, 7, 5);
                IntRegIndex rt = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
                switch (op0) {
                  case 0x0:
                    if (rt != 0x1f || l)
                        return new Unknown64(machInst);
                    if (crn == 0x2 && op1 == 0x3) {
                        switch (op2) {
                          case 0x0:
                            return new NopInst(machInst);
                          case 0x1:
                            return new YieldInst(machInst);
                          case 0x2:
                            return new WfeInst(machInst);
                          case 0x3:
                            return new WfiInst(machInst);
                          case 0x4:
                            return new SevInst(machInst);
                          case 0x5:
                            return new SevlInst(machInst);
                          default:
                            return new Unknown64(machInst);
                        }
                    } else if (crn == 0x3 && op1 == 0x3) {
                        switch (op2) {
                          case 0x2:
                            return new Clrex64(machInst);
                          case 0x4:
                            return new Dsb64(machInst);
                          case 0x5:
                            return new Dmb64(machInst);
                          case 0x6:
                            return new Isb64(machInst);
                          default:
                            return new Unknown64(machInst);
                        }
                    } else if (crn == 0x4) {
                        // MSR immediate
                        switch (op1 << 3 | op2) {
                          case 0x5:
                            // SP
                            return new MsrSP64(machInst,
                                               (IntRegIndex) MISCREG_SPSEL,
                                               INTREG_ZERO,
                                               crm & 0x1);
                          case 0x1e:
                            // DAIFSet
                            return new MsrDAIFSet64(
                                machInst,
                                (IntRegIndex) MISCREG_DAIF,
                                INTREG_ZERO,
                                crm);
                          case 0x1f:
                            // DAIFClr
                            return new MsrDAIFClr64(
                                machInst,
                                (IntRegIndex) MISCREG_DAIF,
                                INTREG_ZERO,
                                crm);
                          default:
                            return new Unknown64(machInst);
                        }
                    } else {
                        return new Unknown64(machInst);
                    }
                    break;
                  case 0x1:
                  case 0x2:
                  case 0x3:
                  {
                    // bit 31:22=1101010100, 20:19=11
                    bool read = l;
                    MiscRegIndex miscReg =
                        decodeAArch64SysReg(op0, op1, crn, crm, op2);
                    if (read) {
                        if ((miscReg == MISCREG_DC_CIVAC_Xt) ||
                            (miscReg == MISCREG_DC_CVAC_Xt) ||
                            (miscReg == MISCREG_DC_ZVA_Xt)) {
                            return new Unknown64(machInst);
                        }
                    }
                    // Check for invalid registers
                    if (miscReg == MISCREG_UNKNOWN) {
                        return new Unknown64(machInst);
                    } else if (miscRegInfo[miscReg][MISCREG_IMPLEMENTED]) {
                        if (miscReg == MISCREG_NZCV) {
                            if (read)
                                return new MrsNZCV64(machInst, rt, (IntRegIndex) miscReg);
                            else
                                return new MsrNZCV64(machInst, (IntRegIndex) miscReg, rt);
                        }
                        uint32_t iss = msrMrs64IssBuild(read, op0, op1, crn, crm, op2, rt);
                        if (miscReg == MISCREG_DC_ZVA_Xt && !read)
                            return new Dczva(machInst, rt, (IntRegIndex) miscReg, iss);

                        if (read) {
                            StaticInstPtr si = new Mrs64(machInst, rt, (IntRegIndex) miscReg, iss);
                            if (miscRegInfo[miscReg][MISCREG_UNVERIFIABLE])
                                si->setFlag(StaticInst::IsUnverifiable);
                            return si;
                        } else
                            return new Msr64(machInst, (IntRegIndex) miscReg, rt, iss);
                    } else if (miscRegInfo[miscReg][MISCREG_WARN_NOT_FAIL]) {
                        std::string full_mnem = csprintf("%s %s",
                            read ? "mrs" : "msr", miscRegName[miscReg]);
                        return new WarnUnimplemented(read ? "mrs" : "msr",
                                                     machInst, full_mnem);
                    } else {
                        return new FailUnimplemented(read ? "mrs" : "msr",
                                    machInst,
                                    csprintf("%s %s",
                                      read ? "mrs" : "msr",
                                      miscRegName[miscReg]));
                    }
                  }
                  break;
                }
            } else if (bits(machInst, 25) == 0x1) {
                uint8_t opc = bits(machInst, 24, 21);
                uint8_t op2 = bits(machInst, 20, 16);
                uint8_t op3 = bits(machInst, 15, 10);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                uint8_t op4 = bits(machInst, 4, 0);
                if (op2 != 0x1f || op3 != 0x0 || op4 != 0x0)
                    return new Unknown64(machInst);
                switch (opc) {
                  case 0x0:
                    return new Br64(machInst, rn);
                  case 0x1:
                    return new Blr64(machInst, rn);
                  case 0x2:
                    return new Ret64(machInst, rn);
                  case 0x4:
                    if (rn != 0x1f)
                        return new Unknown64(machInst);
                    return new Eret64(machInst);
                  case 0x5:
                    if (rn != 0x1f)
                        return new Unknown64(machInst);
                    return new FailUnimplemented("dret", machInst);
                }
            }
          default:
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case7", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeLoadsStores(ExtMachInst machInst)
    {
        // bit 27,25=10
        switch (bits(machInst, 29, 28)) {
          case 0x0:
            if (bits(machInst, 26) == 0) {
                if (bits(machInst, 24) != 0)
                    return new Unknown64(machInst);
                IntRegIndex rt = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                IntRegIndex rnsp = makeSP(rn);
                IntRegIndex rt2 = (IntRegIndex)(uint8_t)bits(machInst, 14, 10);
                IntRegIndex rs = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
                uint8_t opc = (bits(machInst, 15) << 0) |
                              (bits(machInst, 23, 21) << 1);
                uint8_t size = bits(machInst, 31, 30);
                switch (opc) {
                  case 0x0:
                    switch (size) {
                      case 0x0:
                        return new STXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new STXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new STXRX64(machInst, rt, rnsp, rs);
                    }
                  case 0x1:
                    switch (size) {
                      case 0x0:
                        return new STLXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new STLXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new STLXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new STLXRX64(machInst, rt, rnsp, rs);
                    }
                  case 0x2:
                    switch (size) {
                      case 0x0:
                      case 0x1:
                        return new Unknown64(machInst);
                      case 0x2:
                        return new STXPW64(machInst, rs, rt, rt2, rnsp);
                      case 0x3:
                        return new STXPX64(machInst, rs, rt, rt2, rnsp);
                    }

                  case 0x3:
                    switch (size) {
                      case 0x0:
                      case 0x1:
                        return new Unknown64(machInst);
                      case 0x2:
                        return new STLXPW64(machInst, rs, rt, rt2, rnsp);
                      case 0x3:
                        return new STLXPX64(machInst, rs, rt, rt2, rnsp);
                    }

                  case 0x4:
                    switch (size) {
                      case 0x0:
                        return new LDXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new LDXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new LDXRX64(machInst, rt, rnsp, rs);
                    }
                  case 0x5:
                    switch (size) {
                      case 0x0:
                        return new LDAXRB64(machInst, rt, rnsp, rs);
                      case 0x1:
                        return new LDAXRH64(machInst, rt, rnsp, rs);
                      case 0x2:
                        return new LDAXRW64(machInst, rt, rnsp, rs);
                      case 0x3:
                        return new LDAXRX64(machInst, rt, rnsp, rs);
                    }
                  case 0x6:
                    switch (size) {
                      case 0x0:
                      case 0x1:
                        return new Unknown64(machInst);
                      case 0x2:
                        return new LDXPW64(machInst, rt, rt2, rnsp);
                      case 0x3:
                        return new LDXPX64(machInst, rt, rt2, rnsp);
                    }

                  case 0x7:
                    switch (size) {
                      case 0x0:
                      case 0x1:
                        return new Unknown64(machInst);
                      case 0x2:
                        return new LDAXPW64(machInst, rt, rt2, rnsp);
                      case 0x3:
                        return new LDAXPX64(machInst, rt, rt2, rnsp);
                    }

                  case 0x9:
                    switch (size) {
                      case 0x0:
                        return new STLRB64(machInst, rt, rnsp);
                      case 0x1:
                        return new STLRH64(machInst, rt, rnsp);
                      case 0x2:
                        return new STLRW64(machInst, rt, rnsp);
                      case 0x3:
                        return new STLRX64(machInst, rt, rnsp);
                    }
                  case 0xd:
                    switch (size) {
                      case 0x0:
                        return new LDARB64(machInst, rt, rnsp);
                      case 0x1:
                        return new LDARH64(machInst, rt, rnsp);
                      case 0x2:
                        return new LDARW64(machInst, rt, rnsp);
                      case 0x3:
                        return new LDARX64(machInst, rt, rnsp);
                    }
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 31)) {
                return new Unknown64(machInst);
            } else {
                return decodeNeonMem(machInst);
            }
          case 0x1:
          {
            if (bits(machInst, 24) != 0)
                return new Unknown64(machInst);
            uint8_t switchVal = (bits(machInst, 26) << 0) |
                                (bits(machInst, 31, 30) << 1);
            int64_t imm = sext<19>(bits(machInst, 23, 5)) << 2;
            IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
            switch (switchVal) {
              case 0x0:
                return new LDRWL64_LIT(machInst, rt, imm);
              case 0x1:
                return new LDRSFP64_LIT(machInst, rt, imm);
              case 0x2:
                return new LDRXL64_LIT(machInst, rt, imm);
              case 0x3:
                return new LDRDFP64_LIT(machInst, rt, imm);
              case 0x4:
                return new LDRSWL64_LIT(machInst, rt, imm);
              case 0x5:
                return new BigFpMemLit("ldr", machInst, rt, imm);
              case 0x6:
                return new PRFM64_LIT(machInst, rt, imm);
              default:
                return new Unknown64(machInst);
            }
          }
          case 0x2:
          {
            uint8_t opc = bits(machInst, 31, 30);
            if (opc >= 3)
                return new Unknown64(machInst);
            uint32_t size = 0;
            bool fp = bits(machInst, 26);
            bool load = bits(machInst, 22);
            if (fp) {
                size = 4 << opc;
            } else {
                if ((opc == 1) && !load)
                    return new Unknown64(machInst);
                size = (opc == 0 || opc == 1) ? 4 : 8;
            }
            uint8_t type = bits(machInst, 24, 23);
            int64_t imm = sext<7>(bits(machInst, 21, 15)) * size;

            IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
            IntRegIndex rt = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
            IntRegIndex rt2 = (IntRegIndex)(uint8_t)bits(machInst, 14, 10);

            bool noAlloc = (type == 0);
            bool signExt = !noAlloc && !fp && opc == 1;
            PairMemOp::AddrMode mode;
            const char *mnemonic = NULL;
            switch (type) {
              case 0x0:
              case 0x2:
                mode = PairMemOp::AddrMd_Offset;
                break;
              case 0x1:
                mode = PairMemOp::AddrMd_PostIndex;
                break;
              case 0x3:
                mode = PairMemOp::AddrMd_PreIndex;
                break;
              default:
                return new Unknown64(machInst);
            }
            if (load) {
                if (noAlloc)
                    mnemonic = "ldnp";
                else if (signExt)
                    mnemonic = "ldpsw";
                else
                    mnemonic = "ldp";
            } else {
                if (noAlloc)
                    mnemonic = "stnp";
                else
                    mnemonic = "stp";
            }

            return new LdpStp(mnemonic, machInst, size, fp, load, noAlloc,
                    signExt, false, false, imm, mode, rn, rt, rt2);
          }
          // bit 29:27=111, 25=0
          case 0x3:
          {
            uint8_t switchVal = (bits(machInst, 23, 22) << 0) |
                                (bits(machInst, 26) << 2) |
                                (bits(machInst, 31, 30) << 3);
            if (bits(machInst, 24) == 1) {
                uint64_t imm12 = bits(machInst, 21, 10);
                IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                IntRegIndex rnsp = makeSP(rn);
                switch (switchVal) {
                  case 0x00:
                    return new STRB64_IMM(machInst, rt, rnsp, imm12);
                  case 0x01:
                    return new LDRB64_IMM(machInst, rt, rnsp, imm12);
                  case 0x02:
                    return new LDRSBX64_IMM(machInst, rt, rnsp, imm12);
                  case 0x03:
                    return new LDRSBW64_IMM(machInst, rt, rnsp, imm12);
                  case 0x04:
                    return new STRBFP64_IMM(machInst, rt, rnsp, imm12);
                  case 0x05:
                    return new LDRBFP64_IMM(machInst, rt, rnsp, imm12);
                  case 0x06:
                    return new BigFpMemImm("str", machInst, false,
                                           rt, rnsp, imm12 << 4);
                  case 0x07:
                    return new BigFpMemImm("ldr", machInst, true,
                                           rt, rnsp, imm12 << 4);
                  case 0x08:
                    return new STRH64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x09:
                    return new LDRH64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0a:
                    return new LDRSHX64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0b:
                    return new LDRSHW64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0c:
                    return new STRHFP64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x0d:
                    return new LDRHFP64_IMM(machInst, rt, rnsp, imm12 << 1);
                  case 0x10:
                    return new STRW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x11:
                    return new LDRW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x12:
                    return new LDRSW64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x14:
                    return new STRSFP64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x15:
                    return new LDRSFP64_IMM(machInst, rt, rnsp, imm12 << 2);
                  case 0x18:
                    return new STRX64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x19:
                    return new LDRX64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1a:
                    return new PRFM64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1c:
                    return new STRDFP64_IMM(machInst, rt, rnsp, imm12 << 3);
                  case 0x1d:
                    return new LDRDFP64_IMM(machInst, rt, rnsp, imm12 << 3);
                  default:
                    return new Unknown64(machInst);
                }
            } else if (bits(machInst, 21) == 1) {
                if (bits(machInst, 11, 10) != 0x2)
                    return new Unknown64(machInst);
                if (!bits(machInst, 14))
                    return new Unknown64(machInst);
                IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                IntRegIndex rnsp = makeSP(rn);
                IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 20, 16);
                ArmExtendType type =
                    (ArmExtendType)(uint32_t)bits(machInst, 15, 13);
                uint8_t s = bits(machInst, 12);
                switch (switchVal) {
                  case 0x00:
                    return new STRB64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x01:
                    return new LDRB64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x02:
                    return new LDRSBX64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x03:
                    return new LDRSBW64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x04:
                    return new STRBFP64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x05:
                    return new LDRBFP64_REG(machInst, rt, rnsp, rm, type, 0);
                  case 0x6:
                    return new BigFpMemReg("str", machInst, false,
                                           rt, rnsp, rm, type, s * 4);
                  case 0x7:
                    return new BigFpMemReg("ldr", machInst, true,
                                           rt, rnsp, rm, type, s * 4);
                  case 0x08:
                    return new STRH64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x09:
                    return new LDRH64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x0a:
                    return new LDRSHX64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x0b:
                    return new LDRSHW64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x0c:
                    return new STRHFP64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x0d:
                    return new LDRHFP64_REG(machInst, rt, rnsp, rm, type, s);
                  case 0x10:
                    return new STRW64_REG(machInst, rt, rnsp, rm, type, s * 2);
                  case 0x11:
                    return new LDRW64_REG(machInst, rt, rnsp, rm, type, s * 2);
                  case 0x12:
                    return new LDRSW64_REG(machInst, rt, rnsp, rm, type, s * 2);
                  case 0x14:
                    return new STRSFP64_REG(machInst, rt, rnsp, rm, type, s * 2);
                  case 0x15:
                    return new LDRSFP64_REG(machInst, rt, rnsp, rm, type, s * 2);
                  case 0x18:
                    return new STRX64_REG(machInst, rt, rnsp, rm, type, s * 3);
                  case 0x19:
                    return new LDRX64_REG(machInst, rt, rnsp, rm, type, s * 3);
                  case 0x1a:
                    return new PRFM64_REG(machInst, rt, rnsp, rm, type, s * 3);
                  case 0x1c:
                    return new STRDFP64_REG(machInst, rt, rnsp, rm, type, s * 3);
                  case 0x1d:
                    return new LDRDFP64_REG(machInst, rt, rnsp, rm, type, s * 3);
                  default:
                    return new Unknown64(machInst);
                }
            } else {
                // bit 29:27=111, 25:24=00, 21=0
                switch (bits(machInst, 11, 10)) {
                  case 0x0:
                  {
                    IntRegIndex rt =
                        (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                    IntRegIndex rn =
                        (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                    IntRegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STURB64_IMM(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDURB64_IMM(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDURSBX64_IMM(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDURSBW64_IMM(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STURBFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDURBFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemImm("stur", machInst, false,
                                               rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemImm("ldur", machInst, true,
                                               rt, rnsp, imm);
                      case 0x08:
                        return new STURH64_IMM(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDURH64_IMM(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDURSHX64_IMM(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDURSHW64_IMM(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STURHFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDURHFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STURW64_IMM(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDURW64_IMM(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDURSW64_IMM(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STURSFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDURSFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STURX64_IMM(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDURX64_IMM(machInst, rt, rnsp, imm);
                      case 0x1a:
                        return new PRFUM64_IMM(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STURDFP64_IMM(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDURDFP64_IMM(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  // bit 29:27=111, 25:24=00, 21=0, 11:10=01
                  case 0x1:
                  {
                    IntRegIndex rt =
                        (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                    IntRegIndex rn =
                        (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                    IntRegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STRB64_POST(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDRB64_POST(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDRSBX64_POST(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDRSBW64_POST(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STRBFP64_POST(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDRBFP64_POST(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemPost("str", machInst, false,
                                                rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemPost("ldr", machInst, true,
                                                rt, rnsp, imm);
                      case 0x08:
                        return new STRH64_POST(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDRH64_POST(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDRSHX64_POST(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDRSHW64_POST(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STRHFP64_POST(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDRHFP64_POST(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STRW64_POST(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDRW64_POST(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDRSW64_POST(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STRSFP64_POST(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDRSFP64_POST(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STRX64_POST(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDRX64_POST(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STRDFP64_POST(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDRDFP64_POST(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  case 0x2:
                  {
                    IntRegIndex rt =
                        (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                    IntRegIndex rn =
                        (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                    IntRegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STTRB64_IMM(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDTRB64_IMM(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDTRSBX64_IMM(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDTRSBW64_IMM(machInst, rt, rnsp, imm);
                      case 0x08:
                        return new STTRH64_IMM(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDTRH64_IMM(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDTRSHX64_IMM(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDTRSHW64_IMM(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STTRW64_IMM(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDTRW64_IMM(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDTRSW64_IMM(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STTRX64_IMM(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDTRX64_IMM(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                  case 0x3:
                  {
                    IntRegIndex rt =
                        (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
                    IntRegIndex rn =
                        (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
                    IntRegIndex rnsp = makeSP(rn);
                    uint64_t imm = sext<9>(bits(machInst, 20, 12));
                    switch (switchVal) {
                      case 0x00:
                        return new STRB64_PRE(machInst, rt, rnsp, imm);
                      case 0x01:
                        return new LDRB64_PRE(machInst, rt, rnsp, imm);
                      case 0x02:
                        return new LDRSBX64_PRE(machInst, rt, rnsp, imm);
                      case 0x03:
                        return new LDRSBW64_PRE(machInst, rt, rnsp, imm);
                      case 0x04:
                        return new STRBFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x05:
                        return new LDRBFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x06:
                        return new BigFpMemPre("str", machInst, false,
                                               rt, rnsp, imm);
                      case 0x07:
                        return new BigFpMemPre("ldr", machInst, true,
                                               rt, rnsp, imm);
                      case 0x08:
                        return new STRH64_PRE(machInst, rt, rnsp, imm);
                      case 0x09:
                        return new LDRH64_PRE(machInst, rt, rnsp, imm);
                      case 0x0a:
                        return new LDRSHX64_PRE(machInst, rt, rnsp, imm);
                      case 0x0b:
                        return new LDRSHW64_PRE(machInst, rt, rnsp, imm);
                      case 0x0c:
                        return new STRHFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x0d:
                        return new LDRHFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x10:
                        return new STRW64_PRE(machInst, rt, rnsp, imm);
                      case 0x11:
                        return new LDRW64_PRE(machInst, rt, rnsp, imm);
                      case 0x12:
                        return new LDRSW64_PRE(machInst, rt, rnsp, imm);
                      case 0x14:
                        return new STRSFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x15:
                        return new LDRSFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x18:
                        return new STRX64_PRE(machInst, rt, rnsp, imm);
                      case 0x19:
                        return new LDRX64_PRE(machInst, rt, rnsp, imm);
                      case 0x1c:
                        return new STRDFP64_PRE(machInst, rt, rnsp, imm);
                      case 0x1d:
                        return new LDRDFP64_PRE(machInst, rt, rnsp, imm);
                      default:
                        return new Unknown64(machInst);
                    }
                  }
                }
            }
          }
        }
        return new FailUnimplemented("Unhandled Case1", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeDataProcReg(ExtMachInst machInst)
    {
        uint8_t switchVal = (bits(machInst, 28) << 1) |
                            (bits(machInst, 24) << 0);
        switch (switchVal) {
          case 0x0:
          {
            uint8_t switchVal = (bits(machInst, 21) << 0) |
                                (bits(machInst, 30, 29) << 1);
            ArmShiftType type = (ArmShiftType)(uint8_t)bits(machInst, 23, 22);
            uint8_t imm6 = bits(machInst, 15, 10);
            bool sf = bits(machInst, 31);
            if (!sf && (imm6 & 0x20))
                return new Unknown64(machInst);
            IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
            IntRegIndex rdzr = makeZero(rd);
            IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
            IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);

            switch (switchVal) {
              case 0x0:
                return new AndXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x1:
                return new BicXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x2:
                return new OrrXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x3:
                return new OrnXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x4:
                return new EorXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x5:
                return new EonXSReg(machInst, rdzr, rn, rm, imm6, type);
              case 0x6:
                return new AndXSRegCc(machInst, rdzr, rn, rm, imm6, type);
              case 0x7:
                return new BicXSRegCc(machInst, rdzr, rn, rm, imm6, type);
            }
          }
          case 0x1:
          {
            uint8_t switchVal = bits(machInst, 30, 29);
            if (bits(machInst, 21) == 0) {
                ArmShiftType type =
                    (ArmShiftType)(uint8_t)bits(machInst, 23, 22);
                if (type == ROR)
                    return new Unknown64(machInst);
                uint8_t imm6 = bits(machInst, 15, 10);
                if (!bits(machInst, 31) && bits(imm6, 5))
                    return new Unknown64(machInst);
                IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
                IntRegIndex rdzr = makeZero(rd);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
                switch (switchVal) {
                  case 0x0:
                    return new AddXSReg(machInst, rdzr, rn, rm, imm6, type);
                  case 0x1:
                    return new AddXSRegCc(machInst, rdzr, rn, rm, imm6, type);
                  case 0x2:
                    return new SubXSReg(machInst, rdzr, rn, rm, imm6, type);
                  case 0x3:
                    return new SubXSRegCc(machInst, rdzr, rn, rm, imm6, type);
                }
            } else {
                if (bits(machInst, 23, 22) != 0 || bits(machInst, 12, 10) > 0x4)
                   return new Unknown64(machInst);
                ArmExtendType type =
                    (ArmExtendType)(uint8_t)bits(machInst, 15, 13);
                uint8_t imm3 = bits(machInst, 12, 10);
                IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
                IntRegIndex rdsp = makeSP(rd);
                IntRegIndex rdzr = makeZero(rd);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                IntRegIndex rnsp = makeSP(rn);
                IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);

                switch (switchVal) {
                  case 0x0:
                    return new AddXEReg(machInst, rdsp, rnsp, rm, type, imm3);
                  case 0x1:
                    return new AddXERegCc(machInst, rdzr, rnsp, rm, type, imm3);
                  case 0x2:
                    return new SubXEReg(machInst, rdsp, rnsp, rm, type, imm3);
                  case 0x3:
                    return new SubXERegCc(machInst, rdzr, rnsp, rm, type, imm3);
                }
            }
          }
          case 0x2:
          {
            if (bits(machInst, 21) == 1)
                return new Unknown64(machInst);
            IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
            IntRegIndex rdzr = makeZero(rd);
            IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
            IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
            switch (bits(machInst, 23, 22)) {
              case 0x0:
              {
                if (bits(machInst, 15, 10))
                    return new Unknown64(machInst);
                uint8_t switchVal = bits(machInst, 30, 29);
                switch (switchVal) {
                  case 0x0:
                    return new AdcXSReg(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x1:
                    return new AdcXSRegCc(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x2:
                    return new SbcXSReg(machInst, rdzr, rn, rm, 0, LSL);
                  case 0x3:
                    return new SbcXSRegCc(machInst, rdzr, rn, rm, 0, LSL);
                }
              }
              case 0x1:
              {
                if ((bits(machInst, 4) == 1) ||
                        (bits(machInst, 10) == 1) ||
                        (bits(machInst, 29) == 0)) {
                    return new Unknown64(machInst);
                }
                ConditionCode cond =
                    (ConditionCode)(uint8_t)bits(machInst, 15, 12);
                uint8_t flags = bits(machInst, 3, 0);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                if (bits(machInst, 11) == 0) {
                    IntRegIndex rm =
                        (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
                    if (bits(machInst, 30) == 0) {
                        return new CcmnReg64(machInst, rn, rm, cond, flags);
                    } else {
                        return new CcmpReg64(machInst, rn, rm, cond, flags);
                    }
                } else {
                    uint8_t imm5 = bits(machInst, 20, 16);
                    if (bits(machInst, 30) == 0) {
                        return new CcmnImm64(machInst, rn, imm5, cond, flags);
                    } else {
                        return new CcmpImm64(machInst, rn, imm5, cond, flags);
                    }
                }
              }
              case 0x2:
              {
                if (bits(machInst, 29) == 1 ||
                        bits(machInst, 11) == 1) {
                    return new Unknown64(machInst);
                }
                uint8_t switchVal = (bits(machInst, 10) << 0) |
                                    (bits(machInst, 30) << 1);
                IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
                IntRegIndex rdzr = makeZero(rd);
                IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
                IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)bits(machInst, 15, 12);
                switch (switchVal) {
                  case 0x0:
                    return new Csel64(machInst, rdzr, rn, rm, cond);
                  case 0x1:
                    return new Csinc64(machInst, rdzr, rn, rm, cond);
                  case 0x2:
                    return new Csinv64(machInst, rdzr, rn, rm, cond);
                  case 0x3:
                    return new Csneg64(machInst, rdzr, rn, rm, cond);
                }
              }
              case 0x3:
                if (bits(machInst, 30) == 0) {
                    if (bits(machInst, 29) != 0)
                        return new Unknown64(machInst);
                    uint8_t switchVal = bits(machInst, 15, 10);
                    switch (switchVal) {
                      case 0x2:
                        return new Udiv64(machInst, rdzr, rn, rm);
                      case 0x3:
                        return new Sdiv64(machInst, rdzr, rn, rm);
                      case 0x8:
                        return new Lslv64(machInst, rdzr, rn, rm);
                      case 0x9:
                        return new Lsrv64(machInst, rdzr, rn, rm);
                      case 0xa:
                        return new Asrv64(machInst, rdzr, rn, rm);
                      case 0xb:
                        return new Rorv64(machInst, rdzr, rn, rm);
                      default:
                        return new Unknown64(machInst);
                    }
                } else {
                    if (bits(machInst, 20, 16) != 0 ||
                            bits(machInst, 29) != 0) {
                        return new Unknown64(machInst);
                    }
                    uint8_t switchVal = bits(machInst, 15, 10);
                    switch (switchVal) {
                      case 0x0:
                        return new Rbit64(machInst, rdzr, rn);
                      case 0x1:
                        return new Rev1664(machInst, rdzr, rn);
                      case 0x2:
                        if (bits(machInst, 31) == 0)
                            return new Rev64(machInst, rdzr, rn);
                        else
                            return new Rev3264(machInst, rdzr, rn);
                      case 0x3:
                        if (bits(machInst, 31) != 1)
                            return new Unknown64(machInst);
                        return new Rev64(machInst, rdzr, rn);
                      case 0x4:
                        return new Clz64(machInst, rdzr, rn);
                      case 0x5:
                        return new Cls64(machInst, rdzr, rn);
                    }
                }
            }
          }
          case 0x3:
          {
            if (bits(machInst, 30, 29) != 0x0 ||
                    (bits(machInst, 23, 21) != 0 && bits(machInst, 31) == 0))
                return new Unknown64(machInst);
            IntRegIndex rd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
            IntRegIndex rdzr = makeZero(rd);
            IntRegIndex rn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);
            IntRegIndex ra = (IntRegIndex)(uint8_t)bits(machInst, 14, 10);
            IntRegIndex rm = (IntRegIndex)(uint8_t)bits(machInst, 20, 16);
            switch (bits(machInst, 23, 21)) {
              case 0x0:
                if (bits(machInst, 15) == 0)
                    return new Madd64(machInst, rdzr, ra, rn, rm);
                else
                    return new Msub64(machInst, rdzr, ra, rn, rm);
              case 0x1:
                if (bits(machInst, 15) == 0)
                    return new Smaddl64(machInst, rdzr, ra, rn, rm);
                else
                    return new Smsubl64(machInst, rdzr, ra, rn, rm);
              case 0x2:
                if (bits(machInst, 15) != 0)
                    return new Unknown64(machInst);
                return new Smulh64(machInst, rdzr, rn, rm);
              case 0x5:
                if (bits(machInst, 15) == 0)
                    return new Umaddl64(machInst, rdzr, ra, rn, rm);
                else
                    return new Umsubl64(machInst, rdzr, ra, rn, rm);
              case 0x6:
                if (bits(machInst, 15) != 0)
                    return new Unknown64(machInst);
                return new Umulh64(machInst, rdzr, rn, rm);
              default:
                return new Unknown64(machInst);
            }
          }
        }
        return new FailUnimplemented("Unhandled Case2", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeAdvSIMD(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 10) == 0) {
                return decodeNeonIndexedElem(machInst);
            } else if (bits(machInst, 23) == 1) {
                return new Unknown64(machInst);
            } else {
                if (bits(machInst, 22, 19)) {
                    return decodeNeonShiftByImm(machInst);
                } else {
                    return decodeNeonModImm(machInst);
                }
            }
        } else if (bits(machInst, 21) == 1) {
            if (bits(machInst, 10) == 1) {
                return decodeNeon3Same(machInst);
            } else if (bits(machInst, 11) == 0) {
                return decodeNeon3Diff(machInst);
            } else if (bits(machInst, 20, 17) == 0x0) {
                return decodeNeon2RegMisc(machInst);
            } else if (bits(machInst, 20, 17) == 0x8) {
                return decodeNeonAcrossLanes(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 24) ||
                   bits(machInst, 21) ||
                   bits(machInst, 15)) {
            return new Unknown64(machInst);
        } else if (bits(machInst, 10) == 1) {
            if (bits(machInst, 23, 22))
                return new Unknown64(machInst);
            return decodeNeonCopy(machInst);
        } else if (bits(machInst, 29) == 1) {
            return decodeNeonExt(machInst);
        } else if (bits(machInst, 11) == 1) {
            return decodeNeonZipUzpTrn(machInst);
        } else if (bits(machInst, 23, 22) == 0x0) {
            return decodeNeonTblTbx(machInst);
        } else {
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case3", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    // bit 30=0, 28:25=1111
    decodeFp(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 31) || bits(machInst, 29))
                return new Unknown64(machInst);
            IntRegIndex rd    = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
            IntRegIndex rn    = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
            IntRegIndex rm    = (IntRegIndex)(uint32_t)bits(machInst, 20, 16);
            IntRegIndex ra    = (IntRegIndex)(uint32_t)bits(machInst, 14, 10);
            uint8_t switchVal = (bits(machInst, 23, 21) << 1) |
                                (bits(machInst, 15)     << 0);
            switch (switchVal) {
              case 0x0: // FMADD Sd = Sa + Sn*Sm
                return new FMAddS(machInst, rd, rn, rm, ra);
              case 0x1: // FMSUB Sd = Sa + (-Sn)*Sm
                return new FMSubS(machInst, rd, rn, rm, ra);
              case 0x2: // FNMADD Sd = (-Sa) + (-Sn)*Sm
                return new FNMAddS(machInst, rd, rn, rm, ra);
              case 0x3: // FNMSUB Sd = (-Sa) + Sn*Sm
                return new FNMSubS(machInst, rd, rn, rm, ra);
              case 0x4: // FMADD Dd = Da + Dn*Dm
                return new FMAddD(machInst, rd, rn, rm, ra);
              case 0x5: // FMSUB Dd = Da + (-Dn)*Dm
                return new FMSubD(machInst, rd, rn, rm, ra);
              case 0x6: // FNMADD Dd = (-Da) + (-Dn)*Dm
                return new FNMAddD(machInst, rd, rn, rm, ra);
              case 0x7: // FNMSUB Dd = (-Da) + Dn*Dm
                return new FNMSubD(machInst, rd, rn, rm, ra);
              default:
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 21) == 0) {
            bool s = bits(machInst, 29);
            if (s)
                return new Unknown64(machInst);
            uint8_t switchVal = bits(machInst, 20, 16);
            uint8_t type      = bits(machInst, 23, 22);
            uint8_t scale     = bits(machInst, 15, 10);
            IntRegIndex rd    = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
            IntRegIndex rn    = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
            if (bits(machInst, 18, 17) == 3 && scale != 0)
                return new Unknown64(machInst);
            // 30:24=0011110, 21=0
            switch (switchVal) {
              case 0x00:
                return new FailUnimplemented("fcvtns", machInst);
              case 0x01:
                return new FailUnimplemented("fcvtnu", machInst);
              case 0x02:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // SCVTF Sd = convertFromInt(Wn/(2^fbits))
                    return new FcvtSFixedFpSW(machInst, rd, rn, scale);
                  case 1: // SCVTF Dd = convertFromInt(Wn/(2^fbits))
                    return new FcvtSFixedFpDW(machInst, rd, rn, scale);
                  case 4: // SCVTF Sd = convertFromInt(Xn/(2^fbits))
                    return new FcvtSFixedFpSX(machInst, rd, rn, scale);
                  case 5: // SCVTF Dd = convertFromInt(Xn/(2^fbits))
                    return new FcvtSFixedFpDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x03:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // UCVTF Sd = convertFromInt(Wn/(2^fbits))
                    return new FcvtUFixedFpSW(machInst, rd, rn, scale);
                  case 1: // UCVTF Dd = convertFromInt(Wn/(2^fbits))
                    return new FcvtUFixedFpDW(machInst, rd, rn, scale);
                  case 4: // UCVTF Sd = convertFromInt(Xn/(2^fbits))
                    return new FcvtUFixedFpSX(machInst, rd, rn, scale);
                  case 5: // UCVTF Dd = convertFromInt(Xn/(2^fbits))
                    return new FcvtUFixedFpDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x04:
                return new FailUnimplemented("fcvtas", machInst);
              case 0x05:
                return new FailUnimplemented("fcvtau", machInst);
              case 0x08:
                return new FailUnimplemented("fcvtps", machInst);
              case 0x09:
                return new FailUnimplemented("fcvtpu", machInst);
              case 0x0e:
                return new FailUnimplemented("fmov elem. to 64", machInst);
              case 0x0f:
                return new FailUnimplemented("fmov 64 bit", machInst);
              case 0x10:
                return new FailUnimplemented("fcvtms", machInst);
              case 0x11:
                return new FailUnimplemented("fcvtmu", machInst);
              case 0x18:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // FCVTZS Wd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpSFixedSW(machInst, rd, rn, scale);
                  case 1: // FCVTZS Wd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpSFixedDW(machInst, rd, rn, scale);
                  case 4: // FCVTZS Xd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpSFixedSX(machInst, rd, rn, scale);
                  case 5: // FCVTZS Xd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpSFixedDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
              case 0x19:
                switch ( (bits(machInst, 31) << 2) | type ) {
                  case 0: // FCVTZU Wd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpUFixedSW(machInst, rd, rn, scale);
                  case 1: // FCVTZU Wd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpUFixedDW(machInst, rd, rn, scale);
                  case 4: // FCVTZU Xd = convertToIntExactTowardZero(Sn*(2^fbits))
                    return new FcvtFpUFixedSX(machInst, rd, rn, scale);
                  case 5: // FCVTZU Xd = convertToIntExactTowardZero(Dn*(2^fbits))
                    return new FcvtFpUFixedDX(machInst, rd, rn, scale);
                  default:
                    return new Unknown64(machInst);
                }
            }
        } else {
            // 30=0, 28:24=11110, 21=1
            uint8_t type   = bits(machInst, 23, 22);
            uint8_t imm8   = bits(machInst, 20, 13);
            IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 4, 0);
            IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 9, 5);
            switch (bits(machInst, 11, 10)) {
              case 0x0:
                if (bits(machInst, 12) == 1) {
                    if (bits(machInst, 31) ||
                            bits(machInst, 29) ||
                            bits(machInst, 9, 5)) {
                        return new Unknown64(machInst);
                    }
                    // 31:29=000, 28:24=11110, 21=1, 12:10=100
                    if (type == 0) {
                        // FMOV S[d] = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,5)
                        //             :bits(imm8, 5, 0):Zeros(19)
                        uint32_t imm = vfp_modified_imm(imm8, false);
                        return new FmovImmS(machInst, rd, imm);
                    } else if (type == 1) {
                        // FMOV D[d] = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,8)
                        //             :bits(imm8, 5, 0):Zeros(48)
                        uint64_t imm = vfp_modified_imm(imm8, true);
                        return new FmovImmD(machInst, rd, imm);
                    } else {
                        return new Unknown64(machInst);
                    }
                } else if (bits(machInst, 13) == 1) {
                    if (bits(machInst, 31) ||
                            bits(machInst, 29) ||
                            bits(machInst, 15, 14) ||
                            bits(machInst, 23) ||
                            bits(machInst, 2, 0)) {
                        return new Unknown64(machInst);
                    }
                    uint8_t switchVal = (bits(machInst, 4, 3) << 0) |
                                        (bits(machInst, 22) << 2);
                    IntRegIndex rm = (IntRegIndex)(uint32_t)
                                        bits(machInst, 20, 16);
                    // 28:23=000111100, 21=1, 15:10=001000, 2:0=000
                    switch (switchVal) {
                      case 0x0:
                        // FCMP flags = compareQuiet(Sn,Sm)
                        return new FCmpRegS(machInst, rn, rm);
                      case 0x1:
                        // FCMP flags = compareQuiet(Sn,0.0)
                        return new FCmpImmS(machInst, rn, 0);
                      case 0x2:
                        // FCMPE flags = compareSignaling(Sn,Sm)
                        return new FCmpERegS(machInst, rn, rm);
                      case 0x3:
                        // FCMPE flags = compareSignaling(Sn,0.0)
                        return new FCmpEImmS(machInst, rn, 0);
                      case 0x4:
                        // FCMP flags = compareQuiet(Dn,Dm)
                        return new FCmpRegD(machInst, rn, rm);
                      case 0x5:
                        // FCMP flags = compareQuiet(Dn,0.0)
                        return new FCmpImmD(machInst, rn, 0);
                      case 0x6:
                        // FCMPE flags = compareSignaling(Dn,Dm)
                        return new FCmpERegD(machInst, rn, rm);
                      case 0x7:
                        // FCMPE flags = compareSignaling(Dn,0.0)
                        return new FCmpEImmD(machInst, rn, 0);
                      default:
                        return new Unknown64(machInst);
                    }
                } else if (bits(machInst, 14) == 1) {
                    if (bits(machInst, 31) || bits(machInst, 29))
                        return new Unknown64(machInst);
                    uint8_t opcode = bits(machInst, 20, 15);
                    // Bits 31:24=00011110, 21=1, 14:10=10000
                    switch (opcode) {
                      case 0x0:
                        if (type == 0)
                            // FMOV Sd = Sn
                            return new FmovRegS(machInst, rd, rn);
                        else if (type == 1)
                            // FMOV Dd = Dn
                            return new FmovRegD(machInst, rd, rn);
                        break;
                      case 0x1:
                        if (type == 0)
                            // FABS Sd = abs(Sn)
                            return new FAbsS(machInst, rd, rn);
                        else if (type == 1)
                            // FABS Dd = abs(Dn)
                            return new FAbsD(machInst, rd, rn);
                        break;
                      case 0x2:
                        if (type == 0)
                            // FNEG Sd = -Sn
                            return new FNegS(machInst, rd, rn);
                        else if (type == 1)
                            // FNEG Dd = -Dn
                            return new FNegD(machInst, rd, rn);
                        break;
                      case 0x3:
                        if (type == 0)
                            // FSQRT Sd = sqrt(Sn)
                            return new FSqrtS(machInst, rd, rn);
                        else if (type == 1)
                            // FSQRT Dd = sqrt(Dn)
                            return new FSqrtD(machInst, rd, rn);
                        break;
                      case 0x4:
                        if (type == 1)
                            // FCVT Sd = convertFormat(Dn)
                            return new FcvtFpDFpS(machInst, rd, rn);
                        else if (type == 3)
                            // FCVT Sd = convertFormat(Hn)
                            return new FcvtFpHFpS(machInst, rd, rn);
                        break;
                      case 0x5:
                        if (type == 0)
                            // FCVT Dd = convertFormat(Sn)
                            return new FCvtFpSFpD(machInst, rd, rn);
                        else if (type == 3)
                            // FCVT Dd = convertFormat(Hn)
                            return new FcvtFpHFpD(machInst, rd, rn);
                        break;
                      case 0x7:
                        if (type == 0)
                            // FCVT Hd = convertFormat(Sn)
                            return new FcvtFpSFpH(machInst, rd, rn);
                        else if (type == 1)
                            // FCVT Hd = convertFormat(Dn)
                            return new FcvtFpDFpH(machInst, rd, rn);
                        break;
                      case 0x8:
                        if (type == 0) // FRINTN Sd = roundToIntegralTiesToEven(Sn)
                            return new FRIntNS(machInst, rd, rn);
                        else if (type == 1) // FRINTN Dd = roundToIntegralTiesToEven(Dn)
                            return new FRIntND(machInst, rd, rn);
                        break;
                      case 0x9:
                        if (type == 0) // FRINTP Sd = roundToIntegralTowardPlusInf(Sn)
                            return new FRIntPS(machInst, rd, rn);
                        else if (type == 1) // FRINTP Dd = roundToIntegralTowardPlusInf(Dn)
                            return new FRIntPD(machInst, rd, rn);
                        break;
                      case 0xa:
                        if (type == 0) // FRINTM Sd = roundToIntegralTowardMinusInf(Sn)
                            return new FRIntMS(machInst, rd, rn);
                        else if (type == 1) // FRINTM Dd = roundToIntegralTowardMinusInf(Dn)
                            return new FRIntMD(machInst, rd, rn);
                        break;
                      case 0xb:
                        if (type == 0) // FRINTZ Sd = roundToIntegralTowardZero(Sn)
                            return new FRIntZS(machInst, rd, rn);
                        else if (type == 1) // FRINTZ Dd = roundToIntegralTowardZero(Dn)
                            return new FRIntZD(machInst, rd, rn);
                        break;
                      case 0xc:
                        if (type == 0) // FRINTA Sd = roundToIntegralTiesToAway(Sn)
                            return new FRIntAS(machInst, rd, rn);
                        else if (type == 1) // FRINTA Dd = roundToIntegralTiesToAway(Dn)
                            return new FRIntAD(machInst, rd, rn);
                        break;
                      case 0xe:
                        if (type == 0) // FRINTX Sd = roundToIntegralExact(Sn)
                            return new FRIntXS(machInst, rd, rn);
                        else if (type == 1) // FRINTX Dd = roundToIntegralExact(Dn)
                            return new FRIntXD(machInst, rd, rn);
                        break;
                      case 0xf:
                        if (type == 0) // FRINTI Sd = roundToIntegral(Sn)
                            return new FRIntIS(machInst, rd, rn);
                        else if (type == 1) // FRINTI Dd = roundToIntegral(Dn)
                            return new FRIntID(machInst, rd, rn);
                        break;
                      default:
                        return new Unknown64(machInst);
                    }
                    return new Unknown64(machInst);
                } else if (bits(machInst, 15) == 1) {
                    return new Unknown64(machInst);
                } else {
                    if (bits(machInst, 29))
                        return new Unknown64(machInst);
                    uint8_t rmode      = bits(machInst, 20, 19);
                    uint8_t switchVal1 = bits(machInst, 18, 16);
                    uint8_t switchVal2 = (type << 1) | bits(machInst, 31);
                    // 30:24=0011110, 21=1, 15:10=000000
                    switch (switchVal1) {
                      case 0x0:
                        switch ((switchVal2 << 2) | rmode) {
                          case 0x0: //FCVTNS Wd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpSIntWSN(machInst, rd, rn);
                          case 0x1: //FCVTPS Wd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpSIntWSP(machInst, rd, rn);
                          case 0x2: //FCVTMS Wd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpSIntWSM(machInst, rd, rn);
                          case 0x3: //FCVTZS Wd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpSIntWSZ(machInst, rd, rn);
                          case 0x4: //FCVTNS Xd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpSIntXSN(machInst, rd, rn);
                          case 0x5: //FCVTPS Xd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpSIntXSP(machInst, rd, rn);
                          case 0x6: //FCVTMS Xd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpSIntXSM(machInst, rd, rn);
                          case 0x7: //FCVTZS Xd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpSIntXSZ(machInst, rd, rn);
                          case 0x8: //FCVTNS Wd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpSIntWDN(machInst, rd, rn);
                          case 0x9: //FCVTPS Wd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpSIntWDP(machInst, rd, rn);
                          case 0xA: //FCVTMS Wd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpSIntWDM(machInst, rd, rn);
                          case 0xB: //FCVTZS Wd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpSIntWDZ(machInst, rd, rn);
                          case 0xC: //FCVTNS Xd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpSIntXDN(machInst, rd, rn);
                          case 0xD: //FCVTPS Xd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpSIntXDP(machInst, rd, rn);
                          case 0xE: //FCVTMS Xd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpSIntXDM(machInst, rd, rn);
                          case 0xF: //FCVTZS Xd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpSIntXDZ(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x1:
                        switch ((switchVal2 << 2) | rmode) {
                          case 0x0: //FCVTNU Wd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpUIntWSN(machInst, rd, rn);
                          case 0x1: //FCVTPU Wd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpUIntWSP(machInst, rd, rn);
                          case 0x2: //FCVTMU Wd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpUIntWSM(machInst, rd, rn);
                          case 0x3: //FCVTZU Wd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpUIntWSZ(machInst, rd, rn);
                          case 0x4: //FCVTNU Xd = convertToIntExactTiesToEven(Sn)
                            return new FcvtFpUIntXSN(machInst, rd, rn);
                          case 0x5: //FCVTPU Xd = convertToIntExactTowardPlusInf(Sn)
                            return new FcvtFpUIntXSP(machInst, rd, rn);
                          case 0x6: //FCVTMU Xd = convertToIntExactTowardMinusInf(Sn)
                            return new FcvtFpUIntXSM(machInst, rd, rn);
                          case 0x7: //FCVTZU Xd = convertToIntExactTowardZero(Sn)
                            return new FcvtFpUIntXSZ(machInst, rd, rn);
                          case 0x8: //FCVTNU Wd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpUIntWDN(machInst, rd, rn);
                          case 0x9: //FCVTPU Wd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpUIntWDP(machInst, rd, rn);
                          case 0xA: //FCVTMU Wd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpUIntWDM(machInst, rd, rn);
                          case 0xB: //FCVTZU Wd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpUIntWDZ(machInst, rd, rn);
                          case 0xC: //FCVTNU Xd = convertToIntExactTiesToEven(Dn)
                            return new FcvtFpUIntXDN(machInst, rd, rn);
                          case 0xD: //FCVTPU Xd = convertToIntExactTowardPlusInf(Dn)
                            return new FcvtFpUIntXDP(machInst, rd, rn);
                          case 0xE: //FCVTMU Xd = convertToIntExactTowardMinusInf(Dn)
                            return new FcvtFpUIntXDM(machInst, rd, rn);
                          case 0xF: //FCVTZU Xd = convertToIntExactTowardZero(Dn)
                            return new FcvtFpUIntXDZ(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x2:
                        if (rmode != 0)
                            return new Unknown64(machInst);
                        switch (switchVal2) {
                          case 0: // SCVTF Sd = convertFromInt(Wn)
                            return new FcvtWSIntFpS(machInst, rd, rn);
                          case 1: // SCVTF Sd = convertFromInt(Xn)
                            return new FcvtXSIntFpS(machInst, rd, rn);
                          case 2: // SCVTF Dd = convertFromInt(Wn)
                            return new FcvtWSIntFpD(machInst, rd, rn);
                          case 3: // SCVTF Dd = convertFromInt(Xn)
                            return new FcvtXSIntFpD(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x3:
                        switch (switchVal2) {
                          case 0: // UCVTF Sd = convertFromInt(Wn)
                            return new FcvtWUIntFpS(machInst, rd, rn);
                          case 1: // UCVTF Sd = convertFromInt(Xn)
                            return new FcvtXUIntFpS(machInst, rd, rn);
                          case 2: // UCVTF Dd = convertFromInt(Wn)
                            return new FcvtWUIntFpD(machInst, rd, rn);
                          case 3: // UCVTF Dd = convertFromInt(Xn)
                            return new FcvtXUIntFpD(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x4:
                        if (rmode != 0)
                            return new Unknown64(machInst);
                        switch (switchVal2) {
                          case 0: // FCVTAS Wd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpSIntWSA(machInst, rd, rn);
                          case 1: // FCVTAS Xd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpSIntXSA(machInst, rd, rn);
                          case 2: // FCVTAS Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpSIntWDA(machInst, rd, rn);
                          case 3: // FCVTAS Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpSIntXDA(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x5:
                        switch (switchVal2) {
                          case 0: // FCVTAU Wd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpUIntWSA(machInst, rd, rn);
                          case 1: // FCVTAU Xd = convertToIntExactTiesToAway(Sn)
                            return new FcvtFpUIntXSA(machInst, rd, rn);
                          case 2: // FCVTAU Wd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpUIntWDA(machInst, rd, rn);
                          case 3: // FCVTAU Xd = convertToIntExactTiesToAway(Dn)
                            return new FcvtFpUIntXDA(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                      case 0x06:
                        switch (switchVal2) {
                          case 0: // FMOV Wd = Sn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovRegCoreW(machInst, rd, rn);
                          case 3: // FMOV Xd = Dn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovRegCoreX(machInst, rd, rn);
                          case 5: // FMOV Xd = bits(Vn, 127, 64)
                            if (rmode != 1)
                                return new Unknown64(machInst);
                            return new FmovURegCoreX(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                        break;
                      case 0x07:
                        switch (switchVal2) {
                          case 0: // FMOV Sd = Wn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovCoreRegW(machInst, rd, rn);
                          case 3: // FMOV Xd = Dn
                            if (rmode != 0)
                                return new Unknown64(machInst);
                            return new FmovCoreRegX(machInst, rd, rn);
                          case 5: // FMOV Xd = bits(Vn, 127, 64)
                            if (rmode != 1)
                                return new Unknown64(machInst);
                            return new FmovUCoreRegX(machInst, rd, rn);
                          default:
                            return new Unknown64(machInst);
                        }
                        break;
                      default: // Warning! missing cases in switch statement above, that still need to be added
                        return new Unknown64(machInst);
                    }
                }
              case 0x1:
              {
                if (bits(machInst, 31) ||
                    bits(machInst, 29) ||
                    bits(machInst, 23)) {
                    return new Unknown64(machInst);
                }
                IntRegIndex rm = (IntRegIndex)(uint32_t) bits(machInst, 20, 16);
                IntRegIndex rn = (IntRegIndex)(uint32_t) bits(machInst, 9, 5);
                uint8_t    imm = (IntRegIndex)(uint32_t) bits(machInst, 3, 0);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)(bits(machInst, 15, 12));
                uint8_t switchVal = (bits(machInst, 4) << 0) |
                                    (bits(machInst, 22) << 1);
                // 31:23=000111100, 21=1, 11:10=01
                switch (switchVal) {
                  case 0x0:
                    // FCCMP flags = if cond the compareQuiet(Sn,Sm) else #nzcv
                    return new FCCmpRegS(machInst, rn, rm, cond, imm);
                  case 0x1:
                    // FCCMP flags = if cond then compareSignaling(Sn,Sm)
                    //               else #nzcv
                    return new FCCmpERegS(machInst, rn, rm, cond, imm);
                  case 0x2:
                    // FCCMP flags = if cond then compareQuiet(Dn,Dm) else #nzcv
                    return new FCCmpRegD(machInst, rn, rm, cond, imm);
                  case 0x3:
                    // FCCMP flags = if cond then compareSignaling(Dn,Dm)
                    //               else #nzcv
                    return new FCCmpERegD(machInst, rn, rm, cond, imm);
                  default:
                    return new Unknown64(machInst);
                }
              }
              case 0x2:
              {
                if (bits(machInst, 31) ||
                        bits(machInst, 29) ||
                        bits(machInst, 23)) {
                    return new Unknown64(machInst);
                }
                IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst,  4,  0);
                IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst,  9,  5);
                IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 20, 16);
                uint8_t switchVal = (bits(machInst, 15, 12) << 0) |
                                    (bits(machInst, 22) << 4);
                switch (switchVal) {
                  case 0x00: // FMUL Sd = Sn * Sm
                    return new FMulS(machInst, rd, rn, rm);
                  case 0x10: // FMUL Dd = Dn * Dm
                    return new FMulD(machInst, rd, rn, rm);
                  case 0x01: // FDIV Sd = Sn / Sm
                    return new FDivS(machInst, rd, rn, rm);
                  case 0x11: // FDIV Dd = Dn / Dm
                    return new FDivD(machInst, rd, rn, rm);
                  case 0x02: // FADD Sd = Sn + Sm
                    return new FAddS(machInst, rd, rn, rm);
                  case 0x12: // FADD Dd = Dn + Dm
                    return new FAddD(machInst, rd, rn, rm);
                  case 0x03: // FSUB Sd = Sn - Sm
                    return new FSubS(machInst, rd, rn, rm);
                  case 0x13: // FSUB Dd = Dn - Dm
                    return new FSubD(machInst, rd, rn, rm);
                  case 0x04: // FMAX Sd = max(Sn, Sm)
                    return new FMaxS(machInst, rd, rn, rm);
                  case 0x14: // FMAX Dd = max(Dn, Dm)
                    return new FMaxD(machInst, rd, rn, rm);
                  case 0x05: // FMIN Sd = min(Sn, Sm)
                    return new FMinS(machInst, rd, rn, rm);
                  case 0x15: // FMIN Dd = min(Dn, Dm)
                    return new FMinD(machInst, rd, rn, rm);
                  case 0x06: // FMAXNM Sd = maxNum(Sn, Sm)
                    return new FMaxNMS(machInst, rd, rn, rm);
                  case 0x16: // FMAXNM Dd = maxNum(Dn, Dm)
                    return new FMaxNMD(machInst, rd, rn, rm);
                  case 0x07: // FMINNM Sd = minNum(Sn, Sm)
                    return new FMinNMS(machInst, rd, rn, rm);
                  case 0x17: // FMINNM Dd = minNum(Dn, Dm)
                    return new FMinNMD(machInst, rd, rn, rm);
                  case 0x08: // FNMUL Sd = -(Sn * Sm)
                    return new FNMulS(machInst, rd, rn, rm);
                  case 0x18: // FNMUL Dd = -(Dn * Dm)
                    return new FNMulD(machInst, rd, rn, rm);
                  default:
                    return new Unknown64(machInst);
                }
              }
              case 0x3:
              {
                if (bits(machInst, 31) || bits(machInst, 29))
                    return new Unknown64(machInst);
                uint8_t type = bits(machInst, 23, 22);
                IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst,  4,  0);
                IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst,  9,  5);
                IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 20, 16);
                ConditionCode cond =
                    (ConditionCode)(uint8_t)(bits(machInst, 15, 12));
                if (type == 0) // FCSEL Sd = if cond then Sn else Sm
                    return new FCSelS(machInst, rd, rn, rm, cond);
                else if (type == 1) // FCSEL Dd = if cond then Dn else Dm
                    return new FCSelD(machInst, rd, rn, rm, cond);
                else
                    return new Unknown64(machInst);
              }
            }
        }
        return new FailUnimplemented("Unhandled Case4", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeAdvSIMDScalar(ExtMachInst machInst)
    {
        if (bits(machInst, 24) == 1) {
            if (bits(machInst, 10) == 0) {
                return decodeNeonScIndexedElem(machInst);
            } else if (bits(machInst, 23) == 0) {
                return decodeNeonScShiftByImm(machInst);
            }
        } else if (bits(machInst, 21) == 1) {
            if (bits(machInst, 10) == 1) {
                return decodeNeonSc3Same(machInst);
            } else if (bits(machInst, 11) == 0) {
                return decodeNeonSc3Diff(machInst);
            } else if (bits(machInst, 20, 17) == 0x0) {
                return decodeNeonSc2RegMisc(machInst);
            } else if (bits(machInst, 20, 17) == 0x8) {
                return decodeNeonScPwise(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 23, 22) == 0 &&
                   bits(machInst, 15) == 0 &&
                   bits(machInst, 10) == 1) {
            return decodeNeonScCopy(machInst);
        } else {
            return new Unknown64(machInst);
        }
        return new FailUnimplemented("Unhandled Case6", machInst);
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeFpAdvSIMD(ExtMachInst machInst)
    {

        if (bits(machInst, 28) == 0) {
            if (bits(machInst, 31) == 0) {
                return decodeAdvSIMD(machInst);
            } else {
                return new Unknown64(machInst);
            }
        } else if (bits(machInst, 30) == 0) {
            return decodeFp(machInst);
        } else if (bits(machInst, 31) == 0) {
            return decodeAdvSIMDScalar(machInst);
        } else {
            return new Unknown64(machInst);
        }
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeGem5Ops(ExtMachInst machInst)
    {
        const uint32_t m5func = bits(machInst, 23, 16);
        switch (m5func) {
          case 0x00: return new Arm(machInst);
          case 0x01: return new Quiesce(machInst);
          case 0x02: return new QuiesceNs64(machInst);
          case 0x03: return new QuiesceCycles64(machInst);
          case 0x04: return new QuiesceTime64(machInst);
          case 0x07: return new Rpns64(machInst);
          case 0x09: return new WakeCPU64(machInst);
          case 0x10: return new Deprecated_ivlb(machInst);
          case 0x11: return new Deprecated_ivle(machInst);
          case 0x20: return new Deprecated_exit (machInst);
          case 0x21: return new M5exit64(machInst);
          case 0x31: return new Loadsymbol(machInst);
          case 0x30: return new Initparam64(machInst);
          case 0x40: return new Resetstats64(machInst);
          case 0x41: return new Dumpstats64(machInst);
          case 0x42: return new Dumpresetstats64(machInst);
          case 0x43: return new M5checkpoint64(machInst);
          case 0x4F: return new M5writefile64(machInst);
          case 0x50: return new M5readfile64(machInst);
          case 0x51: return new M5break(machInst);
          case 0x52: return new M5switchcpu(machInst);
          case 0x53: return new M5addsymbol64(machInst);
          case 0x54: return new M5panic(machInst);
          case 0x5a: return new M5workbegin64(machInst);
          case 0x5b: return new M5workend64(machInst);
          default: return new Unknown64(machInst);
        }
    }
}

namespace Aarch64
{
    StaticInstPtr
    decodeNeon3Same(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;

        switch (opcode) {
          case 0x00:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UhaddDX, UhaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<ShaddDX, ShaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x01:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqaddDX, UqaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqaddDX, SqaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x02:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UrhaddDX, UrhaddQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SrhaddDX, SrhaddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x03:
            switch (size) {
              case 0x0:
                if (u) {
                    if (q)
                        return new EorQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new EorDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new AndQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new AndDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x1:
                if (u) {
                    if (q)
                        return new BslQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BslDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new BicQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BicDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x2:
                if (u) {
                    if (q)
                        return new BitQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BitDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new OrrQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new OrrDX<uint64_t>(machInst, vd, vn, vm);
                }
              case 0x3:
                if (u) {
                    if (q)
                        return new BifQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new BifDX<uint64_t>(machInst, vd, vn, vm);
                } else {
                    if (q)
                        return new OrnQX<uint64_t>(machInst, vd, vn, vm);
                    else
                        return new OrnDX<uint64_t>(machInst, vd, vn, vm);
                }
            }
          case 0x04:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UhsubDX, UhsubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<ShsubDX, ShsubQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x05:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqsubDX, UqsubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqsubDX, SqsubQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x06:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmhiDX, CmhiQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<CmgtDX, CmgtQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x07:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmhsDX, CmhsQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<CmgeDX, CmgeQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x08:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UshlDX, UshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SshlDX, SshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x09:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqshlDX, UqshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqshlDX, SqshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0a:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UrshlDX, UrshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SrshlDX, SrshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<UqrshlDX, UqrshlQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeXReg<SqrshlDX, SqrshlQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0c:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmaxDX, UmaxQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmaxDX, SmaxQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0d:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UminDX, UminQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SminDX, SminQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0e:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabdDX, UabdQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabdDX, SabdQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x0f:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabaDX, UabaQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabaDX, SabaQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x10:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<SubDX, SubQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeXReg<AddDX, AddQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x11:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeXReg<CmeqDX, CmeqQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeXReg<CmtstDX, CmtstQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x12:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<MlsDX, MlsQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<MlaDX, MlaQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x13:
            if (size == 0x3 || (size != 0x0 && bits(machInst, 29)))
                return new Unknown64(machInst);
            if (u) {
                if (q)
                    return new PmulQX<uint8_t>(machInst, vd, vn, vm);
                else
                    return new PmulDX<uint8_t>(machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeSReg<MulDX, MulQX>(
                    q, size, machInst, vd, vn, vm);
            }
          case 0x14:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmaxpDX, UmaxpQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmaxpDX, SmaxpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x15:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UminpDX, UminpQX>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SminpDX, SminpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x16:
            if (size == 0x3 || size == 0x0)
                return new Unknown64(machInst);
            if (u) {
                if (q)
                    return decodeNeonSThreeHAndWReg<SqrdmulhQX>(
                        size, machInst, vd, vn, vm);
                else
                    return decodeNeonSThreeHAndWReg<SqrdmulhDX>(
                        size, machInst, vd, vn, vm);
            } else {
                if (q)
                    return decodeNeonSThreeHAndWReg<SqdmulhQX>(
                        size, machInst, vd, vn, vm);
                else
                    return decodeNeonSThreeHAndWReg<SqdmulhDX>(
                        size, machInst, vd, vn, vm);
            }
          case 0x17:
            if (u || size_q == 0x6)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeXReg<AddpDX, AddpQX>(
                    q, size, machInst, vd, vn, vm);
          case 0x18:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmaxnmpDX, FmaxnmpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmaxnmDX, FmaxnmQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FminnmpDX, FminnmpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FminnmDX, FminnmQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x19:
            if (size < 0x2) {
                if (u || sz_q == 0x2)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FmlaDX, FmlaQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u || sz_q == 0x2)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FmlsDX, FmlsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FaddpDX, FaddpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FaddDX, FaddQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FabdDX, FabdQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FsubDX, FsubQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1b:
            if (size < 0x2 && sz_q != 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmulDX, FmulQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmulxDX, FmulxQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                return new Unknown64(machInst);
            }
          case 0x1c:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FcmgeDX, FcmgeQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FcmeqDX, FcmeqQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FcmgtDX, FcmgtQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1d:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FacgeDX, FacgeQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FacgtDX, FacgtQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1e:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FmaxpDX, FmaxpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FmaxDX, FmaxQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeFpReg<FminpDX, FminpQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FminDX, FminQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          case 0x1f:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeFpReg<FdivDX, FdivQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeFpReg<FrecpsDX, FrecpsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return new Unknown64(machInst);
                else
                    return decodeNeonUThreeFpReg<FrsqrtsDX, FrsqrtsQX>(
                        q, size & 0x1, machInst, vd, vn, vm);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeon3Diff(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x0:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UaddlX, Uaddl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SaddlX, Saddl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x1:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UaddwX, Uaddw2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SaddwX, Saddw2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x2:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UsublX, Usubl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SsublX, Ssubl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x3:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UsubwX, Usubw2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SsubwX, Ssubw2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x4:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<RaddhnX, Raddhn2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<AddhnX, Addhn2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x5:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabalX, Uabal2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabalX, Sabal2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x6:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<RsubhnX, Rsubhn2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeSReg<SubhnX, Subhn2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x7:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UabdlX, Uabdl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SabdlX, Sabdl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x8:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmlalX, Umlal2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmlalX, Smlal2X>(
                    q, size, machInst, vd, vn, vm);
          case 0x9:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmlal2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmlalX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xa:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmlslX, Umlsl2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmlslX, Smlsl2X>(
                    q, size, machInst, vd, vn, vm);
          case 0xb:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmlsl2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmlslX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xc:
            if (size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeSReg<UmullX, Umull2X>(
                    q, size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeSReg<SmullX, Smull2X>(
                    q, size, machInst, vd, vn, vm);
          case 0xd:
            if (u || (size == 0x0 || size == 0x3)) {
                return new Unknown64(machInst);
            } else {
                if (q) {
                    return decodeNeonSThreeHAndWReg<Sqdmull2X>(
                        size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeHAndWReg<SqdmullX>(
                        size, machInst, vd, vn, vm);
                }
            }
          case 0xe:
            if (u || size != 0) {
                return new Unknown64(machInst);
            } else {
                if (q)
                    return new Pmull2X<uint8_t>(machInst, vd, vn, vm);
                else
                    return new PmullX<uint8_t>(machInst, vd, vn, vm);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeon2RegMisc(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        IntRegIndex vd = (IntRegIndex)(uint8_t)bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex)(uint8_t)bits(machInst, 9, 5);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;
        uint8_t op = (uint8_t)((bits(machInst, 12) << 1) |
                               bits(machInst, 29));
        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);

        switch (switchVal) {
          case 0x00:
            if (op + size >= 3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<Rev64DX, Rev64QX>(
                q, size, machInst, vd, vn);
          case 0x01:
            if (op + size >= 3)
                return new Unknown64(machInst);
            if (q)
                return new Rev16QX<uint8_t>(machInst, vd, vn);
            else
                return new Rev16DX<uint8_t>(machInst, vd, vn);
          case 0x02:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SaddlpDX, SaddlpQX>(
                q, size, machInst, vd, vn);
          case 0x03:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscXReg<SuqaddDX, SuqaddQX>(
                q, size, machInst, vd, vn);
          case 0x04:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<ClsDX, ClsQX>(
                q, size, machInst, vd, vn);
          case 0x05:
            if (size != 0x0)
                return new Unknown64(machInst);
            if (q)
                return new CntQX<uint8_t>(machInst, vd, vn);
            else
                return new CntDX<uint8_t>(machInst, vd, vn);
          case 0x06:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SadalpDX, SadalpQX>(
                q, size, machInst, vd, vn);
          case 0x07:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<SqabsDX, SqabsQX>(
                q, size, machInst, vd, vn);
          case 0x08:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmgtZeroDX, CmgtZeroQX>(
                q, size, machInst, vd, vn);
          case 0x09:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmeqZeroDX, CmeqZeroQX>(
                q, size, machInst, vd, vn);
          case 0x0a:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmltZeroDX, CmltZeroQX>(
                q, size, machInst, vd, vn);
          case 0x0b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<AbsDX, AbsQX>(
                q, size, machInst, vd, vn);
          case 0x0c:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmgtZeroDX, FcmgtZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0d:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmeqZeroDX, FcmeqZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0e:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmltZeroDX, FcmltZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x0f:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FabsDX, FabsQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x12:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<XtnX, Xtn2X>(
                q, size, machInst, vd, vn);
          case 0x14:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SqxtnX, Sqxtn2X>(
                q, size, machInst, vd, vn);
          case 0x16:
            if (size > 0x1)
                return new Unknown64(machInst);
            if (q) {
                if (size)
                    return new Fcvtn2X<uint32_t>(machInst, vd, vn);
                else
                    return new Fcvtn2X<uint16_t>(machInst, vd, vn);
            } else {
                if (size)
                    return new FcvtnX<uint32_t>(machInst, vd, vn);
                else
                    return new FcvtnX<uint16_t>(machInst, vd, vn);
            }
          case 0x17:
            if (size > 0x1)
                return new Unknown64(machInst);
            if (q) {
                if (size)
                    return new Fcvtl2X<uint32_t>(machInst, vd, vn);
                else
                    return new Fcvtl2X<uint16_t>(machInst, vd, vn);
            } else {
                if (size)
                    return new FcvtlX<uint32_t>(machInst, vd, vn);
                else
                    return new FcvtlX<uint16_t>(machInst, vd, vn);
            }
          case 0x18:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintnDX, FrintnQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintpDX, FrintpQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x19:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintmDX, FrintmQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintzDX, FrintzQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtnsDX, FcvtnsQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtpsDX, FcvtpsQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1b:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtmsDX, FcvtmsQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtzsIntDX, FcvtzsIntQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x1c:
            if (size < 0x2) {
                if (sz_q == 0x2)
                    return new Unknown64(machInst);
                return decodeNeonUTwoMiscFpReg<FcvtasDX, FcvtasQX>(
                    q, size & 0x1, machInst, vd, vn);
            } else {
                if (size & 0x1)
                    return new Unknown64(machInst);
                if (q)
                    return new UrecpeQX<uint32_t>(machInst, vd, vn);
                else
                    return new UrecpeDX<uint32_t>(machInst, vd, vn);
            }
          case 0x1d:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q) {
                    if (size & 0x1)
                        return new ScvtfIntDQX<uint64_t>(machInst, vd, vn);
                    else
                        return new ScvtfIntSQX<uint32_t>(machInst, vd, vn);
                } else {
                    if (size & 0x1)
                        return new Unknown(machInst);
                    else
                        return new ScvtfIntDX<uint32_t>(machInst, vd, vn);
                }
            } else {
                return decodeNeonUTwoMiscFpReg<FrecpeDX, FrecpeQX>(
                    q, size & 0x1, machInst, vd, vn);
            }
          case 0x20:
            if (op + size >= 3)
                return new Unknown64(machInst);
            if (q) {
                if (size & 0x1)
                    return new Rev32QX<uint16_t>(machInst, vd, vn);
                else
                    return new Rev32QX<uint8_t>(machInst, vd, vn);
            } else {
                if (size & 0x1)
                    return new Rev32DX<uint16_t>(machInst, vd, vn);
                else
                    return new Rev32DX<uint8_t>(machInst, vd, vn);
            }
          case 0x22:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UaddlpDX, UaddlpQX>(
                q, size, machInst, vd, vn);
          case 0x23:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscXReg<UsqaddDX, UsqaddQX>(
                q, size, machInst, vd, vn);
            return new Unknown64(machInst);
          case 0x24:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<ClzDX, ClzQX>(
                q, size, machInst, vd, vn);
          case 0x25:
            if (size == 0x0) {
                if (q)
                    return new MvnQX<uint64_t>(machInst, vd, vn);
                else
                    return new MvnDX<uint64_t>(machInst, vd, vn);
            } else if (size == 0x1) {
                if (q)
                    return new RbitQX<uint8_t>(machInst, vd, vn);
                else
                    return new RbitDX<uint8_t>(machInst, vd, vn);
            } else {
                return new Unknown64(machInst);
            }
          case 0x26:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UadalpDX, UadalpQX>(
                q, size, machInst, vd, vn);
          case 0x27:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<SqnegDX, SqnegQX>(
                q, size, machInst, vd, vn);
          case 0x28:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmgeZeroDX, CmgeZeroQX>(
                q, size, machInst, vd, vn);
          case 0x29:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<CmleZeroDX, CmleZeroQX>(
                q, size, machInst, vd, vn);
          case 0x2b:
            if (size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscXReg<NegDX, NegQX>(
                q, size, machInst, vd, vn);
          case 0x2c:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmgeZeroDX, FcmgeZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x2d:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FcmleZeroDX, FcmleZeroQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x2f:
            if (size < 0x2 || size_q == 0x6)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FnegDX, FnegQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x32:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSTwoMiscSReg<SqxtunX, Sqxtun2X>(
                q, size, machInst, vd, vn);
          case 0x33:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<ShllX, Shll2X>(
                q, size, machInst, vd, vn);
          case 0x34:
            if (size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscSReg<UqxtnX, Uqxtn2X>(
                q, size, machInst, vd, vn);
          case 0x36:
            if (size != 0x1)
                return new Unknown64(machInst);
            if (q)
                return new Fcvtxn2X<uint32_t>(machInst, vd, vn);
            else
                return new FcvtxnX<uint32_t>(machInst, vd, vn);
          case 0x38:
            if (size > 0x1 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FrintaDX, FrintaQX>(
                q, size & 0x1, machInst, vd, vn);
          case 0x39:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FrintxDX, FrintxQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrintiDX, FrintiQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3a:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtnuDX, FcvtnuQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtpuDX, FcvtpuQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3b:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<FcvtmuDX, FcvtmuQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FcvtzuIntDX, FcvtzuIntQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3c:
            if (size < 0x2) {
                return decodeNeonUTwoMiscFpReg<FcvtauDX, FcvtauQX>(
                    q, size & 0x1, machInst, vd, vn);
            } else if (size == 0x2) {
                if (q)
                    return new UrsqrteQX<uint32_t>(machInst, vd, vn);
                else
                    return new UrsqrteDX<uint32_t>(machInst, vd, vn);
            } else {
                return new Unknown64(machInst);
            }
          case 0x3d:
            if (sz_q == 0x2)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUTwoMiscFpReg<UcvtfIntDX, UcvtfIntQX>(
                    q, size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscFpReg<FrsqrteDX, FrsqrteQX>(
                    q, size & 0x1, machInst, vd, vn);
          case 0x3f:
            if (size < 0x2 || sz_q == 0x2)
                return new Unknown64(machInst);
            return decodeNeonUTwoMiscFpReg<FsqrtDX, FsqrtQX>(
                q, size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonAcrossLanes(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size_q = (size << 1) | q;
        uint8_t sz_q = size_q & 0x3;
        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);

        switch (switchVal) {
          case 0x03:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesLongReg<SaddlvDX, SaddlvQX,
                                                 SaddlvBQX>(
                q, size, machInst, vd, vn);
          case 0x0a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesReg<SmaxvDX, SmaxvQX>(
                q, size, machInst, vd, vn);
          case 0x1a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonSAcrossLanesReg<SminvDX, SminvQX>(
                q, size, machInst, vd, vn);
          case 0x1b:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<AddvDX, AddvQX>(
                q, size, machInst, vd, vn);
          case 0x23:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesLongReg<UaddlvDX, UaddlvQX,
                                                 UaddlvBQX>(
                q, size, machInst, vd, vn);
          case 0x2a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<UmaxvDX, UmaxvQX>(
                q, size, machInst, vd, vn);
          case 0x2c:
            if (sz_q != 0x1)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q)
                    return new FmaxnmvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            } else {
                if (q)
                    return new FminnmvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            }
          case 0x2f:
            if (sz_q != 0x1)
                return new Unknown64(machInst);
            if (size < 0x2) {
                if (q)
                    return new FmaxvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            } else {
                if (q)
                    return new FminvQX<uint32_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            }
          case 0x3a:
            if (size_q == 0x4 || size == 0x3)
                return new Unknown64(machInst);
            return decodeNeonUAcrossLanesReg<UminvDX, UminvQX>(
                q, size, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonCopy(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op = bits(machInst, 29);
        uint8_t imm5 = bits(machInst, 20, 16);
        uint8_t imm4 = bits(machInst, 14, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t imm5_pos = findLsbSet(imm5);
        uint8_t index1 = 0, index2 = 0;

        if (op) {
            if (!q || (imm4 & mask(imm5_pos)))
                return new Unknown64(machInst);

            index1 = bits(imm5, 4, imm5_pos + 1);  // dst
            index2 = bits(imm4, 3, imm5_pos);  // src

            switch (imm5_pos) {
              case 0:
                return new InsElemX<uint8_t>(machInst, vd, vn, index1, index2);
              case 1:
                return new InsElemX<uint16_t>(machInst, vd, vn, index1, index2);
              case 2:
                return new InsElemX<uint32_t>(machInst, vd, vn, index1, index2);
              case 3:
                return new InsElemX<uint64_t>(machInst, vd, vn, index1, index2);
              default:
                return new Unknown64(machInst);
            }
        }

        switch (imm4) {
          case 0x0:
            index1 = bits(imm5, 4, imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                if (q)
                    return new DupElemQX<uint8_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                if (q)
                    return new DupElemQX<uint16_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                if (q)
                    return new DupElemQX<uint32_t>(machInst, vd, vn, index1);
                else
                    return new DupElemDX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                if (q)
                    return new DupElemQX<uint64_t>(machInst, vd, vn, index1);
                else
                    return new Unknown64(machInst);
              default:
                return new Unknown64(machInst);
            }
          case 0x1:
            switch (imm5) {
              case 0x1:
                if (q)
                    return new DupGprWQX<uint8_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint8_t>(machInst, vd, vn);
              case 0x2:
                if (q)
                    return new DupGprWQX<uint16_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint16_t>(machInst, vd, vn);
              case 0x4:
                if (q)
                    return new DupGprWQX<uint32_t>(machInst, vd, vn);
                else
                    return new DupGprWDX<uint32_t>(machInst, vd, vn);
              case 0x8:
                if (q)
                    return new DupGprXQX<uint64_t>(machInst, vd, vn);
                else
                    return new Unknown64(machInst);
            }
          case 0x3:
            index1 = imm5 >> (imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                return new InsGprWX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                return new InsGprWX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                return new InsGprWX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                return new InsGprXX<uint64_t>(machInst, vd, vn, index1);
              default:
                return new Unknown64(machInst);
            }
          case 0x5:
            index1 = bits(imm5, 4, imm5_pos + 1);
            switch (imm5_pos) {
              case 0:
                if (q)
                    return new SmovXX<int8_t>(machInst, vd, vn, index1);
                else
                    return new SmovWX<int8_t>(machInst, vd, vn, index1);
              case 1:
                if (q)
                    return new SmovXX<int16_t>(machInst, vd, vn, index1);
                else
                    return new SmovWX<int16_t>(machInst, vd, vn, index1);
              case 2:
                if (q)
                    return new SmovXX<int32_t>(machInst, vd, vn, index1);
                else
                    return new Unknown64(machInst);
              default:
                return new Unknown64(machInst);
            }
          case 0x7:
            index1 = imm5 >> (imm5_pos + 1);

            if ((q && imm5_pos != 3) || (!q && imm5_pos >= 3))
                return new Unknown64(machInst);

            switch (imm5_pos) {
              case 0:
                return new UmovWX<uint8_t>(machInst, vd, vn, index1);
              case 1:
                return new UmovWX<uint16_t>(machInst, vd, vn, index1);
              case 2:
                return new UmovWX<uint32_t>(machInst, vd, vn, index1);
              case 3:
                return new UmovXX<uint64_t>(machInst, vd, vn, index1);
              default:
                return new Unknown64(machInst);
            }
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonIndexedElem(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t L = bits(machInst, 21);
        uint8_t M = bits(machInst, 20);
        uint8_t opcode = bits(machInst, 15, 12);
        uint8_t H = bits(machInst, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm_bf = (IntRegIndex) (uint8_t) bits(machInst, 19, 16);

        uint8_t index = 0;
        uint8_t index_fp = 0;
        uint8_t vmh = 0;
        uint8_t sz = size & 0x1;
        uint8_t sz_q = (sz << 1) | bits(machInst, 30);
        uint8_t sz_L = (sz << 1) | L;

        // Index and 2nd register operand for integer instructions
        if (size == 0x1) {
            index = (H << 2) | (L << 1) | M;
            // vmh = 0;
        } else if (size == 0x2) {
            index = (H << 1) | L;
            vmh = M;
        }
        IntRegIndex vm = (IntRegIndex) (uint8_t) (vmh << 4 | vm_bf);

        // Index and 2nd register operand for FP instructions
        vmh = M;
        if ((size & 0x1) == 0) {
            index_fp = (H << 1) | L;
        } else if (L == 0) {
            index_fp = H;
        }
        IntRegIndex vm_fp = (IntRegIndex) (uint8_t) (vmh << 4 | vm_bf);

        switch (opcode) {
          case 0x0:
            if (!u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmHAndWReg<MlaElemDX, MlaElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x1:
            if (!u && size >= 2 && sz_q != 0x2 && sz_L != 0x3)
                return decodeNeonUThreeImmFpReg<FmlaElemDX, FmlaElemQX>(
                    q, sz, machInst, vd, vn, vm_fp, index_fp);
            else
                return new Unknown64(machInst);
          case 0x2:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmlalElemX, UmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmlalElemX, SmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x3:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlalElemX,
                                                   SqdmlalElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x4:
            if (u && !(size == 0x0 || size == 0x3))
                return decodeNeonUThreeImmHAndWReg<MlsElemDX, MlsElemQX>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return new Unknown64(machInst);
          case 0x5:
            if (!u && size >= 0x2 && sz_L != 0x3 && sz_q != 0x2)
                return decodeNeonUThreeImmFpReg<FmlsElemDX, FmlsElemQX>(
                    q, sz, machInst, vd, vn, vm_fp, index_fp);
            else
                return new Unknown64(machInst);
          case 0x6:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmlslElemX, UmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmlslElemX, SmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x7:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlslElemX,
                                                   SqdmlslElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x8:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmHAndWReg<MulElemDX, MulElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0x9:
            if (size >= 2 && sz_q != 0x2 && sz_L != 0x3) {
                if (u)
                    return decodeNeonUThreeImmFpReg<FmulxElemDX, FmulxElemQX>(
                        q, sz, machInst, vd, vn, vm_fp, index_fp);
                else
                    return decodeNeonUThreeImmFpReg<FmulElemDX, FmulElemQX>(
                        q, sz, machInst, vd, vn, vm_fp, index_fp);
            } else {
                return new Unknown64(machInst);
            }
          case 0xa:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmHAndWReg<UmullElemX, UmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
            else
                return decodeNeonSThreeImmHAndWReg<SmullElemX, SmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xb:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmullElemX, SqdmullElem2X>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xc:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmulhElemDX, SqdmulhElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          case 0xd:
            if (u || (size == 0x0 || size == 0x3))
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqrdmulhElemDX, SqrdmulhElemQX>(
                    q, size, machInst, vd, vn, vm, index);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonModImm(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op = bits(machInst, 29);
        uint8_t abcdefgh = (bits(machInst, 18, 16) << 5) |
                           bits(machInst, 9, 5);
        uint8_t cmode = bits(machInst, 15, 12);
        uint8_t o2 = bits(machInst, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);

        if (o2 == 0x1 || (op == 0x1 && cmode == 0xf && !q))
            return new Unknown64(machInst);

        bool immValid = true;
        const uint64_t bigImm = simd_modified_imm(op, cmode, abcdefgh,
                                                  immValid,
                                                  true /* isAarch64 */);
        if (!immValid) {
            return new Unknown(machInst);
        }

        if (op) {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new MvniQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new MvniDX<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new BicImmQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new BicImmDX<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    switch (bits(cmode, 1, 0)) {
                      case 0:
                      case 1:
                        if (q)
                            return new MvniQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MvniDX<uint64_t>(machInst, vd, bigImm);
                      case 2:
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                      case 3:
                        if (q)
                            return new FmovQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new MvniQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MvniDX<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new BicImmQX<uint64_t>(machInst, vd,
                                                          bigImm);
                        else
                            return new BicImmDX<uint64_t>(machInst, vd,
                                                          bigImm);
                    }
                }
            }
        } else {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new MoviQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new MoviDX<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new OrrImmQX<uint64_t>(machInst, vd, bigImm);
                    else
                        return new OrrImmDX<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    if (bits(cmode, 1, 0) == 0x3) {
                        if (q)
                            return new FmovQX<uint32_t>(machInst, vd, bigImm);
                        else
                            return new FmovDX<uint32_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new MoviQX<uint64_t>(machInst, vd, bigImm);
                        else
                            return new MoviDX<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new OrrImmQX<uint64_t>(machInst, vd,
                                                          bigImm);
                        else
                            return new OrrImmDX<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }

    StaticInstPtr
    decodeNeonShiftByImm(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t u = bits(machInst, 29);
        uint8_t immh = bits(machInst, 22, 19);
        uint8_t immb = bits(machInst, 18, 16);
        uint8_t opcode = bits(machInst, 15, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t immh3 = bits(machInst, 22);
        uint8_t immh3_q = (immh3 << 1) | q;
        uint8_t op_u = (bits(machInst, 12) << 1) | u;
        uint8_t size = findMsbSet(immh);
        int shiftAmt = 0;

        switch (opcode) {
          case 0x00:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UshrDX, UshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SshrDX, SshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x02:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UsraDX, UsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SsraDX, SsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x04:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UrshrDX, UrshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SrshrDX, SrshrQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x06:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftXReg<UrsraDX, UrsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SrsraDX, SrsraQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x08:
            if (u && !(immh3_q == 0x2)) {
                shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
                return decodeNeonUTwoShiftXReg<SriDX, SriQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0a:
            if (immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftXReg<SliDX, SliQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftXReg<ShlDX, ShlQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x0c:
            if (u && !(immh3_q == 0x2 || op_u == 0x0)) {
                shiftAmt = ((immh << 3) | immb) - (8 << size);
                return decodeNeonSTwoShiftXReg<SqshluDX, SqshluQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0e:
            if (immh3_q == 0x2 || op_u == 0x0)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftXReg<UqshlImmDX, UqshlImmQX>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftXReg<SqshlImmDX, SqshlImmQX>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x10:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonSTwoShiftSReg<SqshrunX, Sqshrun2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftSReg<ShrnX, Shrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x11:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonSTwoShiftSReg<SqrshrunX, Sqrshrun2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftSReg<RshrnX, Rshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x12:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftSReg<UqshrnX, Uqshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SqshrnX, Sqshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x13:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftSReg<UqrshrnX, Uqrshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SqrshrnX, Sqrshrn2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x14:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftSReg<UshllX, Ushll2X>(
                    q, size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftSReg<SshllX, Sshll2X>(
                    q, size, machInst, vd, vn, shiftAmt);
          case 0x1c:
            if (immh < 0x4 || immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u) {
                return decodeNeonUTwoShiftFpReg<UcvtfFixedDX, UcvtfFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
            } else {
                if (q) {
                    if (size & 0x1)
                        return new ScvtfFixedDQX<uint64_t>(machInst, vd, vn,
                                                           shiftAmt);
                    else
                        return new ScvtfFixedSQX<uint32_t>(machInst, vd, vn,
                                                           shiftAmt);
                } else {
                    if (size & 0x1)
                        return new Unknown(machInst);
                    else
                        return new ScvtfFixedDX<uint32_t>(machInst, vd, vn,
                                                          shiftAmt);
                }
            }
          case 0x1f:
            if (immh < 0x4 || immh3_q == 0x2)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftFpReg<FcvtzuFixedDX, FcvtzuFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftFpReg<FcvtzsFixedDX, FcvtzsFixedQX>(
                    q, size & 0x1, machInst, vd, vn, shiftAmt);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonTblTbx(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t switchVal = bits(machInst, 14, 12);

        switch (switchVal) {
          case 0x0:
            if (q)
                return new Tbl1QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl1DX<uint8_t>(machInst, vd, vn, vm);
          case 0x1:
            if (q)
                return new Tbx1QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx1DX<uint8_t>(machInst, vd, vn, vm);
          case 0x2:
            if (q)
                return new Tbl2QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl2DX<uint8_t>(machInst, vd, vn, vm);
          case 0x3:
            if (q)
                return new Tbx2QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx2DX<uint8_t>(machInst, vd, vn, vm);
          case 0x4:
            if (q)
                return new Tbl3QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl3DX<uint8_t>(machInst, vd, vn, vm);
          case 0x5:
            if (q)
                return new Tbx3QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx3DX<uint8_t>(machInst, vd, vn, vm);
          case 0x6:
            if (q)
                return new Tbl4QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbl4DX<uint8_t>(machInst, vd, vn, vm);
          case 0x7:
            if (q)
                return new Tbx4QX<uint8_t>(machInst, vd, vn, vm);
            else
                return new Tbx4DX<uint8_t>(machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }

        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeNeonZipUzpTrn(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 14, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x1:
            return decodeNeonUThreeXReg<Uzp1DX, Uzp1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x2:
            return decodeNeonUThreeXReg<Trn1DX, Trn1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x3:
            return decodeNeonUThreeXReg<Zip1DX, Zip1QX>(
                q, size, machInst, vd, vn, vm);
          case 0x5:
            return decodeNeonUThreeXReg<Uzp2DX, Uzp2QX>(
                q, size, machInst, vd, vn, vm);
          case 0x6:
            return decodeNeonUThreeXReg<Trn2DX, Trn2QX>(
                q, size, machInst, vd, vn, vm);
          case 0x7:
            return decodeNeonUThreeXReg<Zip2DX, Zip2QX>(
                q, size, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeNeonExt(ExtMachInst machInst)
    {
        uint8_t q = bits(machInst, 30);
        uint8_t op2 = bits(machInst, 23, 22);
        uint8_t imm4 = bits(machInst, 14, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        if (op2 != 0 || (q == 0x0 && bits(imm4, 3) == 0x1))
            return new Unknown64(machInst);

        uint8_t index = q ? imm4 : imm4 & 0x7;

        if (q) {
            return new ExtQX<uint8_t>(machInst, vd, vn, vm, index);
        } else {
            return new ExtDX<uint8_t>(machInst, vd, vn, vm, index);
        }
    }

    StaticInstPtr
    decodeNeonSc3Same(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 15, 11);
        uint8_t s = bits(machInst, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x01:
            if (u)
                return decodeNeonUThreeUReg<UqaddScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqaddScX>(
                    size, machInst, vd, vn, vm);
          case 0x05:
            if (u)
                return decodeNeonUThreeUReg<UqsubScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqsubScX>(
                    size, machInst, vd, vn, vm);
          case 0x06:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmhiDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmgtDX<int64_t>(machInst, vd, vn, vm);
          case 0x07:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmhsDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmgeDX<int64_t>(machInst, vd, vn, vm);
          case 0x08:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new UshlDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new SshlDX<int64_t>(machInst, vd, vn, vm);
          case 0x09:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeUReg<UqshlScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqshlScX>(
                    size, machInst, vd, vn, vm);
          case 0x0a:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new UrshlDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new SrshlDX<int64_t>(machInst, vd, vn, vm);
          case 0x0b:
            if (!s && size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeUReg<UqrshlScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeUReg<SqrshlScX>(
                    size, machInst, vd, vn, vm);
          case 0x10:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new SubDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new AddDX<uint64_t>(machInst, vd, vn, vm);
          case 0x11:
            if (size != 0x3)
                return new Unknown64(machInst);
            if (u)
                return new CmeqDX<uint64_t>(machInst, vd, vn, vm);
            else
                return new CmtstDX<uint64_t>(machInst, vd, vn, vm);
          case 0x16:
            if (size == 0x3 || size == 0x0)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonSThreeHAndWReg<SqrdmulhScX>(
                    size, machInst, vd, vn, vm);
            else
                return decodeNeonSThreeHAndWReg<SqdmulhScX>(
                    size, machInst, vd, vn, vm);
          case 0x1a:
            if (!u || size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeScFpReg<FabdScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1b:
            if (u || size > 0x1)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeScFpReg<FmulxScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1c:
            if (size < 0x2) {
                if (u)
                    return decodeNeonUThreeScFpReg<FcmgeScX>(
                        size & 0x1, machInst, vd, vn, vm);
                else
                    return decodeNeonUThreeScFpReg<FcmeqScX>(
                        size & 0x1, machInst, vd, vn, vm);
            } else {
                if (u)
                    return decodeNeonUThreeScFpReg<FcmgtScX>(
                        size & 0x1, machInst, vd, vn, vm);
                else
                    return new Unknown64(machInst);
            }
          case 0x1d:
            if (!u)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUThreeScFpReg<FacgeScX>(
                    size & 0x1, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeScFpReg<FacgtScX>(
                    size & 0x1, machInst, vd, vn, vm);
          case 0x1f:
            if (u)
                return new Unknown64(machInst);
            if (size < 0x2)
                return decodeNeonUThreeScFpReg<FrecpsScX>(
                    size & 0x1, machInst, vd, vn, vm);
            else
                return decodeNeonUThreeScFpReg<FrsqrtsScX>(
                    size & 0x1, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonSc3Diff(ExtMachInst machInst)
    {
        if (bits(machInst, 29))
            return new Unknown64(machInst);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0x0 || size == 0x3)
            return new Unknown64(machInst);

        uint8_t opcode = bits(machInst, 15, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

        switch (opcode) {
          case 0x9:
            return decodeNeonSThreeHAndWReg<SqdmlalScX>(size, machInst, vd, vn, vm);
          case 0xb:
            return decodeNeonSThreeHAndWReg<SqdmlslScX>(size, machInst, vd, vn, vm);
          case 0xd:
            return decodeNeonSThreeHAndWReg<SqdmullScX>(size, machInst, vd, vn, vm);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonSc2RegMisc(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t switchVal = opcode | ((u ? 1 : 0) << 5);
        switch (switchVal) {
          case 0x03:
            return decodeNeonUTwoMiscUReg<SuqaddScX>(size, machInst, vd, vn);
          case 0x07:
            return decodeNeonSTwoMiscUReg<SqabsScX>(size, machInst, vd, vn);
          case 0x08:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmgtZeroDX<int64_t>(machInst, vd, vn);
          case 0x09:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmeqZeroDX<int64_t>(machInst, vd, vn);
          case 0x0a:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmltZeroDX<int64_t>(machInst, vd, vn);
          case 0x0b:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new AbsDX<int64_t>(machInst, vd, vn);
          case 0x0c:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmgtZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0d:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmeqZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0e:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmltZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x14:
            if (size == 0x3) {
                return new Unknown64(machInst);
            } else {
                switch (size) {
                  case 0x0:
                    return new SqxtnScX<int8_t>(machInst, vd, vn);
                  case 0x1:
                    return new SqxtnScX<int16_t>(machInst, vd, vn);
                  case 0x2:
                    return new SqxtnScX<int32_t>(machInst, vd, vn);
                }
            }
          case 0x1a:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtnsScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtpsScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x1b:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtmsScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtzsIntScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x1c:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtasScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return new Unknown64(machInst);
          case 0x1d:
            if (size < 0x2) {
                if (size & 0x1)
                    return new ScvtfIntScDX<uint64_t>(machInst, vd, vn);
                else
                    return new ScvtfIntScSX<uint32_t>(machInst, vd, vn);
            } else {
                return decodeNeonUTwoMiscScFpReg<FrecpeScX>(
                    size & 0x1, machInst, vd, vn);
            }
          case 0x1f:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FrecpxX>(
                    size & 0x1, machInst, vd, vn);
          case 0x23:
            return decodeNeonUTwoMiscUReg<UsqaddScX>(size, machInst, vd, vn);
          case 0x27:
            return decodeNeonSTwoMiscUReg<SqnegScX>(size, machInst, vd, vn);
          case 0x28:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmgeZeroDX<int64_t>(machInst, vd, vn);
          case 0x29:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new CmleZeroDX<int64_t>(machInst, vd, vn);
          case 0x2b:
            if (size != 0x3)
                return new Unknown64(machInst);
            else
                return new NegDX<int64_t>(machInst, vd, vn);
          case 0x2c:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmgeZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x2d:
            if (size < 0x2)
                return new Unknown64(machInst);
            else
                return decodeNeonUTwoMiscScFpReg<FcmleZeroScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x32:
            if (size == 0x3) {
                return new Unknown64(machInst);
            } else {
                switch (size) {
                  case 0x0:
                    return new SqxtunScX<int8_t>(machInst, vd, vn);
                  case 0x1:
                    return new SqxtunScX<int16_t>(machInst, vd, vn);
                  case 0x2:
                    return new SqxtunScX<int32_t>(machInst, vd, vn);
                }
            }
          case 0x34:
            if (size == 0x3) {
                return new Unknown64(machInst);
            } else {
                switch (size) {
                  case 0x0:
                    return new UqxtnScX<uint8_t>(machInst, vd, vn);
                  case 0x1:
                    return new UqxtnScX<uint16_t>(machInst, vd, vn);
                  case 0x2:
                    return new UqxtnScX<uint32_t>(machInst, vd, vn);
                }
            }
          case 0x36:
            if (size != 0x1) {
                return new Unknown64(machInst);
            } else {
                return new FcvtxnScX<uint32_t>(machInst, vd, vn);
            }
          case 0x3a:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtnuScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtpuScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x3b:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtmuScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FcvtzuIntScX>(
                    size & 0x1, machInst, vd, vn);
          case 0x3c:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<FcvtauScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return new Unknown64(machInst);
          case 0x3d:
            if (size < 0x2)
                return decodeNeonUTwoMiscScFpReg<UcvtfIntScX>(
                    size & 0x1, machInst, vd, vn);
            else
                return decodeNeonUTwoMiscScFpReg<FrsqrteScX>(
                    size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScPwise(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opcode = bits(machInst, 16, 12);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        if (!u) {
            if (opcode == 0x1b && size == 0x3)
                return new AddpScQX<uint64_t>(machInst, vd, vn);
            else
                return new Unknown64(machInst);
        }

        uint8_t switchVal = (opcode << 0) | (size << 5);
        switch (switchVal) {
          case 0x0c:
          case 0x2c:
            return decodeNeonUTwoMiscPwiseScFpReg<FmaxnmpScDX, FmaxnmpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0d:
          case 0x2d:
            return decodeNeonUTwoMiscPwiseScFpReg<FaddpScDX, FaddpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x0f:
          case 0x2f:
            return decodeNeonUTwoMiscPwiseScFpReg<FmaxpScDX, FmaxpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x4c:
          case 0x6c:
            return decodeNeonUTwoMiscPwiseScFpReg<FminnmpScDX, FminnmpScQX>(
                    size & 0x1, machInst, vd, vn);
          case 0x4f:
          case 0x6f:
            return decodeNeonUTwoMiscPwiseScFpReg<FminpScDX, FminpScQX>(
                    size & 0x1, machInst, vd, vn);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScCopy(ExtMachInst machInst)
    {
        if (bits(machInst, 14, 11) != 0 || bits(machInst, 29))
            return new Unknown64(machInst);

        uint8_t imm5 = bits(machInst, 20, 16);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t size = findLsbSet(imm5);
        uint8_t index = bits(imm5, 4, size + 1);

        return decodeNeonUTwoShiftUReg<DupElemScX>(
            size, machInst, vd, vn, index);
    }

    StaticInstPtr
    decodeNeonScIndexedElem(ExtMachInst machInst)
    {
        uint8_t u = bits(machInst, 29);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t L = bits(machInst, 21);
        uint8_t M = bits(machInst, 20);
        uint8_t opcode = bits(machInst, 15, 12);
        uint8_t H = bits(machInst, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
        IntRegIndex vm_bf = (IntRegIndex) (uint8_t) bits(machInst, 19, 16);

        uint8_t index = 0;
        uint8_t index_fp = 0;
        uint8_t vmh = 0;
        uint8_t sz_L = bits(machInst, 22, 21);

        // Index and 2nd register operand for integer instructions
        if (size == 0x1) {
            index = (H << 2) | (L << 1) | M;
            // vmh = 0;
        } else if (size == 0x2) {
            index = (H << 1) | L;
            vmh = M;
        } else if (size == 0x3) {
            index = H;
            vmh = M;
        }
        IntRegIndex vm = (IntRegIndex) (uint8_t) (vmh << 4 | vm_bf);

        // Index and 2nd register operand for FP instructions
        vmh = M;
        if ((size & 0x1) == 0) {
            index_fp = (H << 1) | L;
        } else if (L == 0) {
            index_fp = H;
        }
        IntRegIndex vm_fp = (IntRegIndex) (uint8_t) (vmh << 4 | vm_bf);

        if (u && opcode != 9)
            return new Unknown64(machInst);

        switch (opcode) {
          case 0x1:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmScFpReg<FmlaElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0x3:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlalElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0x5:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonUThreeImmScFpReg<FmlsElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0x7:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmlslElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0x9:
            if (size < 2 || sz_L == 0x3)
                return new Unknown64(machInst);
            if (u)
                return decodeNeonUThreeImmScFpReg<FmulxElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
            else
                return decodeNeonUThreeImmScFpReg<FmulElemScX>(
                    size & 0x1, machInst, vd, vn, vm_fp, index_fp);
          case 0xb:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmullElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0xc:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqdmulhElemScX>(
                    size, machInst, vd, vn, vm, index);
          case 0xd:
            if (size == 0x0 || size == 0x3)
                return new Unknown64(machInst);
            else
                return decodeNeonSThreeImmHAndWReg<SqrdmulhElemScX>(
                    size, machInst, vd, vn, vm, index);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonScShiftByImm(ExtMachInst machInst)
    {
        bool u = bits(machInst, 29);
        uint8_t immh = bits(machInst, 22, 19);
        uint8_t immb = bits(machInst, 18, 16);
        uint8_t opcode = bits(machInst, 15, 11);

        IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
        IntRegIndex vn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);

        uint8_t immh3 = bits(machInst, 22);
        uint8_t size = findMsbSet(immh);
        int shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);

        if (immh == 0x0)
            return new Unknown64(machInst);

        switch (opcode) {
          case 0x00:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UshrDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SshrDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x02:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UsraDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SsraDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x04:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UrshrDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SrshrDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x06:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new UrsraDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new SrsraDX<int64_t>(machInst, vd, vn, shiftAmt);
          case 0x08:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return new SriDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new Unknown64(machInst);
          case 0x0a:
            if (!immh3)
                return new Unknown64(machInst);
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return new SliDX<uint64_t>(machInst, vd, vn, shiftAmt);
            else
                return new ShlDX<uint64_t>(machInst, vd, vn, shiftAmt);
          case 0x0c:
            if (u) {
                shiftAmt = ((immh << 3) | immb) - (8 << size);
                return decodeNeonSTwoShiftUReg<SqshluScX>(
                    size, machInst, vd, vn, shiftAmt);
            } else {
                return new Unknown64(machInst);
            }
          case 0x0e:
            shiftAmt = ((immh << 3) | immb) - (8 << size);
            if (u)
                return decodeNeonUTwoShiftUReg<UqshlImmScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUReg<SqshlImmScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x10:
            if (!u || immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            return decodeNeonSTwoShiftUSReg<SqshrunScX>(
                size, machInst, vd, vn, shiftAmt);
          case 0x11:
            if (!u || immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            return decodeNeonSTwoShiftUSReg<SqrshrunScX>(
                size, machInst, vd, vn, shiftAmt);
          case 0x12:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUSReg<UqshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUSReg<SqshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x13:
            if (immh3)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUSReg<UqrshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonSTwoShiftUSReg<SqrshrnScX>(
                    size, machInst, vd, vn, shiftAmt);
          case 0x1c:
            if (immh < 0x4)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u) {
                return decodeNeonUTwoShiftUFpReg<UcvtfFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
            } else {
                if (size & 0x1)
                    return new ScvtfFixedScDX<uint64_t>(machInst, vd, vn,
                                                        shiftAmt);
                else
                    return new ScvtfFixedScSX<uint32_t>(machInst, vd, vn,
                                                        shiftAmt);
            }
          case 0x1f:
            if (immh < 0x4)
                return new Unknown64(machInst);
            shiftAmt = (8 << (size + 1)) - ((immh << 3) | immb);
            if (u)
                return decodeNeonUTwoShiftUFpReg<FcvtzuFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
            else
                return decodeNeonUTwoShiftUFpReg<FcvtzsFixedScX>(
                    size & 0x1, machInst, vd, vn, shiftAmt);
          default:
            return new Unknown64(machInst);
        }
    }

    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst)
    {
        uint8_t dataSize = bits(machInst, 30) ? 128 : 64;
        bool multiple = bits(machInst, 24, 23) < 0x2;
        bool load = bits(machInst, 22);

        uint8_t numStructElems = 0;
        uint8_t numRegs = 0;

        if (multiple) {  // AdvSIMD load/store multiple structures
            uint8_t opcode = bits(machInst, 15, 12);
            uint8_t eSize = bits(machInst, 11, 10);
            bool wb = !(bits(machInst, 20, 16) == 0x0 && !bits(machInst, 23));

            switch (opcode) {
              case 0x0:  // LD/ST4 (4 regs)
                numStructElems = 4;
                numRegs = 4;
                break;
              case 0x2:  // LD/ST1 (4 regs)
                numStructElems = 1;
                numRegs = 4;
                break;
              case 0x4:  // LD/ST3 (3 regs)
                numStructElems = 3;
                numRegs = 3;
                break;
              case 0x6:  // LD/ST1 (3 regs)
                numStructElems = 1;
                numRegs = 3;
                break;
              case 0x7:  // LD/ST1 (1 reg)
                numStructElems = 1;
                numRegs = 1;
                break;
              case 0x8:  // LD/ST2 (2 regs)
                numStructElems = 2;
                numRegs = 2;
                break;
              case 0xa:  // LD/ST1 (2 regs)
                numStructElems = 1;
                numRegs = 2;
                break;
              default:
                return new Unknown64(machInst);
            }

            IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
            IntRegIndex rn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
            IntRegIndex rm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

            if (load) {
                return new VldMult64(machInst, rn, vd, rm, eSize, dataSize,
                                     numStructElems, numRegs, wb);
            } else {
                return new VstMult64(machInst, rn, vd, rm, eSize, dataSize,
                                     numStructElems, numRegs, wb);
            }
        } else {  // AdvSIMD load/store single structure
            uint8_t scale = bits(machInst, 15, 14);
            uint8_t numStructElems = (((uint8_t) bits(machInst, 13) << 1) |
                                      (uint8_t) bits(machInst, 21)) + 1;
            uint8_t index = 0;
            bool wb = !(bits(machInst, 20, 16) == 0x0 && !bits(machInst, 23));
            bool replicate = false;

            switch (scale) {
              case 0x0:
                index = ((uint8_t) bits(machInst, 30) << 3) |
                    ((uint8_t) bits(machInst, 12) << 2) |
                    (uint8_t) bits(machInst, 11, 10);
                break;
              case 0x1:
                index = ((uint8_t) bits(machInst, 30) << 2) |
                    ((uint8_t) bits(machInst, 12) << 1) |
                    (uint8_t) bits(machInst, 11);
                break;
              case 0x2:
                if (bits(machInst, 10) == 0x0) {
                    index = ((uint8_t) bits(machInst, 30) << 1) |
                        bits(machInst, 12);
                } else {
                    index = (uint8_t) bits(machInst, 30);
                    scale = 0x3;
                }
                break;
              case 0x3:
                scale = bits(machInst, 11, 10);
                replicate = true;
                break;
              default:
                return new Unknown64(machInst);
            }

            uint8_t eSize = scale;

            IntRegIndex vd = (IntRegIndex) (uint8_t) bits(machInst, 4, 0);
            IntRegIndex rn = (IntRegIndex) (uint8_t) bits(machInst, 9, 5);
            IntRegIndex rm = (IntRegIndex) (uint8_t) bits(machInst, 20, 16);

            if (load) {
                return new VldSingle64(machInst, rn, vd, rm, eSize, dataSize,
                                       numStructElems, index, wb, replicate);
            } else {
                return new VstSingle64(machInst, rn, vd, rm, eSize, dataSize,
                                       numStructElems, index, wb, replicate);
            }
        }
    }
}

    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst)
    {
        const uint32_t b = bits(machInst, 11, 8);
        const bool single = bits(machInst, 23);
        const bool singleAll = single && (bits(b, 3, 2) == 3);
        const bool load = bits(machInst, 21);
        unsigned width = 0;
        if (single) {
            width = bits(b, 1, 0) + 1;
        } else {
            switch (bits(b, 3, 1)) {
              case 0x0: width = 4;
                break;
              case 0x1: width = (b & 0x1) ? 2 : 1;
                break;
              case 0x2: width = 3;
                break;
              case 0x3: width = 1;
                break;
              case 0x4: width = 2;
                break;
              case 0x5:
                if ((b & 0x1) == 0) {
                    width = 1;
                    break;
                }
                // Fall through on purpose.
              default:
                return new Unknown(machInst);
            }
        }
        assert(width > 0 && width <= 4);
        const RegIndex rm = (RegIndex)(uint32_t)bits(machInst, 3, 0);
        const RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 19, 16);
        const RegIndex vd = (RegIndex)(uint32_t)(bits(machInst, 15, 12) |
                                                 bits(machInst, 22) << 4);
        const uint32_t type = bits(machInst, 11, 8);
        uint32_t size = 0;
        uint32_t align = TLB::MustBeOne;
        unsigned inc = 1;
        unsigned regs = 1;
        unsigned lane = 0;
        if (single) {
            if (singleAll) {
                size = bits(machInst, 7, 6);
                bool t = bits(machInst, 5);
                align = size | TLB::AllowUnaligned;
                if (width == 1) {
                    regs = t ? 2 : 1;
                    inc = 1;
                } else {
                    regs = width;
                    inc = t ? 2 : 1;
                }
                switch (width) {
                  case 1:
                  case 2:
                    if (bits(machInst, 4))
                        align = size + width - 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    if (size == 3) {
                        if (bits(machInst, 4) == 0)
                            return new Unknown(machInst);
                        size = 2;
                        align = 0x4;
                    } else if (size == 2) {
                        if (bits(machInst, 4))
                            align = 0x3;
                    } else {
                        if (bits(machInst, 4))
                            align = size + 2;
                    }
                    break;
                }
            } else {
                size = bits(machInst, 11, 10);
                align = size | TLB::AllowUnaligned;
                regs = width;
                unsigned indexAlign = bits(machInst, 7, 4);
                // If width is 1, inc is always 1. That's overridden later.
                switch (size) {
                  case 0:
                    inc = 1;
                    lane = bits(indexAlign, 3, 1);
                    break;
                  case 1:
                    inc = bits(indexAlign, 1) ? 2 : 1;
                    lane = bits(indexAlign, 3, 2);
                    break;
                  case 2:
                    inc = bits(indexAlign, 2) ? 2 : 1;
                    lane = bits(indexAlign, 3);
                    break;
                }
                // Override inc for width of 1.
                if (width == 1) {
                    inc = 1;
                }
                switch (width) {
                  case 1:
                    switch (size) {
                      case 0:
                        break;
                      case 1:
                        if (bits(indexAlign, 0))
                            align = 1;
                        break;
                      case 2:
                        if (bits(indexAlign, 1, 0))
                            align = 2;
                        break;
                    }
                    break;
                  case 2:
                    if (bits(indexAlign, 0))
                        align = size + 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    switch (size) {
                      case 0:
                      case 1:
                        if (bits(indexAlign, 0))
                            align = size + 2;
                        break;
                      case 2:
                        if (bits(indexAlign, 0))
                            align = bits(indexAlign, 1, 0) + 2;
                        break;
                    }
                    break;
                }
            }
            if (size == 0x3) {
                return new Unknown(machInst);
            }
        } else {
            size = bits(machInst, 7, 6);
            align = bits(machInst, 5, 4);
            if (align == 0) {
                // @align wasn't specified, so alignment can be turned off.
                align = size | TLB::AllowUnaligned;
            } else {
                align = align + 2;
            }
            switch (width) {
              case 1:
                switch (type) {
                  case 0x7: regs = 1;
                    break;
                  case 0xa: regs = 2;
                    break;
                  case 0x6: regs = 3;
                    break;
                  case 0x2: regs = 4;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 2:
                // Regs doesn't behave exactly as it does in the manual
                // because they loop over regs registers twice and we break
                // it down in the macroop.
                switch (type) {
                  case 0x8: regs = 2; inc = 1;
                    break;
                  case 0x9: regs = 2; inc = 2;
                    break;
                  case 0x3: regs = 4; inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 3:
                regs = 3;
                switch (type) {
                  case 0x4: inc = 1;
                    break;
                  case 0x5: inc = 2;;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 4:
                regs = 4;
                switch (type) {
                  case 0: inc = 1;
                    break;
                  case 1: inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
            }
        }
        if (load) {
            // Load instructions.
            if (single) {
                return new VldSingle(machInst, singleAll, width, rn, vd,
                                     regs, inc, size, align, rm, lane);
            } else {
                return new VldMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        } else {
            // Store instructions.
            if (single) {
                if (singleAll) {
                    return new Unknown(machInst);
                } else {
                    return new VstSingle(machInst, false, width, rn, vd,
                                         regs, inc, size, align, rm, lane);
                }
            } else {
                return new VstMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        }
        return new Unknown(machInst);
    }
    
    static StaticInstPtr
    decodeNeonThreeRegistersSameLength(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const bool b = bits(machInst, 4);
        const uint32_t c = bits(machInst, 21, 20);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 21, 20);
        const bool q = bits(machInst, 6);
        if (q && ((vd & 0x1) || (vn & 0x1) || (vm & 0x1)))
            return new Unknown(machInst);
        switch (a) {
          case 0x0:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqaddUD, VqaddUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqaddSD, VqaddSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhaddD, VhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x1:
            if (!b) {
                return decodeNeonUSThreeReg<VrhaddD, VrhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (u) {
                    switch (c) {
                      case 0:
                        if (q) {
                            return new VeorQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VeorD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbslQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbslD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (q) {
                            return new VbitQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbitD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 3:
                        if (q) {
                            return new VbifQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbifD<uint64_t>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    switch (c) {
                      case 0:
                        if (q) {
                            return new VandQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VandD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbicQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbicD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (vn == vm) {
                            if (q) {
                                return new VmovQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VmovD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        } else {
                            if (q) {
                                return new VorrQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VorrD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        }
                      case 3:
                        if (q) {
                            return new VornQ<uint64_t>(
                                    machInst, vd, vn, vm);
                        } else {
                            return new VornD<uint64_t>(
                                    machInst, vd, vn, vm);
                        }
                    }
                }
            }
          case 0x2:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqsubUD, VqsubUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqsubSD, VqsubSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhsubD, VhsubQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x3:
            if (b) {
                return decodeNeonUSThreeReg<VcgeD, VcgeQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VcgtD, VcgtQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x4:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqshlUD, VqshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqshlSD, VqshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VshlD, VshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x5:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqrshlUD, VqrshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqrshlSD, VqrshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VrshlD, VrshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x6:
            if (b) {
                return decodeNeonUSThreeReg<VminD, VminQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VmaxD, VmaxQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (b) {
                return decodeNeonUSThreeReg<VabaD, VabaQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (bits(machInst, 23) == 1) {
                    if (q) {
                        return new Unknown(machInst);
                    } else {
                        return decodeNeonUSThreeUSReg<Vabdl>(
                                u, size, machInst, vd, vn, vm);
                    }
                } else {
                    return decodeNeonUSThreeReg<VabdD, VabdQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0x8:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VceqD, VceqQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<VtstD, VtstQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUThreeReg<NVsubD, NVsubQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<NVaddD, NVaddQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0x9:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<NVmulpD, NVmulpQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<NVmulD, NVmulQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUSThreeReg<NVmlsD, NVmlsQ>(
                            q, u, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUSThreeReg<NVmlaD, NVmlaQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0xa:
            if (q)
                return new Unknown(machInst);
            if (b) {
                return decodeNeonUSThreeUSReg<VpminD>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeUSReg<VpmaxD>(
                        u, size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (b) {
                if (u || q) {
                    return new Unknown(machInst);
                } else {
                    return decodeNeonUThreeUSReg<NVpaddD>(
                            size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonSThreeSReg<VqrdmulhD, VqrdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeSReg<VqdmulhD, VqdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0xc:
            if (b) {
                if (!u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new NVfmaQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVfmaDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new NVfmsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVfmsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
            return new Unknown(machInst);
          case 0xd:
            if (b) {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new NVmulQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmulDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new NVmlaQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlaDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new NVmlsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VpaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VabdQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VabdDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VsubQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VsubDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
          case 0xe:
            if (b) {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VacgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VacgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    return new Unknown(machInst);
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VcgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VcgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VceqQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VceqDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xf:
            if (b) {
                if (u) {
                    return new Unknown(machInst);
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VrecpsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrecpsDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VrsqrtsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrsqrtsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VpmaxQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpmaxDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VpminQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpminDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VmaxQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VmaxDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VminQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VminDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonOneRegModImm(ExtMachInst machInst)
    {
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const bool q = bits(machInst, 6);
        const bool op = bits(machInst, 5);
        const uint8_t cmode = bits(machInst, 11, 8);
        const uint8_t imm = ((THUMB ? bits(machInst, 28) :
                                      bits(machInst, 24)) << 7) |
                            (bits(machInst, 18, 16) << 4) |
                            (bits(machInst, 3, 0) << 0);
        // Check for invalid immediate encodings and return an unknown op
        // if it happens
        bool immValid = true;
        const uint64_t bigImm = simd_modified_imm(op, cmode, imm, immValid);
        if (!immValid) {
            return new Unknown(machInst);
        }
        if (op) {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    switch (bits(cmode, 1, 0)) {
                      case 0:
                      case 1:
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                      case 2:
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                      case 3:
                        if (q)
                            return new Unknown(machInst);
                        else
                            return new Unknown(machInst);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        } else {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVorriD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVorriD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegAndShift(ExtMachInst machInst)
    {
        const uint32_t a = bits(machInst, 11, 8);
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const bool b = bits(machInst, 6);
        const bool l = bits(machInst, 7);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        unsigned imm6 = bits(machInst, 21, 16);
        unsigned imm = ((l ? 1 : 0) << 6) | imm6;
        unsigned size = 3;
        unsigned lShiftAmt = 0;
        unsigned bitSel;
        for (bitSel = 1 << 6; true; bitSel >>= 1) {
            if (bitSel & imm)
                break;
            else if (!size)
                return new Unknown(machInst);
            size--;
        }
        lShiftAmt = imm6 & ~bitSel;
        unsigned rShiftAmt = 0;
        if (a != 0xe && a != 0xf) {
            if (size > 2)
                rShiftAmt = 64 - imm6;
            else
                rShiftAmt = 2 * (8 << size) - imm6;
        }
        switch (a) {
          case 0x0:
            return decodeNeonUSTwoShiftReg<NVshrD, NVshrQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x1:
            return decodeNeonUSTwoShiftReg<NVsraD, NVsraQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x2:
            return decodeNeonUSTwoShiftReg<NVrshrD, NVrshrQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x3:
            return decodeNeonUSTwoShiftReg<NVrsraD, NVrsraQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x4:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsriD, NVsriQ>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return new Unknown(machInst);
            }
          case 0x5:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsliD, NVsliQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            } else {
                return decodeNeonUTwoShiftReg<NVshlD, NVshlQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x6:
          case 0x7:
            if (u) {
                if (a == 0x6) {
                    return decodeNeonSTwoShiftReg<NVqshlusD, NVqshlusQ>(
                            b, size, machInst, vd, vm, lShiftAmt);
                } else {
                    return decodeNeonUTwoShiftReg<NVqshluD, NVqshluQ>(
                            b, size, machInst, vd, vm, lShiftAmt);
                }
            } else {
                return decodeNeonSTwoShiftReg<NVqshlD, NVqshlQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x8:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonSTwoShiftSReg<NVqshruns, NVqrshruns>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonUTwoShiftSReg<NVshrn, NVrshrn>(
                        b, size, machInst, vd, vm, rShiftAmt);
            }
          case 0x9:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonUTwoShiftSReg<NVqshrun, NVqrshrun>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonSTwoShiftSReg<NVqshrn, NVqrshrn>(
                        b, size, machInst, vd, vm, rShiftAmt);
            }
          case 0xa:
            if (l || b) {
                return new Unknown(machInst);
            } else {
                return decodeNeonUSTwoShiftSReg<NVmovl, NVshll>(
                        lShiftAmt, u, size, machInst, vd, vm, lShiftAmt);
            }
          case 0xe:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (b) {
                        return new NVcvtu2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvtu2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (b) {
                        return new NVcvts2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvts2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
          case 0xf:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (b) {
                        return new NVcvt2ufxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2ufxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (b) {
                        return new NVcvt2sfxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2sfxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonThreeRegDiffLengths(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 21, 20);
        switch (a) {
          case 0x0:
            return decodeNeonUSThreeUSReg<Vaddl>(
                    u, size, machInst, vd, vn, vm);
          case 0x1:
            return decodeNeonUSThreeUSReg<Vaddw>(
                    u, size, machInst, vd, vn, vm);
          case 0x2:
            return decodeNeonUSThreeUSReg<Vsubl>(
                    u, size, machInst, vd, vn, vm);
          case 0x3:
            return decodeNeonUSThreeUSReg<Vsubw>(
                    u, size, machInst, vd, vn, vm);
          case 0x4:
            if (u) {
                return decodeNeonUThreeUSReg<Vraddhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vaddhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x5:
            return decodeNeonUSThreeUSReg<Vabal>(
                    u, size, machInst, vd, vn, vm);
          case 0x6:
            if (u) {
                return decodeNeonUThreeUSReg<Vrsubhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vsubhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (bits(machInst, 23)) {
                return decodeNeonUSThreeUSReg<Vabdl>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VabdD, VabdQ>(
                        bits(machInst, 6), u, size, machInst, vd, vn, vm);
            }
          case 0x8:
            return decodeNeonUSThreeUSReg<Vmlal>(
                    u, size, machInst, vd, vn, vm);
          case 0xa:
            return decodeNeonUSThreeUSReg<Vmlsl>(
                    u, size, machInst, vd, vn, vm);
          case 0x9:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlal>(
                        size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlsl>(
                        size, machInst, vd, vn, vm);
            }
          case 0xc:
            return decodeNeonUSThreeUSReg<Vmull>(
                    u, size, machInst, vd, vn, vm);
          case 0xd:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmull>(
                        size, machInst, vd, vn, vm);
            }
          case 0xe:
            return decodeNeonUThreeUSReg<Vmullp>(
                    size, machInst, vd, vn, vm);
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegScalar(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const unsigned size = bits(machInst, 21, 20);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm = (size == 2) ?
            (IntRegIndex)(2 * bits(machInst, 3, 0)) :
            (IntRegIndex)(2 * bits(machInst, 2, 0));
        const unsigned index = (size == 2) ? (unsigned)bits(machInst, 5) :
            (bits(machInst, 3) | (bits(machInst, 5) << 1));
        switch (a) {
          case 0x0:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlasQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlasD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x1:
            if (u)
                return new VmlasQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlasDFp<float>(machInst, vd, vn, vm, index);
          case 0x4:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlssQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlssD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x5:
            if (u)
                return new VmlssQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlssDFp<float>(machInst, vd, vn, vm, index);
          case 0x2:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlals<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x6:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlsls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x3:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x7:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x8:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmulsQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmulsD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x9:
            if (u)
                return new VmulsQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmulsDFp<float>(machInst, vd, vn, vm, index);
          case 0xa:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmulls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmulls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                if (u) {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<uint16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<uint32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<int16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<int32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xc:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xd:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqrdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqrdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegMisc(ExtMachInst machInst)
    {
        const uint32_t a = bits(machInst, 17, 16);
        const uint32_t b = bits(machInst, 10, 6);
        const bool q = bits(machInst, 6);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 19, 18);
        switch (a) {
          case 0x0:
            switch (bits(b, 4, 1)) {
              case 0x0:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev64Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev64Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint16_t>(machInst, vd, vm);
                    }
                  case 2:
                    if (q) {
                        return new NVrev64Q<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint32_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x1:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev32Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev32Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint16_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x2:
                if (size != 0) {
                    return new Unknown(machInst);
                } else if (q) {
                    return new NVrev16Q<uint8_t>(machInst, vd, vm);
                } else {
                    return new NVrev16D<uint8_t>(machInst, vd, vm);
                }
              case 0x4:
                return decodeNeonSTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x5:
                return decodeNeonUTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x8:
                return decodeNeonSTwoMiscReg<NVclsD, NVclsQ>(
                        q, size, machInst, vd, vm);
              case 0x9:
                return decodeNeonSTwoMiscReg<NVclzD, NVclzQ>(
                        q, size, machInst, vd, vm);
              case 0xa:
                return decodeNeonUTwoMiscReg<NVcntD, NVcntQ>(
                        q, size, machInst, vd, vm);
              case 0xb:
                if (q)
                    return new NVmvnQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVmvnD<uint64_t>(machInst, vd, vm);
              case 0xc:
                return decodeNeonSTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xd:
                return decodeNeonUTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xe:
                return decodeNeonSTwoMiscReg<NVqabsD, NVqabsQ>(
                        q, size, machInst, vd, vm);
              case 0xf:
                return decodeNeonSTwoMiscReg<NVqnegD, NVqnegQ>(
                        q, size, machInst, vd, vm);
              default:
                return new Unknown(machInst);
            }
          case 0x1:
            switch (bits(b, 3, 1)) {
              case 0x0:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgtQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgtDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgtD, NVcgtQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x1:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgeD, NVcgeQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x2:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVceqQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVceqDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVceqD, NVceqQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x3:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcleQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcleDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcleD, NVcleQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x4:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcltQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcltDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcltD, NVcltQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x6:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVabsQFp<float>(machInst, vd, vm);
                    else
                        return new NVabsDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVabsD, NVabsQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x7:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVnegQFp<float>(machInst, vd, vm);
                    else
                        return new NVnegDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVnegD, NVnegQ>(
                            q, size, machInst, vd, vm);
                }
            }
          case 0x2:
            switch (bits(b, 4, 1)) {
              case 0x0:
                if (q)
                    return new NVswpQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVswpD<uint64_t>(machInst, vd, vm);
              case 0x1:
                return decodeNeonUTwoMiscSReg<NVtrnD, NVtrnQ>(
                        q, size, machInst, vd, vm);
              case 0x2:
                return decodeNeonUTwoMiscReg<NVuzpD, NVuzpQ>(
                        q, size, machInst, vd, vm);
              case 0x3:
                return decodeNeonUTwoMiscReg<NVzipD, NVzipQ>(
                        q, size, machInst, vd, vm);
              case 0x4:
                if (b == 0x8) {
                    return decodeNeonUTwoMiscUSReg<NVmovn>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovuns>(
                            size, machInst, vd, vm);
                }
              case 0x5:
                if (q) {
                    return decodeNeonUTwoMiscUSReg<NVqmovun>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovn>(
                            size, machInst, vd, vm);
                }
              case 0x6:
                if (b == 0xc) {
                    return decodeNeonSTwoShiftUSReg<NVshll>(
                            size, machInst, vd, vm, 8 << size);
                } else {
                    return new Unknown(machInst);
                }
              case 0xc:
              case 0xe:
                if (b == 0x18) {
                    if (size != 1 || (vm % 2))
                        return new Unknown(machInst);
                    return new NVcvts2h<uint16_t>(machInst, vd, vm);
                } else if (b == 0x1c) {
                    if (size != 1 || (vd % 2))
                        return new Unknown(machInst);
                    return new NVcvth2s<uint16_t>(machInst, vd, vm);
                } else {
                    return new Unknown(machInst);
                }
              default:
                return new Unknown(machInst);
            }
          case 0x3:
            if (bits(b, 4, 3) == 0x3) {
                if ((q && (vd % 2 || vm % 2)) || size != 2) {
                    return new Unknown(machInst);
                } else {
                    if (bits(b, 2)) {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvt2ufxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2ufxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvt2sfxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2sfxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    } else {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvtu2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvtu2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvts2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvts2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    }
                }
            } else if ((b & 0x1a) == 0x10) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrecpeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrecpeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrecpeQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrecpeD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else if ((b & 0x1a) == 0x12) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrsqrteQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrsqrteQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 23, 19);
        const uint32_t b = bits(machInst, 11, 8);
        const uint32_t c = bits(machInst, 7, 4);
        if (bits(a, 4) == 0) {
            return decodeNeonThreeRegistersSameLength(machInst);
        } else if ((c & 0x9) == 1) {
            if ((a & 0x7) == 0) {
                return decodeNeonOneRegModImm(machInst);
            } else {
                return decodeNeonTwoRegAndShift(machInst);
            }
        } else if ((c & 0x9) == 9) {
            return decodeNeonTwoRegAndShift(machInst);
        } else if (bits(a, 2, 1) != 0x3) {
            if ((c & 0x5) == 0) {
                return decodeNeonThreeRegDiffLengths(machInst);
            } else if ((c & 0x5) == 4) {
                return decodeNeonTwoRegScalar(machInst);
            }
        } else if ((a & 0x16) == 0x16) {
            const IntRegIndex vd =
                (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                                   (bits(machInst, 22) << 4)));
            const IntRegIndex vn =
                (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                                   (bits(machInst, 7) << 4)));
            const IntRegIndex vm =
                (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                                   (bits(machInst, 5) << 4)));
            if (!u) {
                if (bits(c, 0) == 0) {
                    unsigned imm4 = bits(machInst, 11, 8);
                    bool q = bits(machInst, 6);
                    if (imm4 >= 16 && !q)
                        return new Unknown(machInst);
                    if (q) {
                        return new NVextQ<uint8_t>(machInst, vd, vn, vm, imm4);
                    } else {
                        return new NVextD<uint8_t>(machInst, vd, vn, vm, imm4);
                    }
                }
            } else if (bits(b, 3) == 0 && bits(c, 0) == 0) {
                return decodeNeonTwoRegMisc(machInst);
            } else if (bits(b, 3, 2) == 0x2 && bits(c, 0) == 0) {
                unsigned length = bits(machInst, 9, 8) + 1;
                if ((uint32_t)vn / 2 + length > 32)
                    return new Unknown(machInst);
                if (bits(machInst, 6) == 0) {
                    switch (length) {
                      case 1:
                        return new NVtbl1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbl2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbl3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbl4(machInst, vd, vn, vm);
                    }
                } else {
                    switch (length) {
                      case 1:
                        return new NVtbx1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbx2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbx3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbx4(machInst, vd, vn, vm);
                    }
                }
            } else if (b == 0xc && (c & 0x9) == 0) {
                unsigned imm4 = bits(machInst, 19, 16);
                if (bits(imm4, 2, 0) == 0)
                    return new Unknown(machInst);
                unsigned size = 0;
                while ((imm4 & 0x1) == 0) {
                    size++;
                    imm4 >>= 1;
                }
                unsigned index = imm4 >> 1;
                const bool q = bits(machInst, 6);
                return decodeNeonUTwoShiftSReg<NVdupD, NVdupQ>(
                        q, size, machInst, vd, vm, index);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst)
    {
        const uint32_t opcode = bits(machInst, 24, 20);
        const uint32_t offset = bits(machInst, 7, 0);
        const bool single = (bits(machInst, 8) == 0);
        const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
        RegIndex vd;
        if (single) {
            vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                      bits(machInst, 22));
        } else {
            vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                      (bits(machInst, 22) << 5));
        }
        switch (bits(opcode, 4, 3)) {
          case 0x0:
            if (bits(opcode, 4, 1) == 0x2 &&
                    !(machInst.thumb == 1 && bits(machInst, 28) == 1) &&
                    !(machInst.thumb == 0 && machInst.condCode == 0xf)) {
                if ((bits(machInst, 7, 4) & 0xd) != 1) {
                    break;
                }
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                const IntRegIndex rt2 =
                    (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                const bool op = bits(machInst, 20);
                uint32_t vm;
                if (single) {
                    vm = (bits(machInst, 3, 0) << 1) | bits(machInst, 5);
                } else {
                    vm = (bits(machInst, 3, 0) << 1) |
                         (bits(machInst, 5) << 5);
                }
                if (op) {
                    return new Vmov2Core2Reg(machInst, rt, rt2,
                                             (IntRegIndex)vm);
                } else {
                    return new Vmov2Reg2Core(machInst, (IntRegIndex)vm,
                                             rt, rt2);
                }
            }
            break;
          case 0x1:
            {
                if (offset == 0 || vd + offset/2 > NumFloatV7ArchRegs) {
                    break;
                }
                switch (bits(opcode, 1, 0)) {
                  case 0x0:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, false, offset);
                  case 0x1:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, true, offset);
                  case 0x2:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, false, offset);
                  case 0x3:
                    // If rn == sp, then this is called vpop.
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, true, offset);
                }
            }
          case 0x2:
            if (bits(opcode, 1, 0) == 0x2) {
                // If rn == sp, then this is called vpush.
                return new VLdmStm(machInst, rn, vd, single,
                                   false, true, false, offset);
            } else if (bits(opcode, 1, 0) == 0x3) {
                return new VLdmStm(machInst, rn, vd, single,
                                   false, true, true, offset);
            }
            // Fall through on purpose
          case 0x3:
            const bool up = (bits(machInst, 23) == 1);
            const uint32_t imm = bits(machInst, 7, 0) << 2;
            if (single) {
                vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                          (bits(machInst, 22)));
            } else {
                vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                          (bits(machInst, 22) << 5));
            }
            if (bits(opcode, 1, 0) == 0x0) {
                if (single) {
                    if (up) {
                        return new VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            } else if (bits(opcode, 1, 0) == 0x1) {
                if (single) {
                    if (up) {
                        return new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst)
    {
        const uint32_t l = bits(machInst, 20);
        const uint32_t c = bits(machInst, 8);
        const uint32_t a = bits(machInst, 23, 21);
        const uint32_t b = bits(machInst, 6, 5);
        if ((machInst.thumb == 1 && bits(machInst, 28) == 1) ||
            (machInst.thumb == 0 && machInst.condCode == 0xf)) {
            return new Unknown(machInst);
        }
        if (l == 0 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (IntRegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vn, rt);
                }
            } else if (a == 0x7) {
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t reg = bits(machInst, 19, 16);
                uint32_t specReg;
                switch (reg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (specReg == MISCREG_FPSCR) {
                    return new VmsrFpscr(machInst, (IntRegIndex)specReg, rt);
                } else {
                    uint32_t iss = mcrMrcIssBuild(0, bits(machInst, 3, 0), rt,
                        reg, a, bits(machInst, 7, 5));
                    return new Vmsr(machInst, (IntRegIndex)specReg, rt, iss);
                }
            }
        } else if (l == 0 && c == 1) {
            if (bits(a, 2) == 0) {
                uint32_t vd = (bits(machInst, 7) << 5) |
                              (bits(machInst, 19, 16) << 1);
                // Handle accessing each single precision half of the vector.
                vd += bits(machInst, 21);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 22) == 1) {
                    return new VmovCoreRegB(machInst, (IntRegIndex)vd,
                                            rt, bits(machInst, 6, 5));
                } else if (bits(machInst, 5) == 1) {
                    return new VmovCoreRegH(machInst, (IntRegIndex)vd,
                                            rt, bits(machInst, 6));
                } else if (bits(machInst, 6) == 0) {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vd, rt);
                } else {
                    return new Unknown(machInst);
                }
            } else if (bits(b, 1) == 0) {
                bool q = bits(machInst, 21);
                unsigned be = (bits(machInst, 22) << 1) | (bits(machInst, 5));
                IntRegIndex vd = (IntRegIndex)(2 * (uint32_t)
                    (bits(machInst, 19, 16) | (bits(machInst, 7) << 4)));
                IntRegIndex rt = (IntRegIndex)(uint32_t)
                    bits(machInst, 15, 12);
                if (q) {
                    switch (be) {
                      case 0:
                        return new NVdupQGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupQGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupQGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (be) {
                      case 0:
                        return new NVdupDGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupDGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupDGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                }
            }
        } else if (l == 1 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (IntRegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vn, rt);
                }
            } else if (a == 7) {
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t reg = bits(machInst, 19, 16);
                uint32_t specReg;
                switch (reg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (rt == 0xf) {
                    if (specReg == MISCREG_FPSCR) {
                        return new VmrsApsrFpscr(machInst);
                    } else {
                        return new Unknown(machInst);
                    }
                } else if (specReg == MISCREG_FPSCR) {
                    return new VmrsFpscr(machInst, rt, (IntRegIndex)specReg);
                } else {
                    uint32_t iss = mcrMrcIssBuild(l, bits(machInst, 3, 0), rt,
                        reg, a, bits(machInst, 7, 5));
                    return new Vmrs(machInst, rt, (IntRegIndex)specReg, iss);
                }
            }
        } else {
            uint32_t vd = (bits(machInst, 7) << 5) |
                          (bits(machInst, 19, 16) << 1);
            // Handle indexing into each single precision half of the vector.
            vd += bits(machInst, 21);
            uint32_t index;
            const IntRegIndex rt =
                (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
            const bool u = (bits(machInst, 23) == 1);
            if (bits(machInst, 22) == 1) {
                index = bits(machInst, 6, 5);
                if (u) {
                    return new VmovRegCoreUB(machInst, rt,
                                             (IntRegIndex)vd, index);
                } else {
                    return new VmovRegCoreSB(machInst, rt,
                                             (IntRegIndex)vd, index);
                }
            } else if (bits(machInst, 5) == 1) {
                index = bits(machInst, 6);
                if (u) {
                    return new VmovRegCoreUH(machInst, rt,
                                             (IntRegIndex)vd, index);
                } else {
                    return new VmovRegCoreSH(machInst, rt,
                                             (IntRegIndex)vd, index);
                }
            } else if (bits(machInst, 6) == 0 && !u) {
                return new VmovRegCoreW(machInst, rt, (IntRegIndex)vd);
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 20);
        const uint32_t opc2 = bits(machInst, 19, 16);
        const uint32_t opc3 = bits(machInst, 7, 6);
        //const uint32_t opc4 = bits(machInst, 3, 0);
        const bool single = (bits(machInst, 8) == 0);
        // Used to select between vcmp and vcmpe.
        const bool e = (bits(machInst, 7) == 1);
        IntRegIndex vd;
        IntRegIndex vm;
        IntRegIndex vn;
        if (single) {
            vd = (IntRegIndex)(bits(machInst, 22) |
                    (bits(machInst, 15, 12) << 1));
            vm = (IntRegIndex)(bits(machInst, 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (IntRegIndex)(bits(machInst, 7) |
                    (bits(machInst, 19, 16) << 1));
        } else {
            vd = (IntRegIndex)((bits(machInst, 22) << 5) |
                    (bits(machInst, 15, 12) << 1));
            vm = (IntRegIndex)((bits(machInst, 5) << 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (IntRegIndex)((bits(machInst, 7) << 5) |
                    (bits(machInst, 19, 16) << 1));
        }
        switch (opc1 & 0xb /* 1011 */) {
          case 0x0:
            if (bits(machInst, 6) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x1:
            if (bits(machInst, 6) == 1) {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x2:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmulD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmulD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x3:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VaddS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VaddD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VsubS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VsubD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x8:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VdivS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VdivD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0x9:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VfnmaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfnmaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VfnmsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfnmsD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0xa:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VfmaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfmaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VfmsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VfmsD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0xb:
            if ((opc3 & 0x1) == 0) {
                const uint32_t baseImm =
                    bits(machInst, 3, 0) | (bits(machInst, 19, 16) << 4);
                if (single) {
                    uint32_t imm = vfp_modified_imm(baseImm, false);
                    return decodeVfpRegImmOp<VmovImmS>(
                            machInst, vd, imm, false);
                } else {
                    uint64_t imm = vfp_modified_imm(baseImm, true);
                    return decodeVfpRegImmOp<VmovImmD>(
                            machInst, vd, imm, true);
                }
            }
            switch (opc2) {
              case 0x0:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VmovRegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VmovRegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VabsS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VabsD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x1:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VnegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VnegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VsqrtS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VsqrtD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x2:
              case 0x3:
                {
                    const bool toHalf = bits(machInst, 16);
                    const bool top = bits(machInst, 7);
                    if (top) {
                        if (toHalf) {
                            return new VcvtFpSFpHT(machInst, vd, vm);
                        } else {
                            return new VcvtFpHTFpS(machInst, vd, vm);
                        }
                    } else {
                        if (toHalf) {
                            return new VcvtFpSFpHB(machInst, vd, vm);
                        } else {
                            return new VcvtFpHBFpS(machInst, vd, vm);
                        }
                    }
                }
              case 0x4:
                if (single) {
                    if (e) {
                        return new VcmpeS(machInst, vd, vm);
                    } else {
                        return new VcmpS(machInst, vd, vm);
                    }
                } else {
                    if (e) {
                        return new VcmpeD(machInst, vd, vm);
                    } else {
                        return new VcmpD(machInst, vd, vm);
                    }
                }
              case 0x5:
                if (single) {
                    if (e) {
                        return new VcmpeZeroS(machInst, vd, 0);
                    } else {
                        return new VcmpZeroS(machInst, vd, 0);
                    }
                } else {
                    if (e) {
                        return new VcmpeZeroD(machInst, vd, 0);
                    } else {
                        return new VcmpZeroD(machInst, vd, 0);
                    }
                }
              case 0x7:
                if (opc3 == 0x3) {
                    if (single) {
                        vd = (IntRegIndex)((bits(machInst, 22) << 5) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSFpD(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpDFpS(machInst, vd, vm);
                    }
                }
                break;
              case 0x8:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtUIntFpS(machInst, vd, vm);
                    } else {
                        vm = (IntRegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtUIntFpD(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtSIntFpS(machInst, vd, vm);
                    } else {
                        vm = (IntRegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtSIntFpD(machInst, vd, vm);
                    }
                }
              case 0xa:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtSHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtSHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xb:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtUHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtUHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xc:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpUIntSR(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpUIntS(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntD(machInst, vd, vm);
                    }
                }
              case 0xd:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpSIntSR(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpSIntS(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntD(machInst, vd, vm);
                    }
                }
              case 0xe:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpSHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpSHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xf:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpUHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpUHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedD(machInst, vd, vd, size);
                        }
                    }
                }
            }
            break;
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex miscReg = decodeCP14Reg(crn, opc1, crm, opc2);
        const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool isRead = bits(machInst, 20);
        switch (miscReg) {
          case MISCREG_NOP:
            return new NopInst(machInst);
          case MISCREG_CP14_UNIMPL:
            return new FailUnimplemented(isRead ? "mrc unknown" : "mcr unknown",
                    machInst,
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, isRead ? "read" : "write"));
          default:
            uint32_t iss = mcrMrcIssBuild(isRead, crm, rt, crn, opc1, opc2);
            if (isRead) {
                return new Mrc14(machInst, rt, (IntRegIndex)miscReg, iss);
            } else {
                return new Mcr14(machInst, (IntRegIndex)miscReg, rt, iss);
            }
        }
    }
    
    StaticInstPtr
    decodeMcrMrc15(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex miscReg = decodeCP15Reg(crn, opc1, crm, opc2);
        const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool isRead = bits(machInst, 20);
        uint32_t iss = mcrMrcIssBuild(isRead, crm, rt, crn, opc1, opc2);
        switch (miscReg) {
          case MISCREG_NOP:
            return new NopInst(machInst);
          case MISCREG_CP15_UNIMPL:
            return new FailUnimplemented(isRead ? "mrc unkown" : "mcr unkown",
                    machInst,
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, isRead ? "read" : "write"));
          case MISCREG_DCCMVAC:
            return new FlushPipeInst(
                    isRead ? "mrc dccmvac" : "mcr dccmvac", machInst);
          case MISCREG_CP15ISB:
            return new Isb(machInst, iss);
          case MISCREG_CP15DSB:
            return new Dsb(machInst, iss);
          case MISCREG_CP15DMB:
            return new Dmb(machInst, iss);
          default:
            if (miscRegInfo[miscReg][MISCREG_WARN_NOT_FAIL]) {
                std::string full_mnem = csprintf("%s %s",
                    isRead ? "mrc" : "mcr", miscRegName[miscReg]);
                warn("\tinstruction '%s' unimplemented\n", full_mnem);
                // Remove the warn flag and set the implemented flag. This
                // prevents the instruction warning a second time, it also
                // means the instruction is actually generated. Actually
                // creating the instruction to access an register that isn't
                // implemented sounds a bit silly, but its required to get
                // the correct behaviour for hyp traps and undef exceptions.
                miscRegInfo[miscReg][MISCREG_IMPLEMENTED]   = true;
                miscRegInfo[miscReg][MISCREG_WARN_NOT_FAIL] = false;
            }
            if (miscRegInfo[miscReg][MISCREG_IMPLEMENTED]) {
                if (isRead)
                    return new Mrc15(machInst, rt, miscReg, iss);
                return new Mcr15(machInst, miscReg, rt, iss);
            } else {
                return new FailUnimplemented(isRead ? "mrc" : "mcr", machInst,
                    csprintf("%s %s", isRead ? "mrc" : "mcr",
                        miscRegName[miscReg]));
            }
        }
    }
    
    StaticInstPtr
    decodeMcrrMrrc15(ExtMachInst machInst)
    {
        const uint32_t crm = bits(machInst, 3, 0);
        const uint32_t opc1 = bits(machInst, 7, 4);
        const MiscRegIndex miscReg = decodeCP15Reg64(crm, opc1);
        const IntRegIndex rt = (IntRegIndex) (uint32_t) bits(machInst, 15, 12);
        const IntRegIndex rt2 = (IntRegIndex) (uint32_t) bits(machInst, 19, 16);
        const bool isRead = bits(machInst, 20);
        switch (miscReg) {
          case MISCREG_CP15_UNIMPL:
            return new FailUnimplemented(isRead ? "mrc" : "mcr", machInst,
                    csprintf("miscreg crm:%d opc1:%d 64-bit %s unknown",
                    crm, opc1, isRead ? "read" : "write"));
          default:
            if (miscRegInfo[miscReg][MISCREG_WARN_NOT_FAIL]) {
                std::string full_mnem = csprintf("%s %s",
                    isRead ? "mrrc" : "mcrr", miscRegName[miscReg]);
                warn("\tinstruction '%s' unimplemented\n", full_mnem);
                // Remove the warn flag and set the implemented flag. This
                // prevents the instruction warning a second time, it also
                // means the instruction is actually generated. Actually
                // creating the instruction to access an register that isn't
                // implemented sounds a bit silly, but its required to get
                // the correct behaviour for hyp traps and undef exceptions.
                miscRegInfo[miscReg][MISCREG_IMPLEMENTED]   = true;
                miscRegInfo[miscReg][MISCREG_WARN_NOT_FAIL] = false;
            }
            if (miscRegInfo[miscReg][MISCREG_IMPLEMENTED]) {
                uint32_t iss = mcrrMrrcIssBuild(isRead, crm, rt, rt2, opc1);
                if (isRead) {
                    StaticInstPtr si =  new Mrrc15(machInst, miscReg, rt2, rt, iss);
                    if (miscRegInfo[miscReg][MISCREG_UNVERIFIABLE])
                        si->setFlag(StaticInst::IsUnverifiable);
                    return si;
                }
                return new Mcrr15(machInst, rt2, rt, miscReg, iss);
            } else {
                return new FailUnimplemented(isRead ? "mrrc" : "mcrr", machInst,
                    csprintf("%s %s",
                    isRead ? "mrrc" : "mcrr", miscRegName[miscReg]));
            }
        }
    }
    
    std::string
    Breakpoint::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s (inst 0x%x)", "Breakpoint", machInst);
    }

// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// ArmERet::armERet(([], {}))

// Breakpoint::bkpt(([], {}))

// ArmSmcHyp::armSmcHyp(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Mcrr15::Mcrr15(([], {}))

// Mrrc15::Mrrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Aarch64::aarch64(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// Mcrr15::Mcrr15(([], {}))

// WarnUnimpl::mcrr(([], {}))

// Mrrc15::Mrrc15(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// DecoderFault::decoderFault(([], {}))

#endif
