// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   arm/isa/main.isa

#undef DECODERFAULT
#define DECODERFAULT	machInst.decoderFault
#undef ENCODING
#define ENCODING	machInst.encoding
#undef OPCODE
#define OPCODE	machInst.opcode
#undef MEDIA_OPCODE
#define MEDIA_OPCODE	machInst.mediaOpcode
#undef MEDIA_OPCODE2
#define MEDIA_OPCODE2	machInst.mediaOpcode2
#undef USEIMM
#define USEIMM	machInst.useImm
#undef OPCODE_24
#define OPCODE_24	machInst.opcode24
#undef OPCODE_24_23
#define OPCODE_24_23	machInst.opcode24_23
#undef OPCODE_23_20
#define OPCODE_23_20	machInst.opcode23_20
#undef OPCODE_23_21
#define OPCODE_23_21	machInst.opcode23_21
#undef OPCODE_22
#define OPCODE_22	machInst.opcode22
#undef OPCODE_20
#define OPCODE_20	machInst.opcode20
#undef OPCODE_19_16
#define OPCODE_19_16	machInst.opcode19_16
#undef OPCODE_19
#define OPCODE_19	machInst.opcode19
#undef OPCODE_18
#define OPCODE_18	machInst.opcode18
#undef OPCODE_15_12
#define OPCODE_15_12	machInst.opcode15_12
#undef OPCODE_15
#define OPCODE_15	machInst.opcode15
#undef MISC_OPCODE
#define MISC_OPCODE	machInst.miscOpcode
#undef OPC2
#define OPC2	machInst.opc2
#undef OPCODE_7
#define OPCODE_7	machInst.opcode7
#undef OPCODE_6
#define OPCODE_6	machInst.opcode6
#undef OPCODE_4
#define OPCODE_4	machInst.opcode4
#undef IS_MISC
#define IS_MISC	machInst.isMisc
#undef SEVEN_AND_FOUR
#define SEVEN_AND_FOUR	machInst.sevenAndFour
#undef THUMB
#define THUMB	machInst.thumb
#undef BIGTHUMB
#define BIGTHUMB	machInst.bigThumb
#undef AARCH64
#define AARCH64	machInst.aarch64
#undef COND_CODE
#define COND_CODE	machInst.condCode
#undef S_FIELD
#define S_FIELD	machInst.sField
#undef RN
#define RN	machInst.rn
#undef RD
#define RD	machInst.rd
#undef RT
#define RT	machInst.rt
#undef SHIFT_SIZE
#define SHIFT_SIZE	machInst.shiftSize
#undef SHIFT
#define SHIFT	machInst.shift
#undef RM
#define RM	machInst.rm
#undef RS
#define RS	machInst.rs
#undef PUSWL
#define PUSWL	machInst.puswl
#undef PREPOST
#define PREPOST	machInst.puswl.prepost
#undef UP
#define UP	machInst.puswl.up
#undef PSRUSER
#define PSRUSER	machInst.puswl.psruser
#undef WRITEBACK
#define WRITEBACK	machInst.puswl.writeback
#undef LOADOP
#define LOADOP	machInst.puswl.loadOp
#undef PUBWL
#define PUBWL	machInst.pubwl
#undef IMM
#define IMM	machInst.imm
#undef IMMED_11_0
#define IMMED_11_0	machInst.immed11_0
#undef IMMED_7_0
#define IMMED_7_0	machInst.immed7_0
#undef IMMED_HI_11_8
#define IMMED_HI_11_8	machInst.immedHi11_8
#undef IMMED_LO_3_0
#define IMMED_LO_3_0	machInst.immedLo3_0
#undef IMMED_23_0
#define IMMED_23_0	machInst.immed23_0
#undef CPNUM
#define CPNUM	machInst.cpNum
#undef FN
#define FN	machInst.fn
#undef FD
#define FD	machInst.fd
#undef FPREGIMM
#define FPREGIMM	machInst.fpRegImm
#undef FM
#define FM	machInst.fm
#undef FPIMM
#define FPIMM	machInst.fpImm
#undef PUNWL
#define PUNWL	machInst.punwl
#undef M5FUNC
#define M5FUNC	machInst.m5Func
#undef TOPCODE_15_13
#define TOPCODE_15_13	machInst.topcode15_13
#undef TOPCODE_13_11
#define TOPCODE_13_11	machInst.topcode13_11
#undef TOPCODE_12_11
#define TOPCODE_12_11	machInst.topcode12_11
#undef TOPCODE_12_10
#define TOPCODE_12_10	machInst.topcode12_10
#undef TOPCODE_11_9
#define TOPCODE_11_9	machInst.topcode11_9
#undef TOPCODE_11_8
#define TOPCODE_11_8	machInst.topcode11_8
#undef TOPCODE_10_9
#define TOPCODE_10_9	machInst.topcode10_9
#undef TOPCODE_10_8
#define TOPCODE_10_8	machInst.topcode10_8
#undef TOPCODE_9_6
#define TOPCODE_9_6	machInst.topcode9_6
#undef TOPCODE_7
#define TOPCODE_7	machInst.topcode7
#undef TOPCODE_7_6
#define TOPCODE_7_6	machInst.topcode7_6
#undef TOPCODE_7_5
#define TOPCODE_7_5	machInst.topcode7_5
#undef TOPCODE_7_4
#define TOPCODE_7_4	machInst.topcode7_4
#undef TOPCODE_3_0
#define TOPCODE_3_0	machInst.topcode3_0
#undef HTOPCODE_12_11
#define HTOPCODE_12_11	machInst.htopcode12_11
#undef HTOPCODE_10_9
#define HTOPCODE_10_9	machInst.htopcode10_9
#undef HTOPCODE_9
#define HTOPCODE_9	machInst.htopcode9
#undef HTOPCODE_9_8
#define HTOPCODE_9_8	machInst.htopcode9_8
#undef HTOPCODE_9_5
#define HTOPCODE_9_5	machInst.htopcode9_5
#undef HTOPCODE_9_4
#define HTOPCODE_9_4	machInst.htopcode9_4
#undef HTOPCODE_8
#define HTOPCODE_8	machInst.htopcode8
#undef HTOPCODE_8_7
#define HTOPCODE_8_7	machInst.htopcode8_7
#undef HTOPCODE_8_6
#define HTOPCODE_8_6	machInst.htopcode8_6
#undef HTOPCODE_8_5
#define HTOPCODE_8_5	machInst.htopcode8_5
#undef HTOPCODE_7
#define HTOPCODE_7	machInst.htopcode7
#undef HTOPCODE_7_5
#define HTOPCODE_7_5	machInst.htopcode7_5
#undef HTOPCODE_6
#define HTOPCODE_6	machInst.htopcode6
#undef HTOPCODE_6_5
#define HTOPCODE_6_5	machInst.htopcode6_5
#undef HTOPCODE_5_4
#define HTOPCODE_5_4	machInst.htopcode5_4
#undef HTOPCODE_4
#define HTOPCODE_4	machInst.htopcode4
#undef HTRN
#define HTRN	machInst.htrn
#undef HTS
#define HTS	machInst.hts
#undef LTOPCODE_15
#define LTOPCODE_15	machInst.ltopcode15
#undef LTOPCODE_11_8
#define LTOPCODE_11_8	machInst.ltopcode11_8
#undef LTOPCODE_7_6
#define LTOPCODE_7_6	machInst.ltopcode7_6
#undef LTOPCODE_7_4
#define LTOPCODE_7_4	machInst.ltopcode7_4
#undef LTOPCODE_4
#define LTOPCODE_4	machInst.ltopcode4
#undef LTRD
#define LTRD	machInst.ltrd
#undef LTCOPROC
#define LTCOPROC	machInst.ltcoproc

    template <class T>
    // Implement a less-than-zero function: ltz()
    // this function exists because some versions of GCC complain when a
    // comparison is done between a unsigned variable and 0 and for GCC 4.2
    // there is no way to disable this warning
    inline bool ltz(T t);

    template <>
    inline bool ltz(uint8_t) { return false; }
    template <>
    inline bool ltz(uint16_t) { return false; }
    template <>
    inline bool ltz(uint32_t) { return false; }
    template <>
    inline bool ltz(uint64_t) { return false; }
    template <>
    inline bool ltz(int8_t v) { return v < 0; }
    template <>
    inline bool ltz(int16_t v) { return v < 0; }
    template <>
    inline bool ltz(int32_t v) { return v < 0; }
    template <>
    inline bool ltz(int64_t v) { return v < 0; }

        template <typename T>
            struct bigger_type_t;

        template<> struct bigger_type_t<uint8_t> { typedef uint16_t type; };
        template<> struct bigger_type_t<uint16_t> { typedef uint32_t type; };
        template<> struct bigger_type_t<uint32_t> { typedef uint64_t type; };

        template<> struct bigger_type_t<int8_t> { typedef int16_t type; };
        template<> struct bigger_type_t<int16_t> { typedef int32_t type; };
        template<> struct bigger_type_t<int32_t> { typedef int64_t type; };

class Movz : public RegImmImmOp
{
  protected:
    public:
        // Constructor
        Movz(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Movk : public RegImmImmOp
{
  protected:
    public:
        // Constructor
        Movk(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Movn : public RegImmImmOp
{
  protected:
    public:
        // Constructor
        Movn(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, true);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrex".
     */
    class LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexh".
     */
    class LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexb".
     */
    class LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "ldrexd".
     */
    class LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class LDRB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRB64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRB64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRB64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRB64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRB64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRB64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRB64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRB64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRB64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRB64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSBW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSBW64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSBW64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSBW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSBW64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBW64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSBW64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSBW64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSBW64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSBX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSBX64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSBX64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSBX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSBX64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSBX64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSBX64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSBX64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSBX64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRH64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRH64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRH64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRH64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRH64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRH64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRH64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRH64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRH64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRH64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSHW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSHW64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSHW64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSHW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSHW64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHW64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSHW64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSHW64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSHW64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSHX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSHX64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSHX64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSHX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSHX64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSHX64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSHX64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSHX64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSHX64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSW64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSW64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSW64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSW64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSW64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSW64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSW64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSW64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRW64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRW64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRW64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRW64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRW64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRW64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRW64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRW64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRX64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRX64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRX64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRX64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRX64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRX64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRX64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRX64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRBFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRBFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRBFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRBFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRBFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRBFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRBFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRBFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRBFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRBFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRBFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRBFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRHFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRHFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRHFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRHFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRHFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRHFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRHFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRHFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRHFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRHFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRHFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRHFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRSFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRSFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRSFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRSFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRSFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRSFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRSFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDRDFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRDFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRDFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        LDRDFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRDFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRDFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRDFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        LDRDFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class LDRDFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        LDRDFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        PRFM64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        PRFM64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFM64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        PRFM64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class PRFUM64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        PRFUM64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURSBW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSBW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURSBX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSBX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURSHW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSHW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURSHX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSHX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURSW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDURBFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURBFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURHFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURHFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURSFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURSFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDURDFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDURDFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDTRB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRSBW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRSBW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRSBX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRSBX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRSHW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRSHW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRSHX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRSHX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRSW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRSW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDTRX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        LDTRX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSWL64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        LDRSWL64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, true);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRWL64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        LDRWL64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRXL64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        LDRXL64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class LDRSFP64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        LDRSFP64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDRDFP64_LIT : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        LDRDFP64_LIT(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDARX64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        LDARX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class LDARW64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        LDARW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class LDARH64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        LDARH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class LDARB64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        LDARB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class LDAXRX64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDAXRX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRW64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDAXRW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRH64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDAXRH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXRB64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDAXRB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRX64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDXRX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRW64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDXRW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRH64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDXRH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXRB64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        LDXRB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdPairUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroLdPairUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdPairFp8Uop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroLdPairFp8Uop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16Uop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroLdFp16Uop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16RegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroLdFp16RegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXPW64 : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        LDAXPW64(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDAXPX64 : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        LDAXPX64(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXPW64 : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        LDXPW64(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class LDXPX64 : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        LDXPX64(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroLdrXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroLdrXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrXLitUop : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        MicroLdrXLitUop(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroLdrFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroLdrFpXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrFpXLitUop : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        MicroLdrFpXLitUop(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdFp16LitUop : public ArmISA::MemoryLiteral64
    {
      public:

        /// Constructor.
        MicroLdFp16LitUop(ExtMachInst machInst, IntRegIndex _dest, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDUXImmUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroLdrDUXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDSXImmUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroLdrDSXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroLdrDFpXImmUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroLdrDFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

class Svc : public ImmOp
{
  protected:
    public:
        // Constructor
        Svc(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "smc".
         */
        class Smc : public PredOp
        {
          public:
                /// Constructor.
                Smc(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Hvc : public ImmOp
{
  protected:
    public:
        // Constructor
        Hvc(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "eret".
         */
        class Eret : public PredOp
        {
          public:
                /// Constructor.
                Eret(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class MrsCpsr : public MrsOp
{
  protected:
    public:
        // Constructor
        MrsCpsr(ExtMachInst machInst, IntRegIndex _dest);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MrsSpsr : public MrsOp
{
  protected:
    public:
        // Constructor
        MrsSpsr(ExtMachInst machInst, IntRegIndex _dest);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MrsBankedReg : public MrsOp
{
  protected:
    uint8_t byteMask;
    bool    r;

  public:
        // Constructor
        MrsBankedReg(ExtMachInst machInst, IntRegIndex _dest,
                       uint8_t _sysM, bool _r);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrBankedReg : public MsrRegOp
{
  protected:
    bool r;

  public:
        // Constructor
        MsrBankedReg(ExtMachInst machInst, IntRegIndex _op1,
                       uint8_t _sysM, bool _r);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrCpsrReg : public MsrRegOp
{
  protected:
    public:
        // Constructor
        MsrCpsrReg(ExtMachInst machInst, IntRegIndex _op1, uint8_t mask);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrSpsrReg : public MsrRegOp
{
  protected:
    public:
        // Constructor
        MsrSpsrReg(ExtMachInst machInst, IntRegIndex _op1, uint8_t mask);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrCpsrImm : public MsrImmOp
{
  protected:
    public:
        // Constructor
        MsrCpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrSpsrImm : public MsrImmOp
{
  protected:
    public:
        // Constructor
        MsrSpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rev : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rev(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rev16 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rev16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Revsh : public RegRegOp
{
  protected:
    public:
        // Constructor
        Revsh(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rbit : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rbit(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Clz : public RegRegOp
{
  protected:
    public:
        // Constructor
        Clz(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ssat : public RegImmRegShiftOp
{
  protected:
    public:
        // Constructor
        Ssat(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usat : public RegImmRegShiftOp
{
  protected:
    public:
        // Constructor
        Usat(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ssat16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Ssat16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usat16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Usat16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxtb : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxtb(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxtab : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtab(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxtb16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxtb16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxtab16 : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtab16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxth : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxth(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sxtah : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtah(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxtb : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxtb(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxtab : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtab(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxtb16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxtb16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxtab16 : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtab16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxth : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxth(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uxtah : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtah(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sel : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Sel(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usad8 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Usad8(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usada8 : public RegRegRegRegOp
{
  protected:
    public:
        // Constructor
        Usada8(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "bkpt".
         */
        class BkptInst : public PredOp
        {
          public:
                /// Constructor.
                BkptInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "nop".
         */
        class NopInst : public ArmStaticInst
        {
          public:
                /// Constructor.
                NopInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "yield".
         */
        class YieldInst : public PredOp
        {
          public:
                /// Constructor.
                YieldInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wfe".
         */
        class WfeInst : public PredOp
        {
          public:
                /// Constructor.
                WfeInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wfi".
         */
        class WfiInst : public PredOp
        {
          public:
                /// Constructor.
                WfiInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "sev".
         */
        class SevInst : public PredOp
        {
          public:
                /// Constructor.
                SevInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "sevl".
         */
        class SevlInst : public PredOp
        {
          public:
                /// Constructor.
                SevlInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "it".
         */
        class ItInst : public PredOp
        {
          public:
                /// Constructor.
                ItInst(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "unknown".
         */
        class Unknown : public UnknownOp
        {
          public:
                /// Constructor.
                Unknown(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Ubfx : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Ubfx(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sbfx : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Sbfx(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Bfc : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Bfc(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Bfi : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Bfi(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mrc14 : public RegRegImmOp
{
  protected:
    public:
        // Constructor
        Mrc14(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mcr14 : public RegRegImmOp
{
  protected:
    public:
        // Constructor
        Mcr14(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mrc15 : public RegMiscRegImmOp
{
  protected:
    public:
        // Constructor
        Mrc15(ExtMachInst machInst,
                       IntRegIndex _dest, MiscRegIndex _op1,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mcr15 : public MiscRegRegImmOp
{
  protected:
    public:
        // Constructor
        Mcr15(ExtMachInst machInst,
                       MiscRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mrrc15 : public MrrcOp
{
  protected:
    public:
        // Constructor
        Mrrc15(ExtMachInst machInst, MiscRegIndex _op1,
                       IntRegIndex _dest, IntRegIndex _dest2, uint32_t imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mcrr15 : public McrrOp
{
  protected:
    public:
        // Constructor
        Mcrr15(ExtMachInst machInst, IntRegIndex _op1, IntRegIndex _op2,
                       MiscRegIndex _dest, uint32_t imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "enterx".
         */
        class Enterx : public PredOp
        {
          public:
                /// Constructor.
                Enterx(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "leavex".
         */
        class Leavex : public PredOp
        {
          public:
                /// Constructor.
                Leavex(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Setend : public ImmOp
{
  protected:
    public:
        // Constructor
        Setend(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "clrex".
         */
        class Clrex : public PredOp
        {
          public:
                /// Constructor.
                Clrex(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Isb : public ImmOp
{
  protected:
    public:
        // Constructor
        Isb(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Dsb : public ImmOp
{
  protected:
    public:
        // Constructor
        Dsb(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Dmb : public ImmOp
{
  protected:
    public:
        // Constructor
        Dmb(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "dbg".
         */
        class Dbg : public PredOp
        {
          public:
                /// Constructor.
                Dbg(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Cps : public ImmOp
{
  protected:
    public:
        // Constructor
        Cps(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "svc".
         */
        class Svc64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Svc64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "smc".
         */
        class Smc64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Smc64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Bfm64 : public RegRegImmImmOp64
{
  protected:
    public:
        // Constructor
        Bfm64(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ubfm64 : public RegRegImmImmOp64
{
  protected:
    public:
        // Constructor
        Ubfm64(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sbfm64 : public RegRegImmImmOp64
{
  protected:
    public:
        // Constructor
        Sbfm64(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Extr64 : public RegRegRegImmOp64
{
  protected:
    public:
        // Constructor
        Extr64(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       IntRegIndex _op2, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "unknown".
         */
        class Unknown64 : public UnknownOp64
        {
          public:
                /// Constructor.
                Unknown64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "isb".
         */
        class Isb64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Isb64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dsb".
         */
        class Dsb64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Dsb64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dmb".
         */
        class Dmb64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Dmb64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "clrex".
         */
        class Clrex64 : public ArmStaticInst
        {
          public:
                /// Constructor.
                Clrex64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

    class STRB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRB64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRB64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRB64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRB64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRB64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRB64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRB64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRB64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRB64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRB64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRH64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRH64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRH64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRH64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRH64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRH64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRH64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRH64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRH64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRH64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRW64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRW64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRW64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRW64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRW64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRW64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRW64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRW64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRW64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRW64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRX64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRX64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRX64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRX64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRX64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRX64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRX64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRX64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRX64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRX64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STRBFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRBFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRBFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRBFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRBFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRBFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRBFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRBFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRBFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRBFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRBFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRBFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRHFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRHFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRHFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRHFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRHFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRHFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRHFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRHFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRHFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRHFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRHFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRHFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRSFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRSFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRSFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRSFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRSFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRSFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRSFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRSFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRSFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRSFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRSFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRSFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRDFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STRDFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STRDFP64_PREAcc : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRDFP64_PREAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRDFP64_PRE : public ArmISA::MemoryPreIndex64
    {
      public:

        /// Constructor.
        STRDFP64_PRE(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRDFP64_POSTAcc : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRDFP64_POSTAcc(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRDFP64_POST : public ArmISA::MemoryPostIndex64
    {
      public:

        /// Constructor.
        STRDFP64_POST(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    class STRDFP64_REG : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        STRDFP64_REG(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STURH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STURW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STURX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STURBFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURBFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURHFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURHFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURSFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURSFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STURDFP64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STURDFP64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STTRB64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STTRB64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STTRH64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STTRH64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STTRW64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STTRW64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STTRX64_IMM : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        STTRX64_IMM(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, false);
                
        }
    };

    class STLRX64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        STLRX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 3);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, true);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class STLRW64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        STLRW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 2);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class STLRH64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        STLRH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 1);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class STLRB64 : public ArmISA::MemoryRaw64
    {
      public:

        /// Constructor.
        STLRB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    fault->annotate(ArmFault::SAS, 0);
                    fault->annotate(ArmFault::SSE, false);
                    fault->annotate(ArmFault::SRT, dest);
                    fault->annotate(ArmFault::SF, false);
                    fault->annotate(ArmFault::AR, true);
                
        }
    };

    class STLXRX64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STLXRX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRW64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STLXRW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRH64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STLXRH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STLXRB64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STLXRB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRX64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STXRX64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRW64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STXRW64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRH64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STXRH64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class STXRB64 : public ArmISA::MemoryEx64
    {
      public:

        /// Constructor.
        STXRB64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _base, IntRegIndex _result);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "stlxp".
     */
    class STLXPW64 : public ArmISA::MemoryDImmEx64
    {
      public:

        /// Constructor.
        STLXPW64(ExtMachInst machInst,
                IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
                IntRegIndex _base, int64_t _imm = 0);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "stlxp".
     */
    class STLXPX64 : public ArmISA::MemoryDImmEx64
    {
      public:

        /// Constructor.
        STLXPX64(ExtMachInst machInst,
                IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
                IntRegIndex _base, int64_t _imm = 0);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "stxp".
     */
    class STXPW64 : public ArmISA::MemoryDImmEx64
    {
      public:

        /// Constructor.
        STXPW64(ExtMachInst machInst,
                IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
                IntRegIndex _base, int64_t _imm = 0);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "stxp".
     */
    class STXPX64 : public ArmISA::MemoryDImmEx64
    {
      public:

        /// Constructor.
        STXPX64(ExtMachInst machInst,
                IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
                IntRegIndex _base, int64_t _imm = 0);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroStrXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroStrXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroStrXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrFpXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroStrFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrFpXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroStrFpXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQBFpXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroStrQBFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQBFpXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroStrQBFpXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQTFpXImmUop : public ArmISA::MemoryImm64
    {
      public:

        /// Constructor.
        MicroStrQTFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrQTFpXRegUop : public ArmISA::MemoryReg64
    {
      public:

        /// Constructor.
        MicroStrQTFpXRegUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
                ArmExtendType _type, uint32_t _shiftAmt,
                bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrDXImmUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroStrDXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    class MicroStrDFpXImmUop : public ArmISA::MemoryDImm64
    {
      public:

        /// Constructor.
        MicroStrDFpXImmUop(ExtMachInst machInst,
                IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
                int64_t _imm = 0, bool noAlloc = false, bool exclusive = false,
                bool acrel = false);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 0);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 1);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strex".
     */
    class STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexh".
     */
    class STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexb".
     */
    class STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexd".
     */
    class STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryExDImm>
    {
      public:

        /// Constructor.
        STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            
                    if (dest != INTREG_PC) {
                        fault->annotate(ArmFault::SAS, 2);
                        fault->annotate(ArmFault::SSE, false);
                        fault->annotate(ArmFault::SRT, dest);
                    }
                
        }
    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "swp".
     */
    class Swp : public Swap
    {
      public:

        /// Constructor.
        Swp(ExtMachInst machInst,
                uint32_t _dest, uint32_t _op1, uint32_t _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "swpb".
     */
    class Swpb : public Swap
    {
      public:

        /// Constructor.
        Swpb(ExtMachInst machInst,
                uint32_t _dest, uint32_t _op1, uint32_t _base);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdrUop : public MicroMemOp
    {
      public:
        MicroLdrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdrRetUop : public MicroMemOp
    {
      public:
        MicroLdrRetUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdrFpUop : public MicroMemOp
    {
      public:
        MicroLdrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdrDBFpUop : public MicroMemOp
    {
      public:
        MicroLdrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdrDTFpUop : public MicroMemOp
    {
      public:
        MicroLdrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroStrUop : public MicroMemOp
    {
      public:
        MicroStrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroStrFpUop : public MicroMemOp
    {
      public:
        MicroStrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroStrDBFpUop : public MicroMemOp
    {
      public:
        MicroStrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroStrDTFpUop : public MicroMemOp
    {
      public:
        MicroStrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroLdr2Uop : public MicroMemPairOp
    {
      public:
        MicroLdr2Uop(ExtMachInst machInst,
                       RegIndex _dreg1, RegIndex _dreg2, RegIndex _base,
                       bool _up, uint8_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon1Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon1_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon1Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon1_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon2Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon2_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon2Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon2_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon3Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon3_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon3Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon3_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon4Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon4_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon4Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon4_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon6Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon6_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon6Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon6_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon8Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon8_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon8Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon8_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon12Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon12_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon12Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon12_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon16Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon16_uop", machInst,
                              MemReadOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon16Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon16_uop", machInst,
                              MemWriteOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon4Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon4Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon6Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon6Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 4) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 5) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon8Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon8Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 4) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 5) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 6) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 7) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to6Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to8Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to6Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to8Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to2Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to4Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to6Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to8Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to4Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to6Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to8Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon4to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon4to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon6to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon6to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon8to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon8to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon6to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon6to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon8to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon8to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroAddiUop : public MicroIntImmOp
    {
      public:
        MicroAddiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroAddXiUop : public MicroIntImmXOp
    {
      public:
        MicroAddXiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroAddXiSpAlignUop : public MicroIntImmXOp
    {
      public:
        MicroAddXiSpAlignUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroSubiUop : public MicroIntImmOp
    {
      public:
        MicroSubiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroSubXiUop : public MicroIntImmXOp
    {
      public:
        MicroSubXiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroAddUop : public MicroIntRegOp
    {
      public:
        MicroAddUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroSubUop : public MicroIntRegOp
    {
      public:
        MicroSubUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroAddXERegUop : public MicroIntRegXOp
    {
      public:
        MicroAddXERegUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       ArmExtendType _type, uint32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroUopRegMov : public MicroIntMov
    {
      public:
        MicroUopRegMov(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroUopRegMovRet : public MicroIntMov
    {
      public:
        MicroUopRegMovRet(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroUopSetPCCPSR : public MicroSetPCCPSR
    {
      public:
        MicroUopSetPCCPSR(ExtMachInst machInst,
                       IntRegIndex _ura,
                       IntRegIndex _urb,
                       IntRegIndex _urc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

/**
 * Static instructions class for a store multiple instruction
 */
class LdmStm : public MacroMemOp
{
    public:
        // Constructor
        LdmStm(ExtMachInst machInst, IntRegIndex rn,
                bool index, bool up, bool user, bool writeback, bool load,
                uint32_t reglist);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class LdpStp : public PairMemOp
{
    public:
        // Constructor
        LdpStp(const char *mnemonic, ExtMachInst machInst,
                uint32_t size, bool fp, bool load, bool noAlloc, bool signExt,
                bool exclusive, bool acrel, uint32_t imm,
                AddrMode mode, IntRegIndex rn, IntRegIndex rt,
                IntRegIndex rt2);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class BigFpMemImm : public BigFpMemImmOp
{
  public:
    // Constructor
    BigFpMemImm(const char *mnemonic, ExtMachInst machInst,
                   bool load, IntRegIndex dest, IntRegIndex base, int64_t imm);
    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class BigFpMemPre : public BigFpMemPreOp
{
  public:
    // Constructor
    BigFpMemPre(const char *mnemonic, ExtMachInst machInst,
                   bool load, IntRegIndex dest, IntRegIndex base, int64_t imm);
    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class BigFpMemPost : public BigFpMemPostOp
{
  public:
    // Constructor
    BigFpMemPost(const char *mnemonic, ExtMachInst machInst,
                   bool load, IntRegIndex dest, IntRegIndex base, int64_t imm);
    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class BigFpMemReg : public BigFpMemRegOp
{
  public:
    // Constructor
    BigFpMemReg(const char *mnemonic, ExtMachInst machInst,
                   bool load, IntRegIndex dest, IntRegIndex base,
                   IntRegIndex offset, ArmExtendType type, int64_t imm);
    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class BigFpMemLit : public BigFpMemLitOp
{
  public:
    // Constructor
    BigFpMemLit(const char *mnemonic, ExtMachInst machInst,
                   IntRegIndex dest, int64_t imm);
    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VldMult : public VldMultOp
{
    public:
        // Constructor
        VldMult(ExtMachInst machInst, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VldSingle : public VldSingleOp
{
    public:
        // Constructor
        VldSingle(ExtMachInst machInst, bool all, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm, unsigned lane = 0);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VstMult : public VstMultOp
{
    public:
        // Constructor
        VstMult(ExtMachInst machInst, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VstSingle : public VstSingleOp
{
    public:
        // Constructor
        VstSingle(ExtMachInst machInst, bool all, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm, unsigned lane = 0);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

/**
 * Static instructions class for a store multiple instruction
 */
class VLdmStm : public MacroVFPMemOp
{
    public:
        // Constructor
        VLdmStm(ExtMachInst machInst, IntRegIndex rn,
                RegIndex vd, bool single, bool up, bool writeback,
                bool load, uint32_t offset);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class AndImm : public DataImmOp
{
    public:
        // Constructor
        AndImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndImmCc : public DataImmOp
{
    public:
        // Constructor
        AndImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndReg : public DataRegOp
{
    public:
        // Constructor
        AndReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndRegCc : public DataRegOp
{
    public:
        // Constructor
        AndRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AndRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AndRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AndsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AndsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorImm : public DataImmOp
{
    public:
        // Constructor
        EorImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorImmCc : public DataImmOp
{
    public:
        // Constructor
        EorImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorReg : public DataRegOp
{
    public:
        // Constructor
        EorReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorRegCc : public DataRegOp
{
    public:
        // Constructor
        EorRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorRegReg : public DataRegRegOp
{
    public:
        // Constructor
        EorRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        EorRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorsImmPclr : public DataImmOp
{
    public:
        // Constructor
        EorsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorsRegPclr : public DataRegOp
{
    public:
        // Constructor
        EorsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubImm : public DataImmOp
{
    public:
        // Constructor
        SubImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubImmCc : public DataImmOp
{
    public:
        // Constructor
        SubImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubReg : public DataRegOp
{
    public:
        // Constructor
        SubReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubRegCc : public DataRegOp
{
    public:
        // Constructor
        SubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubRegReg : public DataRegRegOp
{
    public:
        // Constructor
        SubRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        SubRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubsImmPclr : public DataImmOp
{
    public:
        // Constructor
        SubsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubsRegPclr : public DataRegOp
{
    public:
        // Constructor
        SubsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbImm : public DataImmOp
{
    public:
        // Constructor
        RsbImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbImmCc : public DataImmOp
{
    public:
        // Constructor
        RsbImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbReg : public DataRegOp
{
    public:
        // Constructor
        RsbReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbRegCc : public DataRegOp
{
    public:
        // Constructor
        RsbRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbRegReg : public DataRegRegOp
{
    public:
        // Constructor
        RsbRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        RsbRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbsImmPclr : public DataImmOp
{
    public:
        // Constructor
        RsbsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RsbsRegPclr : public DataRegOp
{
    public:
        // Constructor
        RsbsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddImm : public DataImmOp
{
    public:
        // Constructor
        AddImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddImmCc : public DataImmOp
{
    public:
        // Constructor
        AddImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddReg : public DataRegOp
{
    public:
        // Constructor
        AddReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddRegCc : public DataRegOp
{
    public:
        // Constructor
        AddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AddRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AddRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AddsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AddsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdrImm : public DataImmOp
{
    public:
        // Constructor
        AdrImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdrImmCc : public DataImmOp
{
    public:
        // Constructor
        AdrImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcImm : public DataImmOp
{
    public:
        // Constructor
        AdcImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcImmCc : public DataImmOp
{
    public:
        // Constructor
        AdcImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcReg : public DataRegOp
{
    public:
        // Constructor
        AdcReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcRegCc : public DataRegOp
{
    public:
        // Constructor
        AdcRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AdcRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AdcRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AdcsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AdcsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcImm : public DataImmOp
{
    public:
        // Constructor
        SbcImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcImmCc : public DataImmOp
{
    public:
        // Constructor
        SbcImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcReg : public DataRegOp
{
    public:
        // Constructor
        SbcReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcRegCc : public DataRegOp
{
    public:
        // Constructor
        SbcRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcRegReg : public DataRegRegOp
{
    public:
        // Constructor
        SbcRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        SbcRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcsImmPclr : public DataImmOp
{
    public:
        // Constructor
        SbcsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcsRegPclr : public DataRegOp
{
    public:
        // Constructor
        SbcsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscImm : public DataImmOp
{
    public:
        // Constructor
        RscImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscImmCc : public DataImmOp
{
    public:
        // Constructor
        RscImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscReg : public DataRegOp
{
    public:
        // Constructor
        RscReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscRegCc : public DataRegOp
{
    public:
        // Constructor
        RscRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscRegReg : public DataRegRegOp
{
    public:
        // Constructor
        RscRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        RscRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscsImmPclr : public DataImmOp
{
    public:
        // Constructor
        RscsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class RscsRegPclr : public DataRegOp
{
    public:
        // Constructor
        RscsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstImm : public DataImmOp
{
    public:
        // Constructor
        TstImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstImmCc : public DataImmOp
{
    public:
        // Constructor
        TstImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstReg : public DataRegOp
{
    public:
        // Constructor
        TstReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstRegCc : public DataRegOp
{
    public:
        // Constructor
        TstRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstRegReg : public DataRegRegOp
{
    public:
        // Constructor
        TstRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        TstRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstsImmPclr : public DataImmOp
{
    public:
        // Constructor
        TstsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TstsRegPclr : public DataRegOp
{
    public:
        // Constructor
        TstsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqImm : public DataImmOp
{
    public:
        // Constructor
        TeqImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqImmCc : public DataImmOp
{
    public:
        // Constructor
        TeqImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqReg : public DataRegOp
{
    public:
        // Constructor
        TeqReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqRegCc : public DataRegOp
{
    public:
        // Constructor
        TeqRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqRegReg : public DataRegRegOp
{
    public:
        // Constructor
        TeqRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        TeqRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqsImmPclr : public DataImmOp
{
    public:
        // Constructor
        TeqsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class TeqsRegPclr : public DataRegOp
{
    public:
        // Constructor
        TeqsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpImm : public DataImmOp
{
    public:
        // Constructor
        CmpImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpImmCc : public DataImmOp
{
    public:
        // Constructor
        CmpImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpReg : public DataRegOp
{
    public:
        // Constructor
        CmpReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpRegCc : public DataRegOp
{
    public:
        // Constructor
        CmpRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpRegReg : public DataRegRegOp
{
    public:
        // Constructor
        CmpRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        CmpRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpsImmPclr : public DataImmOp
{
    public:
        // Constructor
        CmpsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmpsRegPclr : public DataRegOp
{
    public:
        // Constructor
        CmpsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnImm : public DataImmOp
{
    public:
        // Constructor
        CmnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnImmCc : public DataImmOp
{
    public:
        // Constructor
        CmnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnReg : public DataRegOp
{
    public:
        // Constructor
        CmnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnRegCc : public DataRegOp
{
    public:
        // Constructor
        CmnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        CmnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        CmnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        CmnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CmnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        CmnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrImm : public DataImmOp
{
    public:
        // Constructor
        OrrImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrImmCc : public DataImmOp
{
    public:
        // Constructor
        OrrImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrReg : public DataRegOp
{
    public:
        // Constructor
        OrrReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrRegCc : public DataRegOp
{
    public:
        // Constructor
        OrrRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrRegReg : public DataRegRegOp
{
    public:
        // Constructor
        OrrRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        OrrRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrsImmPclr : public DataImmOp
{
    public:
        // Constructor
        OrrsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrsRegPclr : public DataRegOp
{
    public:
        // Constructor
        OrrsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnImm : public DataImmOp
{
    public:
        // Constructor
        OrnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnImmCc : public DataImmOp
{
    public:
        // Constructor
        OrnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnReg : public DataRegOp
{
    public:
        // Constructor
        OrnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnRegCc : public DataRegOp
{
    public:
        // Constructor
        OrnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        OrnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        OrnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        OrnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        OrnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovImm : public DataImmOp
{
    public:
        // Constructor
        MovImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovImmCc : public DataImmOp
{
    public:
        // Constructor
        MovImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovReg : public DataRegOp
{
    public:
        // Constructor
        MovReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovRegCc : public DataRegOp
{
    public:
        // Constructor
        MovRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MovRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MovRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MovsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MovsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicImm : public DataImmOp
{
    public:
        // Constructor
        BicImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicImmCc : public DataImmOp
{
    public:
        // Constructor
        BicImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicReg : public DataRegOp
{
    public:
        // Constructor
        BicReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicRegCc : public DataRegOp
{
    public:
        // Constructor
        BicRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicRegReg : public DataRegRegOp
{
    public:
        // Constructor
        BicRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        BicRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicsImmPclr : public DataImmOp
{
    public:
        // Constructor
        BicsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicsRegPclr : public DataRegOp
{
    public:
        // Constructor
        BicsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnImm : public DataImmOp
{
    public:
        // Constructor
        MvnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnImmCc : public DataImmOp
{
    public:
        // Constructor
        MvnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnReg : public DataRegOp
{
    public:
        // Constructor
        MvnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnRegCc : public DataRegOp
{
    public:
        // Constructor
        MvnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MvnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MvnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MvnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MvnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MvnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtImm : public DataImmOp
{
    public:
        // Constructor
        MovtImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtImmCc : public DataImmOp
{
    public:
        // Constructor
        MovtImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtReg : public DataRegOp
{
    public:
        // Constructor
        MovtReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtRegCc : public DataRegOp
{
    public:
        // Constructor
        MovtRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MovtRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MovtRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MovtsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MovtsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MovtsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QaddRegCc : public DataRegOp
{
    public:
        // Constructor
        QaddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Qadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Qadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Qadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Qadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QdaddRegCc : public DataRegOp
{
    public:
        // Constructor
        QdaddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QsubReg : public DataRegOp
{
    public:
        // Constructor
        QsubReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QsubRegCc : public DataRegOp
{
    public:
        // Constructor
        QsubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Qsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Qsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Qsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Qsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QdsubRegCc : public DataRegOp
{
    public:
        // Constructor
        QdsubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QasxReg : public DataRegOp
{
    public:
        // Constructor
        QasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class QsaxReg : public DataRegOp
{
    public:
        // Constructor
        QsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sadd8RegCc : public DataRegOp
{
    public:
        // Constructor
        Sadd8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sadd16RegCc : public DataRegOp
{
    public:
        // Constructor
        Sadd16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ssub8RegCc : public DataRegOp
{
    public:
        // Constructor
        Ssub8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ssub16RegCc : public DataRegOp
{
    public:
        // Constructor
        Ssub16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SasxReg : public DataRegOp
{
    public:
        // Constructor
        SasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SasxRegCc : public DataRegOp
{
    public:
        // Constructor
        SasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SsaxReg : public DataRegOp
{
    public:
        // Constructor
        SsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        SsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Shadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Shadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Shadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Shadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Shsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Shsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Shsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Shsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class ShasxReg : public DataRegOp
{
    public:
        // Constructor
        ShasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class ShasxRegCc : public DataRegOp
{
    public:
        // Constructor
        ShasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class ShsaxReg : public DataRegOp
{
    public:
        // Constructor
        ShsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class ShsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        ShsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uqadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Uqadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uqadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Uqadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uqsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Uqsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uqsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Uqsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UqasxReg : public DataRegOp
{
    public:
        // Constructor
        UqasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UqsaxReg : public DataRegOp
{
    public:
        // Constructor
        UqsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uadd16RegCc : public DataRegOp
{
    public:
        // Constructor
        Uadd16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uadd8RegCc : public DataRegOp
{
    public:
        // Constructor
        Uadd8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usub16RegCc : public DataRegOp
{
    public:
        // Constructor
        Usub16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Usub8RegCc : public DataRegOp
{
    public:
        // Constructor
        Usub8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UasxRegCc : public DataRegOp
{
    public:
        // Constructor
        UasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        UsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uhadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Uhadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uhadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Uhadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uhsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Uhsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Uhsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Uhsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UhasxReg : public DataRegOp
{
    public:
        // Constructor
        UhasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UhsaxReg : public DataRegOp
{
    public:
        // Constructor
        UhsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class PkhbtReg : public DataRegOp
{
    public:
        // Constructor
        PkhbtReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class PkhtbReg : public DataRegOp
{
    public:
        // Constructor
        PkhtbReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdrXImm : public DataXImmOp
{
    public:
        // Constructor
        AdrXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdrpXImm : public DataXImmOp
{
    public:
        // Constructor
        AdrpXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXImm : public DataXImmOp
{
    public:
        // Constructor
        AndXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXImmCc : public DataXImmOp
{
    public:
        // Constructor
        AndXImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXSReg : public DataXSRegOp
{
    public:
        // Constructor
        AndXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        AndXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXEReg : public DataXERegOp
{
    public:
        // Constructor
        AndXEReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AndXERegCc : public DataXERegOp
{
    public:
        // Constructor
        AndXERegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorXImm : public DataXImmOp
{
    public:
        // Constructor
        EorXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorXSReg : public DataXSRegOp
{
    public:
        // Constructor
        EorXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EorXEReg : public DataXERegOp
{
    public:
        // Constructor
        EorXEReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class EonXSReg : public DataXSRegOp
{
    public:
        // Constructor
        EonXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXImm : public DataXImmOp
{
    public:
        // Constructor
        SubXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXImmCc : public DataXImmOp
{
    public:
        // Constructor
        SubXImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXSReg : public DataXSRegOp
{
    public:
        // Constructor
        SubXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        SubXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXEReg : public DataXERegOp
{
    public:
        // Constructor
        SubXEReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SubXERegCc : public DataXERegOp
{
    public:
        // Constructor
        SubXERegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXImm : public DataXImmOp
{
    public:
        // Constructor
        AddXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXImmCc : public DataXImmOp
{
    public:
        // Constructor
        AddXImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXSReg : public DataXSRegOp
{
    public:
        // Constructor
        AddXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        AddXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXEReg : public DataXERegOp
{
    public:
        // Constructor
        AddXEReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AddXERegCc : public DataXERegOp
{
    public:
        // Constructor
        AddXERegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcXSReg : public DataXSRegOp
{
    public:
        // Constructor
        AdcXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class AdcXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        AdcXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcXSReg : public DataXSRegOp
{
    public:
        // Constructor
        SbcXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SbcXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        SbcXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrXImm : public DataXImmOp
{
    public:
        // Constructor
        OrrXImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrXSReg : public DataXSRegOp
{
    public:
        // Constructor
        OrrXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrrXEReg : public DataXERegOp
{
    public:
        // Constructor
        OrrXEReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                ArmExtendType _extendType, int32_t _shiftAmt);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class OrnXSReg : public DataXSRegOp
{
    public:
        // Constructor
        OrnXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicXSReg : public DataXSRegOp
{
    public:
        // Constructor
        BicXSReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BicXSRegCc : public DataXSRegOp
{
    public:
        // Constructor
        BicXSRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Madd64 : public DataX3RegOp
{
    public:
        // Constructor
        Madd64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Msub64 : public DataX3RegOp
{
    public:
        // Constructor
        Msub64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smaddl64 : public DataX3RegOp
{
    public:
        // Constructor
        Smaddl64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smsubl64 : public DataX3RegOp
{
    public:
        // Constructor
        Smsubl64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smulh64 : public DataX2RegOp
{
    public:
        // Constructor
        Smulh64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umaddl64 : public DataX3RegOp
{
    public:
        // Constructor
        Umaddl64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umsubl64 : public DataX3RegOp
{
    public:
        // Constructor
        Umsubl64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umulh64 : public DataX2RegOp
{
    public:
        // Constructor
        Umulh64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Asrv64 : public DataX2RegOp
{
    public:
        // Constructor
        Asrv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Lslv64 : public DataX2RegOp
{
    public:
        // Constructor
        Lslv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Lsrv64 : public DataX2RegOp
{
    public:
        // Constructor
        Lsrv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rorv64 : public DataX2RegOp
{
    public:
        // Constructor
        Rorv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sdiv64 : public DataX2RegOp
{
    public:
        // Constructor
        Sdiv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Udiv64 : public DataX2RegOp
{
    public:
        // Constructor
        Udiv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Cls64 : public DataX1RegOp
{
    public:
        // Constructor
        Cls64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Clz64 : public DataX1RegOp
{
    public:
        // Constructor
        Clz64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rbit64 : public DataX1RegOp
{
    public:
        // Constructor
        Rbit64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rev64 : public DataX1RegOp
{
    public:
        // Constructor
        Rev64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rev1664 : public DataX1RegOp
{
    public:
        // Constructor
        Rev1664(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Rev3264 : public DataX1RegOp
{
    public:
        // Constructor
        Rev3264(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mrs64 : public DataXImmOp
{
    public:
        // Constructor
        Mrs64(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MrsNZCV64 : public DataX1RegOp
{
    public:
        // Constructor
        MrsNZCV64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Msr64 : public DataXImmOp
{
    public:
        // Constructor
        Msr64(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrNZCV64 : public DataX1RegOp
{
    public:
        // Constructor
        MsrNZCV64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

    class Dczva : public SysDC64
    {
      public:

        /// Constructor.
        Dczva(ExtMachInst machInst, IntRegIndex _base, IntRegIndex _dest, uint64_t _imm);

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;


        virtual void
        annotateFault(ArmFault *fault) {
            ;
        }
    };

class MsrSP64 : public DataXImmOp
{
    public:
        // Constructor
        MsrSP64(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrDAIFSet64 : public DataXImmOp
{
    public:
        // Constructor
        MsrDAIFSet64(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MsrDAIFClr64 : public DataXImmOp
{
    public:
        // Constructor
        MsrDAIFClr64(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CcmnImm64 : public DataXCondCompImmOp
{
    public:
        // Constructor
        CcmnImm64(ExtMachInst machInst, IntRegIndex _op1,
                       uint64_t _imm, ConditionCode _condCode, uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CcmpImm64 : public DataXCondCompImmOp
{
    public:
        // Constructor
        CcmpImm64(ExtMachInst machInst, IntRegIndex _op1,
                       uint64_t _imm, ConditionCode _condCode, uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CcmnReg64 : public DataXCondCompRegOp
{
    public:
        // Constructor
        CcmnReg64(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class CcmpReg64 : public DataXCondCompRegOp
{
    public:
        // Constructor
        CcmpReg64(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Csel64 : public DataXCondSelOp
{
    public:
        // Constructor
        Csel64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Csinc64 : public DataXCondSelOp
{
    public:
        // Constructor
        Csinc64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Csinv64 : public DataXCondSelOp
{
    public:
        // Constructor
        Csinv64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Csneg64 : public DataXCondSelOp
{
    public:
        // Constructor
        Csneg64(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class B : public BranchImmCond
{
    public:
        // Constructor
        B(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class Bl : public BranchImmCond
{
    public:
        // Constructor
        Bl(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class BlxImm : public BranchImmCond
{
    public:
        // Constructor
        BlxImm(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class BlxReg : public BranchRegCond
{
    public:
        // Constructor
        BlxReg(ExtMachInst machInst, IntRegIndex _op1,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BxReg : public BranchRegCond
{
    public:
        // Constructor
        BxReg(ExtMachInst machInst, IntRegIndex _op1,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BxjReg : public BranchRegCond
{
    public:
        // Constructor
        BxjReg(ExtMachInst machInst, IntRegIndex _op1,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Cbz : public BranchImmReg
{
    public:
        // Constructor
        Cbz(ExtMachInst machInst,
                       int32_t imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class Cbnz : public BranchImmReg
{
    public:
        // Constructor
        Cbnz(ExtMachInst machInst,
                       int32_t imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class Tbb : public BranchRegReg
{
    public:
        // Constructor
        Tbb(ExtMachInst machInst,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

};

class Tbh : public BranchRegReg
{
    public:
        // Constructor
        Tbh(ExtMachInst machInst,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

};

class B64 : public BranchImm64
{
    public:
        // Constructor
        B64(ExtMachInst machInst, int64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Bl64 : public BranchImm64
{
    public:
        // Constructor
        Bl64(ExtMachInst machInst, int64_t _imm);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Br64 : public BranchReg64
{
    public:
        // Constructor
        Br64(ExtMachInst machInst, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Blr64 : public BranchReg64
{
    public:
        // Constructor
        Blr64(ExtMachInst machInst, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class BCond64 : public BranchImmCond64
{
    public:
        // Constructor
        BCond64(ExtMachInst machInst, int64_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Ret64 : public BranchRet64
{
    public:
        // Constructor
        Ret64(ExtMachInst machInst, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "eret".
         */
        class Eret64 : public BranchEret64
        {
          public:
                /// Constructor.
                Eret64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class Cbz64 : public BranchImmReg64
{
    public:
        // Constructor
        Cbz64(ExtMachInst machInst,
                       int64_t imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Cbnz64 : public BranchImmReg64
{
    public:
        // Constructor
        Cbnz64(ExtMachInst machInst,
                       int64_t imm, IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Tbz64 : public BranchImmImmReg64
{
    public:
        // Constructor
        Tbz64(ExtMachInst machInst, int64_t _imm1, int64_t _imm2,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Tbnz64 : public BranchImmImmReg64
{
    public:
        // Constructor
        Tbnz64(ExtMachInst machInst, int64_t _imm1, int64_t _imm2,
                       IntRegIndex _op1);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mla : public Mult4
{
    public:
        // Constructor
        Mla(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MlaCc : public Mult4
{
    public:
        // Constructor
        MlaCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mls : public Mult4
{
    public:
        // Constructor
        Mls(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Mul : public Mult3
{
    public:
        // Constructor
        Mul(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class MulCc : public Mult3
{
    public:
        // Constructor
        MulCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlabbCc : public Mult4
{
    public:
        // Constructor
        SmlabbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlabtCc : public Mult4
{
    public:
        // Constructor
        SmlabtCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlatbCc : public Mult4
{
    public:
        // Constructor
        SmlatbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlattCc : public Mult4
{
    public:
        // Constructor
        SmlattCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmladCc : public Mult4
{
    public:
        // Constructor
        SmladCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmladxCc : public Mult4
{
    public:
        // Constructor
        SmladxCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlal : public Mult4
{
    public:
        // Constructor
        Smlal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlalCc : public Mult4
{
    public:
        // Constructor
        SmlalCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlalbb : public Mult4
{
    public:
        // Constructor
        Smlalbb(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlalbt : public Mult4
{
    public:
        // Constructor
        Smlalbt(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlaltb : public Mult4
{
    public:
        // Constructor
        Smlaltb(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlaltt : public Mult4
{
    public:
        // Constructor
        Smlaltt(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlald : public Mult4
{
    public:
        // Constructor
        Smlald(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlaldx : public Mult4
{
    public:
        // Constructor
        Smlaldx(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlawbCc : public Mult4
{
    public:
        // Constructor
        SmlawbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlawtCc : public Mult4
{
    public:
        // Constructor
        SmlawtCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlsdCc : public Mult4
{
    public:
        // Constructor
        SmlsdCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmlsdxCc : public Mult4
{
    public:
        // Constructor
        SmlsdxCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlsld : public Mult4
{
    public:
        // Constructor
        Smlsld(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smlsldx : public Mult4
{
    public:
        // Constructor
        Smlsldx(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmla : public Mult4
{
    public:
        // Constructor
        Smmla(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmlar : public Mult4
{
    public:
        // Constructor
        Smmlar(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmls : public Mult4
{
    public:
        // Constructor
        Smmls(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmlsr : public Mult4
{
    public:
        // Constructor
        Smmlsr(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmul : public Mult3
{
    public:
        // Constructor
        Smmul(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smmulr : public Mult3
{
    public:
        // Constructor
        Smmulr(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmuadCc : public Mult3
{
    public:
        // Constructor
        SmuadCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmuadxCc : public Mult3
{
    public:
        // Constructor
        SmuadxCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smulbb : public Mult3
{
    public:
        // Constructor
        Smulbb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smulbt : public Mult3
{
    public:
        // Constructor
        Smulbt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smultb : public Mult3
{
    public:
        // Constructor
        Smultb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smultt : public Mult3
{
    public:
        // Constructor
        Smultt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smull : public Mult4
{
    public:
        // Constructor
        Smull(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class SmullCc : public Mult4
{
    public:
        // Constructor
        SmullCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smulwb : public Mult3
{
    public:
        // Constructor
        Smulwb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smulwt : public Mult3
{
    public:
        // Constructor
        Smulwt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smusd : public Mult3
{
    public:
        // Constructor
        Smusd(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Smusdx : public Mult3
{
    public:
        // Constructor
        Smusdx(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umaal : public Mult4
{
    public:
        // Constructor
        Umaal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umlal : public Mult4
{
    public:
        // Constructor
        Umlal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UmlalCc : public Mult4
{
    public:
        // Constructor
        UmlalCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Umull : public Mult4
{
    public:
        // Constructor
        Umull(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class UmullCc : public Mult4
{
    public:
        // Constructor
        UmullCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Sdiv : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Sdiv(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Udiv : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Udiv(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};


template <class Micro>
class VfpMacroRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                     IntRegIndex _op1, bool _wide) :
        VfpMacroOp("VfpMacroRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        assert(numMicroops > 1);
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, mode);
            nextIdxs(_dest, _op1);
        }
    }

    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegOp(ExtMachInst machInst,
        IntRegIndex dest, IntRegIndex op1, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1);
    } else {
        return new VfpMacroRegRegOp<VfpOp>(machInst, dest, op1, wide);
    }
}

template <class Micro>
class VfpMacroRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegImmOp(ExtMachInst _machInst, IntRegIndex _dest, uint64_t _imm,
                     bool _wide) :
        VfpMacroOp("VfpMacroRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _imm, mode);
            nextIdxs(_dest);
        }
    }

    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegImmOp(ExtMachInst machInst,
        IntRegIndex dest, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, imm);
    } else {
        return new VfpMacroRegImmOp<VfpOp>(machInst, dest, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegImmOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, uint64_t _imm, bool _wide) :
        VfpMacroOp("VfpMacroRegRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _imm, mode);
            nextIdxs(_dest, _op1);
        }
    }

    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegImmOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, imm);
    } else {
        return new VfpMacroRegRegImmOp<VfpOp>(machInst, dest, op1, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, IntRegIndex _op2, bool _wide) :
        VfpMacroOp("VfpMacroRegRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _op2, mode);
            nextIdxs(_dest, _op1, _op2);
        }
    }

    
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegRegOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, IntRegIndex op2, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, op2);
    } else {
        return new VfpMacroRegRegRegOp<VfpOp>(machInst, dest, op1, op2, wide);
    }
}

class Vmsr : public FpRegRegImmOp
{
  public:
    // Constructor
    Vmsr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmsrFpscr : public FpRegRegOp
{
  public:
    // Constructor
    VmsrFpscr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Vmrs : public FpRegRegImmOp
{
  public:
    // Constructor
    Vmrs(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmrsFpscr : public FpRegRegOp
{
  public:
    // Constructor
    VmrsFpscr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "vmrs".
         */
        class VmrsApsrFpscr : public PredOp
        {
          public:
                /// Constructor.
                VmrsApsrFpscr(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

class VmovImmS : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovImmD : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovImmQ : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmQ(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegS : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegD : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegQ : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovCoreRegB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovCoreRegB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovCoreRegH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovCoreRegH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovCoreRegW : public FpRegRegOp
{
  public:
    // Constructor
    VmovCoreRegW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegCoreUB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreUB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegCoreUH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreUH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegCoreSB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreSB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegCoreSH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreSH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmovRegCoreW : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegCoreW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Vmov2Reg2Core : public FpRegRegRegOp
{
  public:
    // Constructor
    Vmov2Reg2Core(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class Vmov2Core2Reg : public FpRegRegRegOp
{
  public:
    // Constructor
    Vmov2Core2Reg(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfmaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VfmaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfmaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VfmaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfmsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VfmsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfmsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VfmsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfnmaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VfnmaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfnmaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VfnmaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfnmsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VfnmsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VfnmsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VfnmsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VaddS : public FpRegRegRegOp
{
  public:
    // Constructor
    VaddS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VaddD : public FpRegRegRegOp
{
  public:
    // Constructor
    VaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VsubS : public FpRegRegRegOp
{
  public:
    // Constructor
    VsubS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VsubD : public FpRegRegRegOp
{
  public:
    // Constructor
    VsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VdivS : public FpRegRegRegOp
{
  public:
    // Constructor
    VdivS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VdivD : public FpRegRegRegOp
{
  public:
    // Constructor
    VdivD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmulS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmulD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VsqrtS : public FpRegRegOp
{
  public:
    // Constructor
    VsqrtS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VsqrtD : public FpRegRegOp
{
  public:
    // Constructor
    VsqrtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnegS : public FpRegRegOp
{
  public:
    // Constructor
    VnegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnegD : public FpRegRegOp
{
  public:
    // Constructor
    VnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VabsS : public FpRegRegOp
{
  public:
    // Constructor
    VabsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VabsD : public FpRegRegOp
{
  public:
    // Constructor
    VabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmlaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmlaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmlsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VmlsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmlaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmlaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmlsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmlsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmulS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VnmulD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtUIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtUIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtSIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtSIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUIntSR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntSR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUIntDR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntDR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSIntSR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntSR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSIntDR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntDR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUIntS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUIntD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSIntS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSIntD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpDFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpDFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpHTFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpHTFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpHBFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpHBFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSFpHT : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpHT(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSFpHB : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpHB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpS : public FpRegRegOp
{
  public:
    // Constructor
    VcmpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpD : public FpRegRegOp
{
  public:
    // Constructor
    VcmpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpZeroS : public FpRegImmOp
{
  public:
    // Constructor
    VcmpZeroS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpZeroD : public FpRegImmOp
{
  public:
    // Constructor
    VcmpZeroD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpeS : public FpRegRegOp
{
  public:
    // Constructor
    VcmpeS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpeD : public FpRegRegOp
{
  public:
    // Constructor
    VcmpeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpeZeroS : public FpRegImmOp
{
  public:
    // Constructor
    VcmpeZeroS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcmpeZeroD : public FpRegImmOp
{
  public:
    // Constructor
    VcmpeZeroD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSHFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSHFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpSHFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSHFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUHFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUHFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtFpUHFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUHFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSHFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSHFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtSHFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSHFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUHFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUHFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class VcvtUHFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUHFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovImmS : public FpRegImmOp
{
  public:
    // Constructor
    FmovImmS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovImmD : public FpRegImmOp
{
  public:
    // Constructor
    FmovImmD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovRegS : public FpRegRegOp
{
  public:
    // Constructor
    FmovRegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovRegD : public FpRegRegOp
{
  public:
    // Constructor
    FmovRegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovCoreRegW : public FpRegRegOp
{
  public:
    // Constructor
    FmovCoreRegW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovCoreRegX : public FpRegRegOp
{
  public:
    // Constructor
    FmovCoreRegX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovUCoreRegX : public FpRegRegOp
{
  public:
    // Constructor
    FmovUCoreRegX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovRegCoreW : public FpRegRegOp
{
  public:
    // Constructor
    FmovRegCoreW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovRegCoreX : public FpRegRegOp
{
  public:
    // Constructor
    FmovRegCoreX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FmovURegCoreX : public FpRegRegOp
{
  public:
    // Constructor
    FmovURegCoreX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMAddD : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FMAddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMAddS : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FMAddS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMSubD : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FMSubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMSubS : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FMSubS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMAddD : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FNMAddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMAddS : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FNMAddS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMSubD : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FNMSubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMSubS : public FpRegRegRegRegOp
{
  public:
    // Constructor
    FNMSubS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   IntRegIndex _op3, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FAddS : public FpRegRegRegOp
{
  public:
    // Constructor
    FAddS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FAddD : public FpRegRegRegOp
{
  public:
    // Constructor
    FAddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FSubS : public FpRegRegRegOp
{
  public:
    // Constructor
    FSubS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FSubD : public FpRegRegRegOp
{
  public:
    // Constructor
    FSubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FDivS : public FpRegRegRegOp
{
  public:
    // Constructor
    FDivS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FDivD : public FpRegRegRegOp
{
  public:
    // Constructor
    FDivD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMulS : public FpRegRegRegOp
{
  public:
    // Constructor
    FMulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMulD : public FpRegRegRegOp
{
  public:
    // Constructor
    FMulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMulS : public FpRegRegRegOp
{
  public:
    // Constructor
    FNMulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNMulD : public FpRegRegRegOp
{
  public:
    // Constructor
    FNMulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMinS : public FpRegRegRegOp
{
  public:
    // Constructor
    FMinS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMinD : public FpRegRegRegOp
{
  public:
    // Constructor
    FMinD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMaxS : public FpRegRegRegOp
{
  public:
    // Constructor
    FMaxS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMaxD : public FpRegRegRegOp
{
  public:
    // Constructor
    FMaxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMinNMS : public FpRegRegRegOp
{
  public:
    // Constructor
    FMinNMS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMinNMD : public FpRegRegRegOp
{
  public:
    // Constructor
    FMinNMD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMaxNMS : public FpRegRegRegOp
{
  public:
    // Constructor
    FMaxNMS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FMaxNMD : public FpRegRegRegOp
{
  public:
    // Constructor
    FMaxNMD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FSqrtS : public FpRegRegOp
{
  public:
    // Constructor
    FSqrtS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FSqrtD : public FpRegRegOp
{
  public:
    // Constructor
    FSqrtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNegS : public FpRegRegOp
{
  public:
    // Constructor
    FNegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FNegD : public FpRegRegOp
{
  public:
    // Constructor
    FNegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FAbsS : public FpRegRegOp
{
  public:
    // Constructor
    FAbsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FAbsD : public FpRegRegOp
{
  public:
    // Constructor
    FAbsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntNS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntNS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntND : public FpRegRegOp
{
  public:
    // Constructor
    FRIntND(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntPS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntPS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntPD : public FpRegRegOp
{
  public:
    // Constructor
    FRIntPD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntMS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntMS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntMD : public FpRegRegOp
{
  public:
    // Constructor
    FRIntMD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntZS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntZS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntZD : public FpRegRegOp
{
  public:
    // Constructor
    FRIntZD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntAS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntAS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntAD : public FpRegRegOp
{
  public:
    // Constructor
    FRIntAD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntIS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntIS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntID : public FpRegRegOp
{
  public:
    // Constructor
    FRIntID(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntXS : public FpRegRegOp
{
  public:
    // Constructor
    FRIntXS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FRIntXD : public FpRegRegOp
{
  public:
    // Constructor
    FRIntXD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtWUIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    FcvtWUIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtWSIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    FcvtWSIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtWUIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtWUIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtWSIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtWSIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtXUIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    FcvtXUIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtXSIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    FcvtXSIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtXUIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtXUIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtXSIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtXSIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXDN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXDN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXDP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXDP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXDM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXDM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXDZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXDZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXDA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXDA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWDN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWDN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWDP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWDP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWDM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWDM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWDZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWDZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWDA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWDA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXDN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXDN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXDP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXDP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXDM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXDM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXDZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXDZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXDA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXDA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWDN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWDN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWDP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWDP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWDM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWDM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWDZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWDZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWDA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWDA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXSN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXSN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXSP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXSP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXSM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXSM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXSZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXSZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntXSA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntXSA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWSN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWSN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWSP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWSP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWSM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWSM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWSZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWSZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSIntWSA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSIntWSA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXSN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXSN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXSP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXSP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXSM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXSM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXSZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXSZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntXSA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntXSA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWSN : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWSN(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWSP : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWSP(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWSM : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWSM(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWSZ : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWSZ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUIntWSA : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpUIntWSA(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCvtFpSFpD : public FpRegRegOp
{
  public:
    // Constructor
    FCvtFpSFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpDFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpDFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpHFpD : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpHFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpHFpS : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpHFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpDFpH : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpDFpH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSFpH : public FpRegRegOp
{
  public:
    // Constructor
    FcvtFpSFpH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpImmD : public FpRegImmOp
{
  public:
    // Constructor
    FCmpImmD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpRegD : public FpRegRegOp
{
  public:
    // Constructor
    FCmpRegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpImmS : public FpRegImmOp
{
  public:
    // Constructor
    FCmpImmS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpRegS : public FpRegRegOp
{
  public:
    // Constructor
    FCmpRegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpEImmD : public FpRegImmOp
{
  public:
    // Constructor
    FCmpEImmD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpERegD : public FpRegRegOp
{
  public:
    // Constructor
    FCmpERegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpEImmS : public FpRegImmOp
{
  public:
    // Constructor
    FCmpEImmS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCmpERegS : public FpRegRegOp
{
  public:
    // Constructor
    FCmpERegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCCmpRegD : public FpCondCompRegOp
{
    public:
        // Constructor
        FCCmpRegD(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCCmpRegS : public FpCondCompRegOp
{
    public:
        // Constructor
        FCCmpRegS(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCCmpERegD : public FpCondCompRegOp
{
    public:
        // Constructor
        FCCmpERegD(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCCmpERegS : public FpCondCompRegOp
{
    public:
        // Constructor
        FCCmpERegS(ExtMachInst machInst, IntRegIndex _op1,
                       IntRegIndex _op2, ConditionCode _condCode,
                       uint8_t _defCc);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSFixedDX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpSFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtSFixedFpDX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtSFixedFpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUFixedDX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpUFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtUFixedFpDX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtUFixedFpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSFixedSX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpSFixedSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtSFixedFpSX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtSFixedFpSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUFixedSX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpUFixedSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtUFixedFpSX : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtUFixedFpSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSFixedDW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpSFixedDW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtSFixedFpDW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtSFixedFpDW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUFixedDW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpUFixedDW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtUFixedFpDW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtUFixedFpDW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpSFixedSW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpSFixedSW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtSFixedFpSW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtSFixedFpSW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtFpUFixedSW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtFpUFixedSW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FcvtUFixedFpSW : public FpRegRegImmOp
{
  public:
    // Constructor
    FcvtUFixedFpSW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCSelD : public FpCondSelOp
{
    public:
        // Constructor
        FCSelD(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class FCSelS : public FpCondSelOp
{
    public:
        // Constructor
        FCSelS(ExtMachInst machInst, IntRegIndex _dest,
                       IntRegIndex _op1, IntRegIndex _op2,
                       ConditionCode _condCode);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUReg(bool notSigned, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUReg<Base>(size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<Base>(size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUSReg(unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUSReg(unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeHAndWReg(unsigned size, ExtMachInst machInst,
                             IntRegIndex dest, IntRegIndex op1,
                             IntRegIndex op2)
    {
        switch (size) {
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeImmHAndWReg(unsigned size, ExtMachInst machInst,
                                IntRegIndex dest, IntRegIndex op1,
                                IntRegIndex op2, uint64_t imm)
    {
        switch (size) {
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUSReg(bool notSigned, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeXReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeXReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeSReg(bool q, bool notSigned, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, IntRegIndex dest,
                        IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, IntRegIndex dest,
                        IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeReg(bool q, bool notSigned, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeFpReg(bool q, unsigned size, ExtMachInst machInst,
                          IntRegIndex dest, IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, op2);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, op2);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeScFpReg(bool size, ExtMachInst machInst,
                            IntRegIndex dest, IntRegIndex op1, IntRegIndex op2)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, op2);
        else
            return new Base<uint32_t>(machInst, dest, op1, op2);
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeImmScFpReg(bool size, ExtMachInst machInst,
                               IntRegIndex dest, IntRegIndex op1,
                               IntRegIndex op2, uint64_t imm)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, op2, imm);
        else
            return new Base<uint32_t>(machInst, dest, op1, op2, imm);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeImmHAndWReg(bool q, unsigned size, ExtMachInst machInst,
                                IntRegIndex dest, IntRegIndex op1,
                                IntRegIndex op2, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 1:
                return new BaseQ<uint16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseQ<uint32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 1:
                return new BaseD<uint16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseD<uint32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeImmHAndWReg(bool q, unsigned size, ExtMachInst machInst,
                                IntRegIndex dest, IntRegIndex op1,
                                IntRegIndex op2, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 1:
                return new BaseQ<int16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseQ<int32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 1:
                return new BaseD<int16_t>(machInst, dest, op1, op2, imm);
              case 2:
                return new BaseD<int32_t>(machInst, dest, op1, op2, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeImmFpReg(bool q, unsigned size, ExtMachInst machInst,
                             IntRegIndex dest, IntRegIndex op1,
                             IntRegIndex op2, uint64_t imm)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, op2, imm);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, op2, imm);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, op2, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }


    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoShiftUReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonUTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonUTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonSTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftSReg(bool q, bool notSigned, unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftXReg(bool q, unsigned size, ExtMachInst machInst,
                            IntRegIndex dest, IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonUTwoShiftUReg<BaseQ>(
                size, machInst, dest, op1, imm);
        } else {
            return decodeNeonUTwoShiftUSReg<BaseD>(
                size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftXReg(bool q, unsigned size, ExtMachInst machInst,
                            IntRegIndex dest, IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonSTwoShiftUReg<BaseQ>(
                size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftUSReg<BaseD>(
                size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUFpReg(unsigned size, ExtMachInst machInst,
                              IntRegIndex dest, IntRegIndex op1, uint64_t imm)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1, imm);
        else
            return new Base<uint32_t>(machInst, dest, op1, imm);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftFpReg(bool q, unsigned size, ExtMachInst machInst,
                             IntRegIndex dest, IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1, imm);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1, imm);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscSReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscSReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUReg(unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUReg(unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          case 3:
            return new Base<int64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoMiscSReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscXReg(bool q, unsigned size, ExtMachInst machInst,
                           IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscXReg(bool q, unsigned size, ExtMachInst machInst,
                           IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscFpReg(bool q, unsigned size, ExtMachInst machInst,
                            IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            if (size)
                return new BaseQ<uint64_t>(machInst, dest, op1);
            else
                return new BaseQ<uint32_t>(machInst, dest, op1);
        } else {
            if (size)
                return new Unknown(machInst);
            else
                return new BaseD<uint32_t>(machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscPwiseScFpReg(unsigned size, ExtMachInst machInst,
                                   IntRegIndex dest, IntRegIndex op1)
    {
        if (size)
            return new BaseQ<uint64_t>(machInst, dest, op1);
        else
            return new BaseD<uint32_t>(machInst, dest, op1);
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscScFpReg(unsigned size, ExtMachInst machInst,
                              IntRegIndex dest, IntRegIndex op1)
    {
        if (size)
            return new Base<uint64_t>(machInst, dest, op1);
        else
            return new Base<uint32_t>(machInst, dest, op1);
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonUAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSAcrossLanesReg(bool q, unsigned size, ExtMachInst machInst,
                              IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<int16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseQ<int32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<int16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonUAcrossLanesLongReg(bool q, unsigned size, ExtMachInst machInst,
                                  IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<uint16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<uint32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<uint8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<uint16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ,
              template <typename T> class BaseBQ>
    StaticInstPtr
    decodeNeonSAcrossLanesLongReg(bool q, unsigned size, ExtMachInst machInst,
                                  IntRegIndex dest, IntRegIndex op1)
    {
        if (q) {
            switch (size) {
              case 0x0:
                return new BaseQ<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseQ<int16_t>(machInst, dest, op1);
              case 0x2:
                return new BaseBQ<int32_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0x0:
                return new BaseD<int8_t>(machInst, dest, op1);
              case 0x1:
                return new BaseD<int16_t>(machInst, dest, op1);
              default:
                return new Unknown(machInst);
            }
        }
    }

template <class _Element>
class VhaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VhaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrhaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrhaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrhaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrhaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VhsubD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VhsubQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhsubQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VandD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VandD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vand", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VandQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VandQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vand", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbicD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbicD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbicQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbicQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VorrD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VorrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VorrQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VorrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmovD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmovD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmov", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmovQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmovQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmov", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VornD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VornD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VornQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VornQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VeorD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VeorD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("veor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VeorQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VeorQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("veor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbifD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbifD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbifQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbifQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbitD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbitD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbitQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbitQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbslD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbslD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VbslQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbslQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VminD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VminQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddw : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddw(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vraddhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vraddhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vraddhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsubD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsubQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsubQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubw : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubw(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vrsubhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vrsubhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrsubhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VshlD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VshlQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrshlD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrshlQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabaD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabaQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabaQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vabal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vabal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabal", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vabdl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vabdl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabdl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VtstD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VtstD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VtstQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VtstQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmull : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmull(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlsl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlsl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmull : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmull(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmull", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlsl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlsl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulpD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulpQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmullp : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmullp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VminDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VminQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VaddDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VaddDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VaddQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VaddQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpaddDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpaddDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VpaddQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpaddQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VsubDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VsubDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VsubQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VsubQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVfmaDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVfmaDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vfma", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVfmaQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVfmaQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vfma", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVfmsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVfmsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vfms", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVfmsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVfmsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vfms", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgtDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgtQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgeDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgeQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrecpsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrecpsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrecpsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrecpsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrsqrtsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrsqrtsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VrsqrtsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrsqrtsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlals : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlals(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlsls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlsls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmulls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmulls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmulls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmulls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlals : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlals(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlsls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlsls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsraD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsraD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsraQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsraQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsraD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsraD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsraQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsraQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsriD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsriD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsriQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsriQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshlD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshlQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsliD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsliD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsliQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsliQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshluD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshluD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshluQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshluQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlusD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlusD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlusQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlusQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshrun : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshrun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshruns : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshruns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshrun : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshrun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshruns : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshruns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshll : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshll(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmovl : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmovl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vmovl", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2ufxD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2ufxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2ufxQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2ufxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2sfxD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2sfxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2sfxQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2sfxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvtu2fpD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvtu2fpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvtu2fpQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvtu2fpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2fpD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2fpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2fpQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2fpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2h : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2h(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvth2s : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvth2s(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev16D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev16D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev16Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev16Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev32D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev32D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev32Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev32Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev64D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev64D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev64Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev64Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddlD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpaddl", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddlQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpaddl", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpadalD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpadalD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpadal", machInst, SimdAddAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpadalQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpadalQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpadal", machInst, SimdAddAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclzD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclzD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclzQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclzQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcntD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcntQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcntQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvnD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvnD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvnQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvnQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqabsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqabsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqabsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqnegD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqnegQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqnegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVswpD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVswpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vswp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVswpQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVswpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vswp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVtrnD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVtrnD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vtrn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVtrnQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVtrnQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vtrn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVuzpD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVuzpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vuzp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVuzpQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVuzpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vuzp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVzipD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVzipD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vzip", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVzipQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVzipQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vzip", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmovn : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmovn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmovn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vdup", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vdup", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupDGpr : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupDGpr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vdup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupQGpr : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupQGpr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vdup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmoviD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmoviD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmoviQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmoviQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVorriD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVorriD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVorriQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVorriQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvniD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvniD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvniQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvniQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVbiciD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVbiciD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVbiciQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVbiciQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovn : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovun : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovuns : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovuns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVextD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVextD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NVextQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVextQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbl1 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl1(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbl2 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl2(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbl3 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl3(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbl4 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl4(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbx1 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx1(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbx2 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx2(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbx3 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx3(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

class NVtbx4 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx4(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AbsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AbsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("abs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AbsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AbsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("abs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("add", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("add", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddhnX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddhnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("addhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Addhn2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Addhn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("addhn2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("addp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("addp", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("addp", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("addv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AddvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AddvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("addv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AndDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AndDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("and", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class AndQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    AndQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("and", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BicImmDX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BicImmDX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("bic", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BicImmQX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BicImmQX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("bic", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BicDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BicDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BicQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BicQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BifDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BifDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BifQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BifQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BitDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BitDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BitQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BitQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BslDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BslDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class BslQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    BslQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("bsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ClsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ClsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ClsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ClsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ClzDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ClzDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("clz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ClzQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ClzQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("clz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmeqDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmeqDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmeq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmeqQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmeqQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmeq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmeqZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmeqZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmeq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmeqZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmeqZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmeq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgeDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgeDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgeQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgeQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgeZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgeZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgeZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgeZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgtDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgtDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgtQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgtQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgtZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgtZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmgtZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmgtZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmhiDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmhiDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmhi", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmhiQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmhiQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmhi", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmhsDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmhsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmhs", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmhsQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmhsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmhs", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmleZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmleZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmleZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmleZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmltZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmltZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmlt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmltZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmltZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cmlt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmtstDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmtstDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CmtstQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CmtstQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("cmtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CntDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CntDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class CntQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    CntQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("cnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupElemDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("dup", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupElemQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("dup", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupElemScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("dup", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupGprWDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupGprWDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("dup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupGprWQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupGprWQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("dup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class DupGprXQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    DupGprXQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("dup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class EorDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    EorDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("eor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class EorQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    EorQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("eor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ExtDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ExtDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("Ext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ExtQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ExtQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("Ext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FabdDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FabdDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FabdQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FabdQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FabdScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FabdScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FabsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FabsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Abs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FabsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FabsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Abs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgeDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgeDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgeQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgeQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgeScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgeScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgtDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgtDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgtQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgtQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FacgtScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FacgtScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("facgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddpScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddpScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("faddp", machInst, SimdFloatAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("faddp", machInst, SimdFloatAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("faddp", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FaddpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FaddpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("faddp", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmeqZeroScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmeqZeroScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmeq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgeZeroScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgeZeroScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmgtZeroScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmgtZeroScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmleZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmleZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmleZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmleZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmleZeroScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmleZeroScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmltZeroDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmltZeroDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmltZeroQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmltZeroQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcmltZeroScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcmltZeroScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcmlt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtasDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtasDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtas", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtasQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtasQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtas", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtasScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtasScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtas", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtauDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtauDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtau", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtauQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtauQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtau", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtauScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtauScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtau", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtlX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtlX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtl", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Fcvtl2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Fcvtl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtl", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtms", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtms", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmsScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtms", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmuDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmuDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtmu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmuQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmuQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtmu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtmuScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtmuScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtmu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Fcvtn2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Fcvtn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtns", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtns", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnsScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtns", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnuDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnuDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtnu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnuQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnuQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtnu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtnuScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtnuScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtnu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtps", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtps", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpsScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtps", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpuDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpuDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtpu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpuQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpuQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtpu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtpuScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtpuScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtpu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtxnX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtxnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtxn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Fcvtxn2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Fcvtxn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtxn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtxnScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtxnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtxn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsFixedDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsFixedQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsFixedQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsFixedScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsFixedScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsIntDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsIntDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsIntQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsIntQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzsIntScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzsIntScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzs", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuFixedDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuFixedQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuFixedQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuFixedScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuFixedScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuIntDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuIntDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuIntQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuIntQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FcvtzuIntScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FcvtzuIntScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fcvtzu", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FdivDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FdivDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fdiv", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FdivQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FdivQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fdiv", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmpScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmpScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxnmvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxnmvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxnmv", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxpScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxpScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmaxp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmaxvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmaxvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fmaxv", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminnm", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmpScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmpScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminnmp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminnmvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminnmvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminnmv", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminpScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminpScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminpScQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminpScQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminp", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fminp", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FminvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FminvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fminv", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlaElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlaElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlaElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlaElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlaElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlaElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlaDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlaDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlaQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlaQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlsElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlsElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlsElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlsElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlsElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlsElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlsDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmlsQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmlsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmovDX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmovDX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("fmov", machInst, SimdMiscOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmovQX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmovQX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("fmov", machInst, SimdMiscOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FmulxElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FmulxElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("fmulx", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FnegDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FnegDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Neg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FnegQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FnegQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Neg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpeDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpeDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpeQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpeQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpeScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpeScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpsDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpsQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpsScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrecpxX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrecpxX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frecpx", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintaDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintaDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frinta", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintaQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintaQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frinta", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintiDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintiDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frinti", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintiQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintiQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frinti", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintmDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintmDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintm", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintmQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintmQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintm", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintnDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintnDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintnQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintnQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintn", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintpDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintp", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintpQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintp", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintxDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintxDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintx", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintxQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintxQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintx", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintzDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintzDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintz", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrintzQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrintzQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frintz", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrteDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrteDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrteQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrteQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrteScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrteScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("frsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrtsDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrtsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrtsQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrtsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FrsqrtsScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FrsqrtsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("frsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FsqrtDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FsqrtDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fsqrt", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FsqrtQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FsqrtQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("fsqrt", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FsubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FsubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class FsubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    FsubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("fsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class InsElemX : public DataX1Reg2ImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    InsElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm1,
                   uint64_t _imm2)
        : DataX1Reg2ImmOp("ins", machInst, SimdMiscOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class InsGprWX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    InsGprWX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ins", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class InsGprXX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    InsGprXX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ins", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlaElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlaElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlaElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlaElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlaDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlaDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlaQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlaQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlsElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlsElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlsElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlsElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlsDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MlsQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MlsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MoviDX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MoviDX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("movi", machInst, SimdMiscOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MoviQX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MoviQX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("movi", machInst, SimdMiscOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MulElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MulElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MulElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MulElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("mul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MulDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MulDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MulQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MulQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("mul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MvnDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MvnDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("mvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MvnQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MvnQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("mvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MvniDX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MvniDX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("mvni", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class MvniQX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    MvniQX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("mvni", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NegDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NegDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("neg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class NegQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NegQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("neg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrnDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrnDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("orn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrnQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrnQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("orn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrrImmDX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrrImmDX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("orr", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrrImmQX : public DataXImmOnlyOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrrImmQX(ExtMachInst machInst,
                   IntRegIndex _dest, uint64_t _imm)
        : DataXImmOnlyOp("orr", machInst, SimdAluOp,
                         _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrrDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrrDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("orr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class OrrQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    OrrQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("orr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class PmulDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    PmulDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("pmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class PmulQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    PmulQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("pmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class PmullX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    PmullX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("pmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Pmull2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Pmull2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("pmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class RaddhnX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    RaddhnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("raddhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Raddhn2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Raddhn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("raddhn2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class RbitDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    RbitDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rbit", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class RbitQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    RbitQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rbit", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev16DX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev16DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev16QX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev16QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev32DX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev32DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev32QX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev32QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev64DX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev64DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rev64QX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rev64QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("rev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class RshrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    RshrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("rshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rshrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rshrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("rshrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class RsubhnX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    RsubhnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("rsubhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Rsubhn2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Rsubhn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("rsubhn2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabaDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabaDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabaQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabaQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabalX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabalX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabal", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sabal2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sabal2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabal2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabdDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabdDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabdQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabdQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SabdlX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SabdlX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabdl", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sabdl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sabdl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sabdl2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SadalpDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SadalpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sadalp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SadalpQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SadalpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sadalp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saddl", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Saddl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Saddl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saddl2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlpDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("saddlp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlpQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("saddlp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("saddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("saddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddlvBQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddlvBQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("saddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SaddwX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SaddwX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saddw", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Saddw2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Saddw2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("saddw2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfFixedDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfFixedSQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfFixedSQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfFixedDQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfFixedDQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfFixedScSX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfFixedScSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfFixedScDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfFixedScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfIntDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfIntDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfIntSQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfIntSQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfIntDQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfIntDQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfIntScSX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfIntScSX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ScvtfIntScDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ScvtfIntScDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("scvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("shadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("shadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShlDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("shl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShlQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("shl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShllX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShllX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("shll", machInst, SimdShiftOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Shll2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Shll2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("shll", machInst, SimdShiftOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("shrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Shrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Shrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("shrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShsubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShsubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("shsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class ShsubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    ShsubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("shsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SliDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SliDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SliQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SliQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smaxp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smaxp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("smaxv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmaxvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmaxvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("smaxv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sminp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sminp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sminv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SminvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SminvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sminv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlalElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlalElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlalElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlalElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlalX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlalX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Smlal2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Smlal2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlslElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlslElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlslElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlslElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmlslX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmlslX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Smlsl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Smlsl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmovWX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmovWX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("smov", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmovXX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmovXX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("smov", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmullElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmullElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmullElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmullElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("smull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SmullX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SmullX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Smull2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Smull2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("smull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqabsDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqabsDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqabsQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqabsQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqabsScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqabsScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqaddScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqaddScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlalElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlalElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlalElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlalElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlalElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlalElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlalX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlalX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqdmlal2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqdmlal2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlalScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlalScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlslElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlslElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlslElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlslElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlslElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlslElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlslX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlslX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqdmlsl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqdmlsl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmlslScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmlslScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmulhScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmulhScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmullElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmullElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmullElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmullElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmullElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmullElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmullX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmullX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqdmull2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqdmull2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqdmullScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqdmullScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqnegDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqnegDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqnegQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqnegQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqnegScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqnegScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhElemDX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhElemDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhElemQX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhElemQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhElemScX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhElemScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrdmulhScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrdmulhScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshlScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshlScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqrshrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqrshrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshrnScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshrnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshrunX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshrunX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqrshrun2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqrshrun2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqrshrunScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqrshrunScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlImmDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlImmDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlImmQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlImmQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlImmScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlImmScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshlScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshlScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshluDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshluDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshluQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshluQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshluScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshluScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshlu", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqshrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqshrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshrnScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshrnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshrunX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshrunX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqshrun2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqshrun2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqshrunScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqshrunScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqsubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqsubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqsubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqsubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqsubScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqsubScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqxtnX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqxtnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqxtn2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqxtn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqxtnScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqxtnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqxtunX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqxtunX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sqxtun2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sqxtun2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SqxtunScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SqxtunScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("sqxtun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrhaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrhaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("srhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrhaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrhaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("srhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SriDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SriDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SriQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SriQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("srshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("srshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrshrDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrshrDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("srshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrshrQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrshrQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("srshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrsraDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrsraDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("srsra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SrsraQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SrsraQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("srsra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SshllX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SshllX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sshll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Sshll2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Sshll2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sshll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SshrDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SshrDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SshrQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SshrQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("sshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SsraDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SsraDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ssra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SsraQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SsraQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ssra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SsublX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SsublX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ssubl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Ssubl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Ssubl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ssubl2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SsubwX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SsubwX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ssubw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Ssubw2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Ssubw2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ssubw2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("sub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SubhnX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SubhnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("subhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Subhn2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Subhn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("subhn2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SuqaddDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SuqaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("suqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SuqaddQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SuqaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("suqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class SuqaddScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    SuqaddScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("suqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl1DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl1DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl1QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl1QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl2DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl2DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl2QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl2QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl3DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl3DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl3QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl3QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl4DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl4DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbl4QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbl4QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx1DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx1DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx1QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx1QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx2DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx2DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx2QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx2QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx3DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx3DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx3QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx3QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx4DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx4DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Tbx4QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Tbx4QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("tbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Trn1DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Trn1DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("trn1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Trn1QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Trn1QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("trn1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Trn2DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Trn2DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("trn2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Trn2QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Trn2QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("trn2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabaDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabaDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabaQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabaQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabalX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabalX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabal", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uabal2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uabal2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabal2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabdDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabdDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabdQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabdQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UabdlX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UabdlX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabdl", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uabdl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uabdl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uabdl2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UadalpDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UadalpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uadalp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UadalpQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UadalpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uadalp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaddl", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uaddl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uaddl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaddl2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlpDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uaddlp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlpQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uaddlp", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uaddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uaddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddlvBQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddlvBQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uaddlv", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UaddwX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UaddwX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaddw", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uaddw2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uaddw2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uaddw2", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfFixedDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfFixedDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfFixedQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfFixedQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfFixedScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfFixedScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfIntDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfIntDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfIntQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfIntQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UcvtfIntScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UcvtfIntScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("ucvtf", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UhaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UhaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UhaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UhaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UhsubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UhsubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UhsubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UhsubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umaxp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umaxp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("umaxv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmaxvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmaxvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("umaxv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminpDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminpDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uminp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminpQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminpQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uminp", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminvDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminvDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uminv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UminvQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UminvQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uminv", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlalElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlalElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlalElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlalElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlalX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlalX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Umlal2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Umlal2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlslElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlslElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlslElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlslElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmlslX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmlslX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Umlsl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Umlsl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmovWX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmovWX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("umov", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmovXX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmovXX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("umov", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmullElemX : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmullElemX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmullElem2X : public DataX2RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmullElem2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : DataX2RegImmOp("umull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UmullX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UmullX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Umull2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Umull2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("umull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqaddScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqaddScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqrshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqrshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqrshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqrshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqrshlScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqrshlScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqrshrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqrshrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uqrshrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uqrshrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqrshrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqrshrnScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqrshrnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlImmDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlImmDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlImmQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlImmQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlImmScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlImmScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshlScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshlScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshrnX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshrnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uqshrn2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uqshrn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshrn2", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqshrnScX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqshrnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("uqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqsubDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqsubDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqsubQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqsubQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqsubScX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqsubScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("uqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqxtnX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqxtnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uqxtn2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uqxtn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UqxtnScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UqxtnScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("uqxtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrecpeDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrecpeDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("urecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrecpeQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrecpeQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("urecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrhaddDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrhaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("urhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrhaddQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrhaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("urhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("urshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("urshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrshrDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrshrDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("urshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrshrQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrshrQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("urshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrsqrteDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrsqrteDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("ursqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrsqrteQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrsqrteQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("ursqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrsraDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrsraDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ursra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UrsraQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UrsraQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ursra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UshlDX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UshlDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ushl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UshlQX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UshlQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("ushl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UshllX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UshllX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ushll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Ushll2X : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Ushll2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ushll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UshrDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UshrDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ushr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UshrQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UshrQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("ushr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsqaddDX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsqaddDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("usqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsqaddQX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsqaddQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("usqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsqaddScX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsqaddScX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("usqadd", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsraDX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsraDX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("usra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsraQX : public DataX1RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsraQX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : DataX1RegImmOp("usra", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsublX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsublX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("usubl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Usubl2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Usubl2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("usubl2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class UsubwX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    UsubwX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("usubw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Usubw2X : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Usubw2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("usubw2", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uzp1DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uzp1DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("Uzp1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uzp1QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uzp1QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("Uzp1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uzp2DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uzp2DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("Uzp2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Uzp2QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Uzp2QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("Uzp2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class XtnX : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    XtnX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Xtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Xtn2X : public DataX1RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Xtn2X(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : DataX1RegOp("Xtn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Zip1DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Zip1DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("zip1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Zip1QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Zip1QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("zip1", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Zip2DX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Zip2DX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("zip2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

template <class _Element>
class Zip2QX : public DataX2RegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Zip2QX(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : DataX2RegOp("zip2", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    
        Fault execute(ExecContext *, Trace::InstRecord *) const;

};

    class MicroNeonLoad64 : public MicroNeonMemOp
    {
      protected:
        // True if the base register is SP (used for SP alignment checking)
        bool baseIsSP;
        // Access size in bytes
        uint8_t accSize;
        // Vector element size (0 -> 8-bit, 1 -> 16-bit, 2 -> 32-bit,
        // 3 -> 64-bit)
        uint8_t eSize;

      public:
        MicroNeonLoad64(ExtMachInst machInst, RegIndex _dest, RegIndex _ura,
                       uint32_t _imm, unsigned extraMemFlags, bool _baseIsSP,
                       uint8_t _accSize, uint8_t _eSize)
            : MicroNeonMemOp("mem_neon_uopld", machInst, MemReadOp, _dest,
                             _ura, _imm),
            baseIsSP(_baseIsSP), accSize(_accSize), eSize(_eSize)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroNeonStore64 : public MicroNeonMemOp
    {
      protected:
        // True if the base register is SP (used for SP alignment checking)
        bool baseIsSP;
        // Access size in bytes
        uint8_t accSize;
        // Vector element size (0 -> 8-bit, 1 -> 16-bit, 2 -> 32-bit,
        // 3 -> 64-bit)
        uint8_t eSize;

      public:
        MicroNeonStore64(ExtMachInst machInst, RegIndex _dest, RegIndex _ura,
                       uint32_t _imm, unsigned extraMemFlags, bool _baseIsSP,
                       uint8_t _accSize, uint8_t _eSize)
            : MicroNeonMemOp("mem_neon_uopst", machInst, MemWriteOp, _dest,
                             _ura, _imm),
            baseIsSP(_baseIsSP), accSize(_accSize), eSize(_eSize)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        
    Fault initiateAcc(ExecContext *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  ExecContext *, Trace::InstRecord *) const;

    };

    class MicroDeintNeon64_1Reg : public MicroNeonMixOp64
    {
      public:
        MicroDeintNeon64_1Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroDeintNeon64_2Reg : public MicroNeonMixOp64
    {
      public:
        MicroDeintNeon64_2Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroDeintNeon64_3Reg : public MicroNeonMixOp64
    {
      public:
        MicroDeintNeon64_3Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroDeintNeon64_4Reg : public MicroNeonMixOp64
    {
      public:
        MicroDeintNeon64_4Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("deint_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroIntNeon64_1Reg : public MicroNeonMixOp64
    {
      public:
        MicroIntNeon64_1Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroIntNeon64_2Reg : public MicroNeonMixOp64
    {
      public:
        MicroIntNeon64_2Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroIntNeon64_3Reg : public MicroNeonMixOp64
    {
      public:
        MicroIntNeon64_3Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroIntNeon64_4Reg : public MicroNeonMixOp64
    {
      public:
        MicroIntNeon64_4Reg(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _numRegs,
                       uint8_t _step) :
            MicroNeonMixOp64("int_neon_uop", machInst, No_OpClass,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _numRegs, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroUnpackNeon64 : public MicroNeonMixLaneOp64
    {
      public:
        MicroUnpackNeon64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _lane, uint8_t _step,
                       bool _replicate = false) :
            MicroNeonMixLaneOp64("unpack_neon_uop", machInst, FloatAddOp,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _lane, _step, _replicate)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+1)%32) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class MicroPackNeon64 : public MicroNeonMixLaneOp64
    {
      public:
        MicroPackNeon64(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _eSize, uint8_t _dataSize,
                       uint8_t _numStructElems, uint8_t _lane, uint8_t _step,
                       bool _replicate = false) :
            MicroNeonMixLaneOp64("pack_neon_uop", machInst, FloatAddOp,
                           _dest, _op1, _eSize, _dataSize, _numStructElems,
                           _lane, _step, _replicate)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+0)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+1)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+2)%32) * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((((op1+3)%32) * 4) + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+0)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((((dest+1)) * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;

    };

    class VldMult64 : public VldMultOp64
    {
      public:
        // Constructor
        VldMult64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t numRegs, bool wb);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

    };

    class VstMult64 : public VstMultOp64
    {
      public:
        // Constructor
        VstMult64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t numRegs, bool wb);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

    };

    class VldSingle64 : public VldSingleOp64
    {
      public:
        // Constructor
        VldSingle64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t index, bool wb,
                       bool replicate = false);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

    };

    class VstSingle64 : public VstSingleOp64
    {
      public:
        // Constructor
        VstSingle64(ExtMachInst machInst, RegIndex rn, RegIndex vd,
                       RegIndex rm, uint8_t eSize, uint8_t dataSize,
                       uint8_t numStructElems, uint8_t index, bool wb,
                       bool replicate = false);
        
Fault execute(ExecContext *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

    };

    uint64_t join32to64(uint32_t r1, uint32_t r0);
    
        /**
         * Static instruction class for "arm".
         */
        class Arm : public PredOp
        {
          public:
                /// Constructor.
                Arm(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesce".
         */
        class Quiesce : public PredOp
        {
          public:
                /// Constructor.
                Quiesce(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceNs".
         */
        class QuiesceNs : public PredOp
        {
          public:
                /// Constructor.
                QuiesceNs(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceNs".
         */
        class QuiesceNs64 : public PredOp
        {
          public:
                /// Constructor.
                QuiesceNs64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceCycles".
         */
        class QuiesceCycles : public PredOp
        {
          public:
                /// Constructor.
                QuiesceCycles(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceCycles".
         */
        class QuiesceCycles64 : public PredOp
        {
          public:
                /// Constructor.
                QuiesceCycles64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceTime".
         */
        class QuiesceTime : public PredOp
        {
          public:
                /// Constructor.
                QuiesceTime(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceTime".
         */
        class QuiesceTime64 : public PredOp
        {
          public:
                /// Constructor.
                QuiesceTime64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "rpns".
         */
        class Rpns : public PredOp
        {
          public:
                /// Constructor.
                Rpns(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "rpns".
         */
        class Rpns64 : public PredOp
        {
          public:
                /// Constructor.
                Rpns64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wakeCPU".
         */
        class WakeCPU : public PredOp
        {
          public:
                /// Constructor.
                WakeCPU(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wakeCPU".
         */
        class WakeCPU64 : public PredOp
        {
          public:
                /// Constructor.
                WakeCPU64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_ivlb".
         */
        class Deprecated_ivlb : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_ivlb(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_ivle".
         */
        class Deprecated_ivle : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_ivle(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_exit".
         */
        class Deprecated_exit : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_exit(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5exit".
         */
        class M5exit : public PredOp
        {
          public:
                /// Constructor.
                M5exit(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5fail".
         */
        class M5fail : public PredOp
        {
          public:
                /// Constructor.
                M5fail(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5exit".
         */
        class M5exit64 : public PredOp
        {
          public:
                /// Constructor.
                M5exit64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "loadsymbol".
         */
        class Loadsymbol : public PredOp
        {
          public:
                /// Constructor.
                Loadsymbol(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "initparam".
         */
        class Initparam : public PredOp
        {
          public:
                /// Constructor.
                Initparam(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "initparam".
         */
        class Initparam64 : public PredOp
        {
          public:
                /// Constructor.
                Initparam64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "resetstats".
         */
        class Resetstats : public PredOp
        {
          public:
                /// Constructor.
                Resetstats(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "resetstats".
         */
        class Resetstats64 : public PredOp
        {
          public:
                /// Constructor.
                Resetstats64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpstats".
         */
        class Dumpstats : public PredOp
        {
          public:
                /// Constructor.
                Dumpstats(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpstats".
         */
        class Dumpstats64 : public PredOp
        {
          public:
                /// Constructor.
                Dumpstats64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpresetstats".
         */
        class Dumpresetstats : public PredOp
        {
          public:
                /// Constructor.
                Dumpresetstats(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpresetstats".
         */
        class Dumpresetstats64 : public PredOp
        {
          public:
                /// Constructor.
                Dumpresetstats64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5checkpoint".
         */
        class M5checkpoint : public PredOp
        {
          public:
                /// Constructor.
                M5checkpoint(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5checkpoint".
         */
        class M5checkpoint64 : public PredOp
        {
          public:
                /// Constructor.
                M5checkpoint64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5readfile".
         */
        class M5readfile : public PredOp
        {
          public:
                /// Constructor.
                M5readfile(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5readfile".
         */
        class M5readfile64 : public PredOp
        {
          public:
                /// Constructor.
                M5readfile64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5writefile".
         */
        class M5writefile : public PredOp
        {
          public:
                /// Constructor.
                M5writefile(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5writefile".
         */
        class M5writefile64 : public PredOp
        {
          public:
                /// Constructor.
                M5writefile64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5break".
         */
        class M5break : public PredOp
        {
          public:
                /// Constructor.
                M5break(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5switchcpu".
         */
        class M5switchcpu : public PredOp
        {
          public:
                /// Constructor.
                M5switchcpu(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5addsymbol".
         */
        class M5addsymbol : public PredOp
        {
          public:
                /// Constructor.
                M5addsymbol(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5addsymbol".
         */
        class M5addsymbol64 : public PredOp
        {
          public:
                /// Constructor.
                M5addsymbol64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5panic".
         */
        class M5panic : public PredOp
        {
          public:
                /// Constructor.
                M5panic(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workbegin".
         */
        class M5workbegin : public PredOp
        {
          public:
                /// Constructor.
                M5workbegin(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workbegin".
         */
        class M5workbegin64 : public PredOp
        {
          public:
                /// Constructor.
                M5workbegin64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workend".
         */
        class M5workend : public PredOp
        {
          public:
                /// Constructor.
                M5workend(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workend".
         */
        class M5workend64 : public PredOp
        {
          public:
                /// Constructor.
                M5workend64(ExtMachInst machInst);
                
        Fault execute(ExecContext *, Trace::InstRecord *) const;

        };

namespace Aarch64
{
    StaticInstPtr decodeDataProcImm(ExtMachInst machInst);
    StaticInstPtr decodeBranchExcSys(ExtMachInst machInst);
    StaticInstPtr decodeLoadsStores(ExtMachInst machInst);
    StaticInstPtr decodeDataProcReg(ExtMachInst machInst);

    StaticInstPtr decodeFpAdvSIMD(ExtMachInst machInst);
    StaticInstPtr decodeFp(ExtMachInst machInst);
    StaticInstPtr decodeAdvSIMD(ExtMachInst machInst);
    StaticInstPtr decodeAdvSIMDScalar(ExtMachInst machInst);

    StaticInstPtr decodeGem5Ops(ExtMachInst machInst);
}

namespace Aarch64
{
    // AdvSIMD three same
    StaticInstPtr decodeNeon3Same(ExtMachInst machInst);
    // AdvSIMD three different
    StaticInstPtr decodeNeon3Diff(ExtMachInst machInst);
    // AdvSIMD two-reg misc
    StaticInstPtr decodeNeon2RegMisc(ExtMachInst machInst);
    // AdvSIMD across lanes
    StaticInstPtr decodeNeonAcrossLanes(ExtMachInst machInst);
    // AdvSIMD copy
    StaticInstPtr decodeNeonCopy(ExtMachInst machInst);
    // AdvSIMD vector x indexed element
    StaticInstPtr decodeNeonIndexedElem(ExtMachInst machInst);
    // AdvSIMD modified immediate
    StaticInstPtr decodeNeonModImm(ExtMachInst machInst);
    // AdvSIMD shift by immediate
    StaticInstPtr decodeNeonShiftByImm(ExtMachInst machInst);
    // AdvSIMD TBL/TBX
    StaticInstPtr decodeNeonTblTbx(ExtMachInst machInst);
    // AdvSIMD ZIP/UZP/TRN
    StaticInstPtr decodeNeonZipUzpTrn(ExtMachInst machInst);
    // AdvSIMD EXT
    StaticInstPtr decodeNeonExt(ExtMachInst machInst);

    // AdvSIMD scalar three same
    StaticInstPtr decodeNeonSc3Same(ExtMachInst machInst);
    // AdvSIMD scalar three different
    StaticInstPtr decodeNeonSc3Diff(ExtMachInst machInst);
    // AdvSIMD scalar two-reg misc
    StaticInstPtr decodeNeonSc2RegMisc(ExtMachInst machInst);
    // AdvSIMD scalar pairwise
    StaticInstPtr decodeNeonScPwise(ExtMachInst machInst);
    // AdvSIMD scalar copy
    StaticInstPtr decodeNeonScCopy(ExtMachInst machInst);
    // AdvSIMD scalar x indexed element
    StaticInstPtr decodeNeonScIndexedElem(ExtMachInst machInst);
    // AdvSIMD scalar shift by immediate
    StaticInstPtr decodeNeonScShiftByImm(ExtMachInst machInst);

    // AdvSIMD load/store
    StaticInstPtr decodeNeonMem(ExtMachInst machInst);
}


    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMemInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex ra,
                   const uint32_t imm, const unsigned extraMemFlags)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, ra, imm, extraMemFlags);
          case 1:
            return new Base<uint16_t>(machInst, dest, ra, imm, extraMemFlags);
          case 2:
            return new Base<uint32_t>(machInst, dest, ra, imm, extraMemFlags);
          case 3:
            return new Base<uint64_t>(machInst, dest, ra, imm, extraMemFlags);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }

    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMixInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex op1,
                   const uint32_t step)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, step);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, step);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, step);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, step);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }


    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst);
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst);
    
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst);
    
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst);
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst);
    
    StaticInstPtr decodeMcrMrc14(ExtMachInst machInst);
    StaticInstPtr decodeMcrMrc15(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrrMrrc15(ExtMachInst machInst);
    
    /**
     * Static instruction class for Breakpoint (illegal) instructions.
     * These cause simulator termination if they are executed in a
     * non-speculative mode.  This is a leaf class.
     */
    class Breakpoint : public ArmStaticInst
    {
      public:
        /// Constructor
        Breakpoint(ExtMachInst _machInst)
            : ArmStaticInst("Breakpoint", _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
        Fault execute(ExecContext *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// ArmERet::armERet(([], {}))

// Breakpoint::bkpt(([], {}))

// ArmSmcHyp::armSmcHyp(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Mcrr15::Mcrr15(([], {}))

// Mrrc15::Mrrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Aarch64::aarch64(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// Mcrr15::Mcrr15(([], {}))

// WarnUnimpl::mcrr(([], {}))

// Mrrc15::Mrrc15(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// DecoderFault::decoderFault(([], {}))
