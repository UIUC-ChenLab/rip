<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Pin 3.0 User Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Pin 3.0 User Guide</h1>
<p>
======================================================================================== <h2><a class="anchor" name="INTRO">
Introduction</a></h2>
========================================================================================<p>
Pin is a tool for the instrumentation of programs. It supports the Android*, Linux*, OS X* and Windows* operating systems and executables for the IA-32, Intel(R) 64 and Intel(R) Many Integrated Core architectures.<p>
Pin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.<p>
Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.<p>
Pin includes the source code for a large number of example instrumentation tools like basic block profilers, cache simulators, instruction trace generators, etc. It is easy to derive new tools using the examples as a template.<p>
Tutorial Sections<ul>
<li><a class="el" href="index.html#INSTRUMENTING">How to Instrument With Pin</a></li><li><a class="el" href="index.html#EXAMPLES">Examples</a></li><li><a class="el" href="index.html#CALLBACK">Callbacks</a></li><li><a class="el" href="index.html#MODIFYING">Modifying Application Instructions</a></li><li><a class="el" href="index.html#APPDEBUG">The Pin Advanced Debugging Extensions</a></li><li><a class="el" href="index.html#EX">Applying a Pintool to an Application</a></li><li><a class="el" href="index.html#DEBUGGING">Debugging Tips for Debugging a Pintool</a></li><li><a class="el" href="index.html#LOGGING">Recording Messages from a Pintool</a></li><li><a class="el" href="index.html#PERFORMANCE">Performance Considerations</a></li><li><a class="el" href="index.html#MEMORY">Memory management</a></li><li><a class="el" href="index.html#RESTRICTIONS">PinTools Information and Restrictions</a></li><li><a class="el" href="index.html#WINDOWS_TOOLS">Building Tools on windows</a></li><li><a class="el" href="index.html#WINLIBRARIES">Libraries for Windows</a></li><li><a class="el" href="index.html#LIBRARIES">Libraries for Linux</a></li><li><a class="el" href="index.html#INSTALLATION">Installation</a></li><li><a class="el" href="index.html#XEONPHIUSAGE">Usage Instructions for Intel(R) Xeon Phi(TM)</a></li><li><a class="el" href="index.html#BUILDINGTOOLS">Building Your Own Tool</a></li><li><a class="el" href="index.html#MAKEFILES">Pin's makefile Infrastructure</a></li><li><a class="el" href="index.html#FEEDBACK">Feedback</a></li><li><a class="el" href="index.html#LEGAL">Disclaimer and Legal Information</a></li></ul>
<p>
Reference Sections<ul>
<li><a class="el" href="group__API__REF.html">Pin API reference</a></li><li><a class="el" href="group__KNOBS.html">Pin Command Line Switches</a></li><li><a class="el" href="group__INSTLIB.html">Instrumentation Library</a></li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="INSTRUMENTING">
How to Instrument with Pin</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#Pin">Pin</a></li><li><a class="el" href="index.html#Pintools">Pintools</a></li><li><a class="el" href="index.html#Observations">Observations</a></li><li><a class="el" href="index.html#GRAN">Instrumentation Granularity</a></li><li><a class="el" href="index.html#JIT_API">Managed platforms support</a></li><li><a class="el" href="index.html#SYMBOLS">Symbols</a></li><li><a class="el" href="index.html#FP">Floating Point Support in Analysis Routines</a></li><li><a class="el" href="index.html#MT">Instrumenting Multi-threaded Applications</a></li><li><a class="el" href="index.html#Deadlock">Avoiding Deadlocks in Multi-threaded Applications</a></li></ul>
<h3><a class="anchor" name="Pin">
Pin</a></h3>
The best way to think about Pin is as a "just in time" (JIT) compiler. The input to this compiler is not bytecode, however, but a regular executable. Pin intercepts the execution of the first instruction of the executable and generates ("compiles") new code for the straight line code sequence starting at this instruction. It then transfers control to the generated sequence. The generated code sequence is almost identical to the original one, but Pin ensures that it regains control when a branch exits the sequence. After regaining control, Pin generates more code for the branch target and continues execution. Pin makes this efficient by keeping all of the generated code in memory so it can be reused and directly branching from one sequence to another.<p>
In JIT mode, the only code ever executed is the generated code. The original code is only used for reference. When generating code, Pin gives the user an opportunity to inject their own code (instrumentation).<p>
Pin instruments all instructions that are actually excuted. It does not matter in what section they reside. Although there are some exceptions for conditional branches, generally speaking, if an instruction is never executed then it will not be instrumented.<h3><a class="anchor" name="Pintools">
Pintools</a></h3>
Conceptually, instrumentation consists of two components:<p>
<ul>
<li>A mechanism that decides where and what code is inserted</li></ul>
<p>
<ul>
<li>The code to execute at insertion points</li></ul>
<p>
These two components are <em>instrumentation</em> and <em>analysis</em> code. Both components live in a single executable, a <em>Pintool</em>. Pintools can be thought of as plugins that can modify the code generation process inside Pin.<p>
The Pintool registers instrumentation callback routines with Pin that are called from Pin whenever new code needs to be generated. This instrumentation callback routine represents the instrumentation component. It inspects the code to be generated, investigates its static properties, and decides if and where to inject calls to analysis functions.<p>
The analysis function gathers data about the application. Pin makes sure that the integer and floating point register state is saved and restored as necessary and allow arguments to be passed to the functions.<p>
The Pintool can also register notification callback routines for events such as thread creation or forking. These callbacks are generally used to gather data or tool initialization or clean up.<h3><a class="anchor" name="Observations">
Observations</a></h3>
Since a Pintool works like a plugin, it must run in the same address space as Pin and the executable to be instrumented. Hence the Pintool has access to all of the executable's data. It also shares file descriptors and other process information with the executable.<p>
Pin and the Pintool control a program starting with the very first instruction. For executables compiled with shared libraries this implies that the execution of the dynamic loader and all shared libraries will be visible to the Pintool.<p>
When writing tools, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.<h3><a class="anchor" name="GRAN">
Instrumentation Granularity</a></h3>
As described above, Pin's instrumentation is "just in time" (JIT). Instrumentation occurs immediately before a code sequence is executed for the first time. We call this mode of operation <em> trace instrumentation </em>.<p>
Trace instrumentation lets the Pintool inspect and instrument an executable one trace at a time. Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target. Pin breaks the trace into basic blocks, <em>BBLs</em>. A BBL is a single entrance, single exit sequence of instructions. Branches to the middle of a bbl begin a new trace and hence a new BBL. It is often possible to insert a single analysis call for a BBL, instead of one analysis call for every instruction. Reducing the number of analysis calls makes instrumentation more efficient. Trace instrumentation utilizes the <a class="el" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a> API call.<p>
Note, though, that since Pin is discovering the control flow of the program dynamically as it executes, Pin's BBL can be different from the classical definition of a BBL which you will find in a compiler textbook. For instance, consider the code generated for the body of a switch statement like this <div class="fragment"><pre class="fragment">    <span class="keywordflow">switch</span>(i)
    {
        <span class="keywordflow">case</span> 4: total++;
        <span class="keywordflow">case</span> 3: total++;
        <span class="keywordflow">case</span> 2: total++;
        <span class="keywordflow">case</span> 1: total++;
        <span class="keywordflow">case</span> 0:
        <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
    }
</pre></div><p>
It will generate instructions something like this (for the IA-32 architecture) <div class="fragment"><pre class="fragment">.L7:
        addl    $1, -4(%ebp)
.L6:
        addl    $1, -4(%ebp)
.L5:
        addl    $1, -4(%ebp)
.L4:
        addl    $1, -4(%ebp)
</pre></div><p>
In terms of classical basic blocks, each addl instruction is in a single instruction basic block. However as the different switch cases are executed, Pin will generate BBLs which contain all four instructions (when the .L7 case is entered), three instructions (when the .L6 case is entered), and so on. This means that counting Pin BBLs is unlikely to give the count you would expect if you thought that Pin BBLs were the same as the basic blocks in the text book. Here, for instance, if the code branches to .L7 you will count one Pin BBL, but there are four classical basic blocks executed.<p>
Pin also breaks BBLs on some other instructions which may be unexpected, for instance cpuid, popf and REP prefixed instructions all end traces and therefore BBLs. Since REP prefixed instructions are treated as implicit loops, if a REP prefixed instruction iterates more than once, iterations after the first will cause a single instruction BBL to be generated, so in this case you would see more basic blocks executed than you might expect.<p>
As a convenience for Pintool writers, Pin also offers an <em> instruction instrumentation </em> mode which lets the tool inspect and instrument an executable a single instruction at a time. This is essentially identical to trace instrumentation where the Pintool writer has been freed from the responsibilty of iterating over the instructions inside a trace. As decribed under trace instrumentation, certain BBLs and the instructions inside of them may be generated (and hence instrumented) multiple times. Instruction instrumentation utilizes the <a class="el" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a> API call.<p>
Sometimes, however, it can be useful to look at different granularity than a trace. For this purpose Pin offers two additional modes: image and routine instrumentation. These modes are implemented by "caching" instrumentation requests and hence incur a space overhead, these modes are aslo referred to as ahead-of-time instrumentation.<p>
Image instrumentation lets the Pintool inspect and instrument an entire image, IMG, when it is first loaded. A Pintool can walk the sections, SEC, of the image, the routines, RTN, of a section, and the instructions, INS of a routine. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Image instrumentation utilizes the <a class="el" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a> API call. Image instrumentation depends on symbol information to determine routine boundaries hence <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>.<p>
Routine instrumentation lets the Pintool inspect and instrument an entire routine when the image it is contained in is first loaded. A Pintool can walk the instructions of a routine. There is not enough information available to break the instructions into BBLs. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Routine instrumentation is provided as a convenience for Pintool writers, as an alternative to walking the sections and routines of the image during the Image instrumentation, as described in the previous paragraph.<p>
Routine instrumentation utilizes the <a class="el" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a> API call. Instrumentation of routine exits does not work reliably in the presence of tail calls or when return instructions cannot reliably be detected.<p>
Note that in both Image and Routine instrumentation, it is not possible to know whether or not a routine will actually be executed (since these instrumentations are done at image load time). It is possible to walk the instructions only of routines that are executed, in the Trace or Instruction instrumentation routines, by identifying instructions that are the start of routines. See the tool Tests/parse_executed_rtns.cpp.<h3><a class="anchor" name="JIT_API">
Managed platforms support</a></h3>
Pin supports all executables including the managed binaries. From Pin point of view managed binary is one more kind of a self-modifying program. There is a way to cause Pin to differentiate the just-in-time compiled code (Jitted code) from all other dynamically generated code and associate Jitted code with appropriate managed functions. To get this functionality, the just-in-time compiler (Jitter) of the running managed platform should support <a href="http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-17D7238B-DD19-45DB-B5E0-D9B344D1BE96.htm">Jit Profiling API</a><p>
The following capabilities are supported:<ul>
<li><a class="el" href="group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b">RTN_IsDynamic()</a> API is used to indentify dynamically created code. A routine can be marked as dynamically created using Jit Profiling API only.</li><li>A Pin tool can instrument Jitted routines using <a class="el" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a> API See the examples <a class="el" href="index.html#JitApiTools">Managed platforms support</a> for more information.</li></ul>
<p>
Following conditions must be satisfied to get the managed platforms support: <ul>
<li>
Set INTEL_JIT_PROFILER32 and INTEL_JIT_PROFILER64 environment variables to appropriate pinjitprofiling dynamic library <ol>
<li>
For Windows:<p>
<div class="fragment"><pre class="fragment">            set INTEL_JIT_PROFILER32=&lt;The Pin kit full path&gt;\ia32\bin\pinjitprofiling.dll
            set INTEL_JIT_PROFILER64=&lt;The Pin kit full path&gt;\intel64\bin\pinjitprofiling.dll
</pre></div><p>
</li>
<li>
For Linux:<p>
<div class="fragment"><pre class="fragment">            setenv INTEL_JIT_PROFILER32 &lt;The Pin kit full path&gt;/ia32/bin/libpinjitprofiling.so
            setenv INTEL_JIT_PROFILER64 &lt;The Pin kit full path&gt;/intel64/bin/libpinjitprofiling.so
</pre></div><p>
</li>
</ol>
<p>
</li>
<li>
Add the knob support_jit_api to the Pin command line as Pin tool option:<p>
<div class="fragment"><pre class="fragment">    &lt;Pin executable&gt; &lt;pin options&gt; -t &lt;Pin tool&gt; -support_jit_api &lt;Other Pin tool options&gt; -- &lt;Test application&gt; &lt;Test application options&gt;
</pre></div><p>
</li>
</ul>
<h3><a class="anchor" name="SYMBOLS">
Symbols</a></h3>
Pin provides access to function names using the symbol object (SYM). Symbol objects only provide information about the function symbols in the application. Information about other types of symbols (e.g. data symbols), must be obtained independently by the tool.<p>
On Windows, you can use dbghelp.dll for this. Note that using dbghelp.dll in an instrumented process is not safe and can cause dead-locks in some cases. A possible solution is to find symbols using a different non-instrumented process.<p>
On Linux, libelf.so or libdwarf.so can be used to access symbol information.<p>
<a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> must be called to access functions by name. See <a class="el" href="group__SYM__BASIC__API.html">SYM: Symbol Object</a> for more information.<h3><a class="anchor" name="FP">
Floating Point Support in Analysis Routines</a></h3>
Pin takes care of maintaining the application's floating point state accross analysis routines.<p>
IARG_REG_VALUE cannot be used to pass floating point register values as arguments to analysis routines.<h3><a class="anchor" name="MT">
Instrumenting Multi-threaded Applications</a></h3>
Instrumenting a multi-threaded program requires that the tool be thread safe - access to global storage must be coordinated with other threads. Pin tries to provide a conventional C++ program environment for tools, but it is not possible to use the standard library interfaces to manage threads in a Pintool. For example, Linux tools cannot use the pthreads library and Windows tools should not use the Win32 API's to manage threads. Instead, Pin provides its own locking and thread management API's, which the Pintool should use. (See <a class="el" href="group__LOCK.html">LOCK: Locking Primitives</a> and <a class="el" href="group__PIN__THREAD__API.html">Pin Thread API</a>.)<p>
Pintools do not need to add explicit locking to instrumentation routines because Pin calls these routines while holding an internal lock called the VM lock. However, Pin does execute analysis and replacement functions in parallel, so Pintools may need to add locking to these routines if they access global data.<p>
Pintools on Linux also need to take care when calling standard C or C++ library routines from analysis or replacement functions because the C and C++ libraries linked into Pintools are <b>not</b> thread-safe. Some simple C / C++ routines are safe to call without locking, because their implementations are inherently thread-safe, however, Pin does not attempt to provide a list of safe routines. If you are in doubt, you should add locking around calls to library functions. In particular, the "errno" value is not multi-thread safe, so tools that use this should provide their own locking. Note that these restrictions only exist on the Unix platforms, as the library routines on Windows are thread safe.<p>
Pin provides call-backs when each thread starts and ends (see PIN_AddThreadStartFunction and PIN_AddThreadFiniFunction). These provide a convenient place for a Pintool to allocate and manipulate thread local data and store it on a thread's local storage.<p>
Pin also provides an analysis routine argument (IARG_THREAD_ID), which passes a Pin-specific thread ID for the calling thread. This ID is different from the O/S system thread ID, and is a small number starting at 0, which can be used as an index to an array of thread data or as the locking value to Pin user locks. See the example <a class="el" href="index.html#MallocMT">Instrumenting Threaded Applications</a> for more information.<p>
In addition to the Pin thread ID, the Pin API provides an efficient thread local storage (TLS), with the option to allocate a new TLS key and associate it with a given data destruction function. Any thread of the process can store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. See the example <a class="el" href="index.html#InscountTLS">Using TLS</a> for more information.<p>
False sharing occurs when multiple threads access different parts of the same cache line and at least one of them is a write. To maintain memory coherency, the computer must copy the memory from one CPU's cache to another, even though data is not truly shared. False sharing can usually be avoided by padding critical data structures to the size of a cache line, or by rearranging the data layout of structures. See the example <a class="el" href="index.html#InscountTLS">Using TLS</a> for more information.<h3><a class="anchor" name="Deadlock">
Avoiding Deadlocks in Multi-threaded Applications</a></h3>
Since Pin, the tool, and the application may each acquire and release locks, Pin tool developers must take care to avoid deadlocks with either the application or Pin. Deadlocks generally occur when two threads acquire the same locks in a different order. For example, thread A acquires lock L1 and then acquires lock L2, while thread B acquires lock L2 and then acquires lock L1. This will lead to a deadlock if thread A holds lock L1 and waits for L2 while thread B holds lock L2 and waits for L1. To avoid such deadlocks, Pin imposes a hierarchy on the order in which locks must be acquired. Pin generally acquires its own internal locks before the tool acquires any lock (e.g. via <a class="el" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock()</a>). Additionally, we assume that the application may acquire locks at the top of this hierarchy (i.e. before Pin acquires its internal locks). The following diagram illustrates the hierarchy: <div class="fragment"><pre class="fragment">Application locks -&gt; Pin internal locks -&gt; Tool locks
</pre></div> Pin tool developers should design their Pin tools such that they never break this lock hierarchy, and they can do so by following these basic guidelines:<ul>
<li>If the tool acquires any locks from within a Pin call-back, it must release those locks before returning from that call-back. Holding a lock across Pin call-backs violates the hierarchy with respect to the Pin internal locks.</li><li>If the tool acquires any locks from within an analysis routine, it must release those locks before returning from the analysis routine. Holding a lock across Pin analysis routines violates the hierarchy with respect to Pin internal locks and other locks used by the instrumented application itself.</li><li>If the tool calls a Pin API from within a Pin call-back or analysis routine, it should not hold any tool locks when calling the API. Some of the Pin APIs use the internal Pin locks so holding a tool lock before invoking these APIs violates the hierarchy with respect to the Pin internal locks.</li><li>If the tool calls a Pin API from within an analysis routine, it may need to acquire the Pin client lock first by calling <a class="el" href="group__PIN__CONTROL.html#gc5d4cd777e5c34bb760ea6768e054f20">PIN_LockClient()</a>. This depends on the API, so check the documentation for the specific API for more information. Note that the tool should not hold any other locks when calling <a class="el" href="group__PIN__CONTROL.html#gc5d4cd777e5c34bb760ea6768e054f20">PIN_LockClient()</a>, as described in the previous item.</li></ul>
<p>
While these guidelines are sufficient in most cases, they may turn out to be too restrictive for certain use-cases. The next set of guidelines explains the conditions in which it is safe to relax the basic guidelines above:<ul>
<li>In JIT mode, the tool may acquire locks from within an analysis routine and not release them, providing it releases these locks before leaving the trace that contains the analysis routine. The tool must expect that the trace may exit "early" if an application instruction raises an exception. Any lock <code>L</code>, which the tool might hold when the application raises an exception, must obey the following sub-rules:<ul>
<li>The tool must establish a call-back that executes when the application raises an exception and this call-back must release lock <code>L</code> if it was acquired at the time the exception occurred. Tools can use <a class="el" href="group__PIN__CONTROL.html#gfe475fc12b9060e8e45cbfccd7d592c8">PIN_AddContextChangeFunction()</a> to establish this call-back.</li><li>The tool must not acquire lock <code>L</code> from within any Pin call-back, to avoid violating the hierarchy with respect to the Pin internal locks.</li></ul>
</li><li>If the tool calls a Pin API from an analysis routine, it may acquire and hold a lock <code>L</code> while calling the API providing that:<ul>
<li>Lock <code>L</code> is not being acquired from any Pin call-back. This avoids the hierarchy violation with respect to the Pin internal locks.</li><li>The Pin API being invoked does not cause application code to execute (e.g., <a class="el" href="group__PIN__CONTROL.html#g5280354edd95efc19a837617ff63ba51">PIN_CallApplicationFunction()</a>). This avoids the hierarchy violation with respect to the locks used by the application itself.</li></ul>
</li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="EXAMPLES">
Examples</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#BuildingExamples">Building the Example Tools</a></li><li><a class="el" href="index.html#WindowsNotes">Notes for Building Tools for Windows</a></li><li><a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#MAddressTrace">Memory Reference Trace (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#ImageLoad">Detecting the Loading and Unloading of Images (Image Instrumentation)</a></li><li><a class="el" href="index.html#inscount1">More Efficient Instruction Counting (Trace Instrumentation)</a></li><li><a class="el" href="index.html#ProcInstrCount">Procedure Instruction Count (Routine Instrumentation)</a></li><li><a class="el" href="index.html#SafeCopy">Using PIN_SafeCopy()</a></li><li><a class="el" href="index.html#Invocation">Order of Instrumentation</a></li><li><a class="el" href="index.html#FunctionArguments">Finding the Value of Function Arguments</a></li><li><a class="el" href="index.html#FindSymbol">Finding Functions By Name on Windows</a></li><li><a class="el" href="index.html#MallocMT">Instrumenting Threaded Applications</a></li><li><a class="el" href="index.html#InscountTLS">Using TLS</a></li><li><a class="el" href="index.html#Buffering">Using the Fast Buffering APIs</a></li><li><a class="el" href="index.html#StaticInstructionCounts">Finding the Static Properties of an Image</a></li><li><a class="el" href="index.html#DetachPin">Detaching Pin from the Application</a></li><li><a class="el" href="index.html#ReplaceSigProbed">Replacing a Routine in Probe Mode</a></li><li><a class="el" href="index.html#FollowChild">Instrumenting Child Processes</a></li><li><a class="el" href="index.html#ForkOnLinux">Instrumenting Before and After Forks</a></li><li><a class="el" href="index.html#JitApiTools">Managed platforms support</a></li></ul>
<p>
To illustrate how to write Pintools, we present some simple examples. In the web based version of the manual, you can click on a function in the Pin API to see its documentation.<p>
All the examples presented in the manual can be found in the source/tools/ManualExamples directory.<h3><a class="anchor" name="BuildingExamples">
Building the Example Tools</a></h3>
To build all examples in a directory for ia32 architecture: <div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make all TARGET=ia32
</pre></div><p>
To build all examples in a directory for intel64 architecture: <div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make all TARGET=intel64
</pre></div><p>
To build and run a specific example (e.g., inscount0): <div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make inscount0.test TARGET=intel64
</pre></div><p>
To build a specific example without running it (e.g., inscount0): <div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make obj-intel64/inscount0.so TARGET=intel64
</pre></div><p>
The above applies to the Intel(R) 64 architecture. For the IA-32 architecture, use TARGET=ia32 instead. <div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make obj-ia32/inscount0.so TARGET=ia32
</pre></div><h3><a class="anchor" name="WindowsNotes">
Notes for Building Tools for Windows</a></h3>
Since the tools are built using make, be sure to install cygwin make first.<p>
Open the Visual Studio Command Prompt corresponding to your target architecture, i.e. x86 or x64, and follow the steps in the <a class="el" href="index.html#BuildingExamples">Building the Example Tools</a> section.<h3><a class="anchor" name="SimpleCount">
Simple Instruction Count (Instruction Instrumentation)</a></h3>
The example below instruments a program to count the total number of instructions executed. It inserts a call to <code>docount</code> before every instruction. When the program exits, it saves the count in the file <code>inscount.out</code>.<p>
Here is how to run it and display its output (note that the file list is the <code>ls</code> output, so it may be different on your machine, similarly the instruction count will depend on the implementation of <code>ls</code>):<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/inscount0.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ cat inscount.out
Count 422838
$
</pre></div><p>
The KNOB exhibited in the example below overwrites the default name for the output file. To use this feature, add "-o &lt;file_name&gt;" to the command line. Tool command line options should be inserted between the tool name and the double dash ("--"). For more information on how to add command line options to your tool, please see <a class="el" href="group__KNOB__API.html">KNOB: Commandline Option Handling</a>.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/inscount0.so -o inscount0.log -- /bin/ls
</pre></div><p>
The example can be found in source/tools/ManualExamples/inscount0.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

ofstream OutFile;

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount() { icount++; }
    
<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to docount before every instruction, no arguments are passed</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, IARG_END);
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="comment">/*   argc, argv are the entire command line: pin -t &lt;toolname&gt; -- ...    */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="IAddressTrace">
Instruction Address Trace (Instruction Instrumentation)</a></h3>
In the previous example, we did not pass any arguments to <code>docount</code>, the analysis procedure. In this example, we show how to pass arguments. When calling an analysis procedure, Pin allows you to pass the instruction pointer, current value of registers, effective address of memory operations, constants, etc. For a complete list, see <a class="el" href="group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681">IARG_TYPE</a>.<p>
With a small change, we can turn the instruction counting example into a Pintool that prints the address of every instruction that is executed. This tool is useful for understanding the control flow of a program for debugging, or in processor design when simulating an instruction cache.<p>
We change the arguments to INS_InsertCall to pass the address of the instruction about to be executed. We replace <code>docount</code> with <code>printip</code>, which prints the instruction address. It writes its output to the file <code>itrace.out</code>.<p>
This is how to run it and look at the output:<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/itrace.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/itrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// This function is called before every instruction is executed</span>
<span class="comment">// and prints the IP</span>
VOID printip(VOID *ip) { fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip); }

<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to printip before every instruction, and pass it the IP</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)printip, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, IARG_END);
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This Pintool prints the IPs of every instruction executed\n"</span> 
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"itrace.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="MAddressTrace">
Memory Reference Trace (Instruction Instrumentation)</a></h3>
The previous example instruments all instructions. Sometimes a tool may only want to instrument a class of instructions, like memory operations or branch instructions. A tool can do this by using the Pin API which includes functions that classify and examine instructions. The basic API is common to all instruction sets and is described <a class="el" href="group__INS__BASIC__API.html">here.</a> In addition, there is an instruction set specific API for the <a class="el" href="group__INS__BASIC__API__IA32.html">IA-32 ISA.</a><p>
In this example, we show how to do more selective instrumentation by examining the instructions. This tool generates a trace of all memory addresses referenced by a program. This is also useful for debugging and for simulating a data cache in a processor.<p>
We only instrument instructions that read or write memory. We also use <a class="el" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a> instead of <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a> to avoid generating references to instructions that are predicated when the predicate is false. On IA-32 and Intel(R) 64 architectures CMOVcc, FCMOVcc and REP prefixed string operations are treated as being predicated. For CMOVcc and FCMOVcc the predicate is the condition test implied by "cc", for REP prefixed string ops it is that the count register is non-zero.<p>
Since the instrumentation functions are only called once and the analysis functions are called every time an instruction is executed, it is much faster to instrument only the memory operations, as compared to the previous instruction trace example that instruments every instruction.<p>
Here is how to run it and the sample output:<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/pinatrace.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace       proccount
atrace            imageload   inscount0      itrace.o     proccount.o
$ head pinatrace.out
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/pinatrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains an ISA-portable PIN tool for tracing memory accesses.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


FILE * trace;

<span class="comment">// Print a memory read record</span>
VOID RecordMemRead(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: R %p\n"</span>, ip, addr);
}

<span class="comment">// Print a memory write record</span>
VOID RecordMemWrite(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: W %p\n"</span>, ip, addr);
}

<span class="comment">// Is called for every instruction and instruments reads and writes</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span>
    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span>
    <span class="comment">//</span>
    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP </span>
    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span>
    UINT32 memOperands = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g5ee651cd69d153bb2ee86594a37e3ad6">INS_MemoryOperandCount</a>(ins);

    <span class="comment">// Iterate over each memory operand of the instruction.</span>
    <span class="keywordflow">for</span> (UINT32 memOp = 0; memOp &lt; memOperands; memOp++)
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins, memOp))
        {
            <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
                ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemRead,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                IARG_END);
        }
        <span class="comment">// Note that in some architectures a single memory operand can be </span>
        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span>
        <span class="comment">// In that case we instrument it once for read and once for write.</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g0cb7a4138a881972c59ca8c855765fba">INS_MemoryOperandIsWritten</a>(ins, memOp))
        {
            <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
                ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemWrite,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                IARG_END);
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>
   
INT32 Usage()
{
    PIN_ERROR( <span class="stringliteral">"This Pintool prints a trace of memory addresses\n"</span> 
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    trace = fopen(<span class="stringliteral">"pinatrace.out"</span>, <span class="stringliteral">"w"</span>);

    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, 0);
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ImageLoad">
Detecting the Loading and Unloading of Images (Image Instrumentation)</a></h3>
The example below prints a message to a trace file every time and image is loaded or unloaded. It really abuses the image instrumentation mode as the Pintool neither inspects the image nor adds instrumentation code.<p>
If you invoke it on ls, you would see this output:<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/imageload.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace       proccount.o
atrace            imageload   inscount0      itrace.o     trace.out
$ cat imageload.out
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/imageload.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="keyword">using namespace </span>std;

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"imageload.out"</span>, <span class="stringliteral">"specify file name"</span>);

ofstream TraceFile;

<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example does not</span>
<span class="comment">// Note that imgs (including shared libraries) are loaded lazily</span>

VOID ImageLoad(IMG img, VOID *v)
{
    TraceFile &lt;&lt; <span class="stringliteral">"Loading "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(img) &lt;&lt; <span class="stringliteral">", Image id = "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img) &lt;&lt; endl;
}

<span class="comment">// Pin calls this function every time a new img is unloaded</span>
<span class="comment">// You can't instrument an image that is about to be unloaded</span>
VOID ImageUnload(IMG img, VOID *v)
{
    TraceFile &lt;&lt; <span class="stringliteral">"Unloading "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(img) &lt;&lt; endl;
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It closes the output file.</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="keywordflow">if</span> (TraceFile.is_open()) { TraceFile.close(); }
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This tool prints a log of image load and unload events\n"</span>
             + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    
    TraceFile.open(KnobOutputFile.Value().c_str());
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register ImageUnload to be called when an image is unloaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#g8f27bbc6bbc60d15df64ca5e81b19c30">IMG_AddUnloadFunction</a>(ImageUnload, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="inscount1">
More Efficient Instruction Counting (Trace Instrumentation)</a></h3>
The example <a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a> computed the number of executed instructions by inserting a call before every instruction. In this example, we make it more efficient by counting the number of instructions in a BBL at instrumentation time, and incrementing the counter once per BBL, instead of once per instruction.<p>
The example can be found in source/tools/ManualExamples/inscount1.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

ofstream OutFile;

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
VOID docount(UINT32 c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount before every bbl, passing the number of instructions</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), IARG_END);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ProcInstrCount">
Procedure Instruction Count (Routine Instrumentation)</a></h3>
The example below instruments a program to count the number of times a procedure is called, and the total number of instructions executed in each procedure. When it finishes, it prints a profile to proccount.out<p>
Executing the tool and sample output:<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/proccount.so -- /bin/grep proccount.cpp Makefile
proccount_SOURCES = proccount.cpp
$ head proccount.out
              Procedure           Image            Address        Calls Instructions
                  _fini       libc.so.6         0x40144d00            1           21
__deregister_frame_info       libc.so.6         0x40143f60            2           70
  __register_frame_info       libc.so.6         0x40143df0            2           62
              fde_merge       libc.so.6         0x40143870            0            8
            __init_misc       libc.so.6         0x40115824            1           85
            __getclktck       libc.so.6         0x401157f4            0            2
                 munmap       libc.so.6         0x40112ca0            1            9
                   mmap       libc.so.6         0x40112bb0            1           23
            getpagesize       libc.so.6         0x4010f934            2           26
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/proccount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool counts the number of times a routine is executed and </span>
<span class="comment">// the number of instructions executed in a routine</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

ofstream outFile;

<span class="comment">// Holds instruction count for a single procedure</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    <span class="keyword">struct </span>RtnCount * _next;
} RTN_COUNT;

<span class="comment">// Linked list of instruction counts for each routine</span>
RTN_COUNT * RtnList = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount(UINT64 * counter)
{
    (*counter)++;
}
    
<span class="keyword">const</span> <span class="keywordtype">char</span> * StripPath(<span class="keyword">const</span> <span class="keywordtype">char</span> * path)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * file = strrchr(path,<span class="charliteral">'/'</span>);
    <span class="keywordflow">if</span> (file)
        <span class="keywordflow">return</span> file+1;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> path;
}

<span class="comment">// Pin calls this function every time a new rtn is executed</span>
VOID Routine(RTN rtn, VOID *v)
{
    
    <span class="comment">// Allocate a counter for this routine</span>
    RTN_COUNT * rc = <span class="keyword">new</span> RTN_COUNT;

    <span class="comment">// The RTN goes away when the image is unloaded, so save it now</span>
    <span class="comment">// because we need it in the fini</span>
    rc-&gt;_name = <a class="code" href="group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1">RTN_Name</a>(rtn);
    rc-&gt;_image = StripPath(<a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(<a class="code" href="group__SEC__BASIC__API.html#g3002fffef1eff03eb1d55ff6dc9c5977">SEC_Img</a>(<a class="code" href="group__RTN__BASIC__API.html#g9046edfd85722ef2f701282ba7a5c7a2">RTN_Sec</a>(rtn))).c_str());
    rc-&gt;_address = <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn);
    rc-&gt;_icount = 0;
    rc-&gt;_rtnCount = 0;

    <span class="comment">// Add to list of routines</span>
    rc-&gt;_next = RtnList;
    RtnList = rc;
            
    <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
    <span class="comment">// Insert a call at the entry point of a routine to increment the call count</span>
    <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_rtnCount), IARG_END);
    
    <span class="comment">// For each instruction of the routine</span>
    <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
    {
        <span class="comment">// Insert a call to docount to increment the instruction counter for this rtn</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_icount), IARG_END);
    }

    
    <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    outFile &lt;&lt; setw(23) &lt;&lt; <span class="stringliteral">"Procedure"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">"Image"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(18) &lt;&lt; <span class="stringliteral">"Address"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Calls"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Instructions"</span> &lt;&lt; endl;

    <span class="keywordflow">for</span> (RTN_COUNT * rc = RtnList; rc; rc = rc-&gt;_next)
    {
        <span class="keywordflow">if</span> (rc-&gt;_icount &gt; 0)
            outFile &lt;&lt; setw(23) &lt;&lt; rc-&gt;_name &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(15) &lt;&lt; rc-&gt;_image &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(18) &lt;&lt; hex &lt;&lt; rc-&gt;_address &lt;&lt; dec &lt;&lt;<span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_rtnCount &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_icount &lt;&lt; endl;
    }

}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This Pintool counts the number of times a routine is executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">"and the number of instructions executed in a routine"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    outFile.open(<span class="stringliteral">"proccount.out"</span>);

    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Routine to be called to instrument rtn</span>
    <a class="code" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a>(Routine, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="SafeCopy">
Using PIN_SafeCopy()</a></h3>
PIN_SafeCopy is used to copy the specified number of bytes from a source memory region to a destination memory region. This function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
Use of this function also guarantees that the tool reads or writes the values used by the application. For example, on Windows, Pin replaces certain TEB fields when running a tool's analysis code. If the tool accessed these fields directly, it would see the modified values rather than the original ones. Using <a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy()</a> allows the tool to read or write the application's values for these fields.<p>
We recommend using this API any time a tool reads or writes application memory.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/safecopy.so -- /bin/cp makefile obj-ia32/safecopy.so.makefile.copy
$ head safecopy.out
Emulate loading from addr 0xbff0057c to ebx
Emulate loading from addr 0x64ffd4 to eax
Emulate loading from addr 0xbff00598 to esi
Emulate loading from addr 0x6501c8 to edi
Emulate loading from addr 0x64ff14 to edx
Emulate loading from addr 0x64ff1c to edx
Emulate loading from addr 0x64ff24 to edx
Emulate loading from addr 0x64ff2c to edx
Emulate loading from addr 0x64ff34 to edx
Emulate loading from addr 0x64ff3c to edx
</pre></div><p>
The example can be found in source/tools/ManualExamples/safecopy.cpp.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include "pin_isa.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

std::ofstream* out = 0;

<span class="comment">//=======================================================</span>
<span class="comment">//  Analysis routines</span>
<span class="comment">//=======================================================</span>

<span class="comment">// Move from memory to register</span>
ADDRINT DoLoad(<a class="code" href="group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a> reg, ADDRINT * addr)
{
    *out &lt;&lt; <span class="stringliteral">"Emulate loading from addr "</span> &lt;&lt; addr &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt; <a class="code" href="group__REG__CPU__GENERIC.html#g6940f3aeb9d4063fe1783efbec5c0287">REG_StringShort</a>(reg) &lt;&lt; endl;
    ADDRINT value;
    <a class="code" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy</a>(&amp;value, addr, <span class="keyword">sizeof</span>(ADDRINT));
    <span class="keywordflow">return</span> value;
}

<span class="comment">//=======================================================</span>
<span class="comment">// Instrumentation routines</span>
<span class="comment">//=======================================================</span>

VOID EmulateLoad(INS ins, VOID* v)
{
    <span class="comment">// Find the instructions that move a value from memory to a register</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g82b583eb54370b90eb16013b9ceccb0a">INS_Opcode</a>(ins) == XED_ICLASS_MOV &amp;&amp;
        <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins) &amp;&amp; 
        <a class="code" href="group__INS__BASIC__API__IA32.html#gda61f0bd5ba11973274b344ccf76b5d3">INS_OperandIsReg</a>(ins, 0) &amp;&amp;
        <a class="code" href="group__INS__BASIC__API__IA32.html#g4e3ee4b5d8346e8f32e5154a720ab093">INS_OperandIsMemory</a>(ins, 1))
    {
        <span class="comment">// op0 &lt;- *op1</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins,
                       <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>,
                       AFUNPTR(DoLoad),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>,
                       <a class="code" href="group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a>(<a class="code" href="group__INS__BASIC__API__IA32.html#g556f7a38ca8ca40562d77810940f46b9">INS_OperandReg</a>(ins, 0)),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56817c4e6beb62b49ef970699ac2263b227c">IARG_RETURN_REGS</a>,
                       <a class="code" href="group__INS__BASIC__API__IA32.html#g556f7a38ca8ca40562d77810940f46b9">INS_OperandReg</a>(ins, 0),
                       IARG_END);

        <span class="comment">// Delete the instruction</span>
        <a class="code" href="group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a">INS_Delete</a>(ins);
    }
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates the use of SafeCopy"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    out = <span class="keyword">new</span> std::ofstream(<span class="stringliteral">"safecopy.out"</span>);

    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Register EmulateLoad to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(EmulateLoad, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();   
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="Invocation">
Order of Instrumentation</a></h3>
Pin provides tools with multiple ways to control the exection order of analysis calls. The exection order depends mainly on the insertion action (<a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a>) and call order (<a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a>). The example below illustrates this behavior by instrumenting all return instructions in three different ways. Additional examples can be found in source/tools/InstrumentationOrderAndVersion.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/invocation.so -- obj-ia32/little_malloc
$ head invocation.out
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x63a12e
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x641c76
After: IP = 0x641ca6
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x648b02
</pre></div><p>
The example can be found in source/tools/ManualExamples/invocation.cpp.<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="keyword">using namespace </span>std;


KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"invocation.out"</span>, <span class="stringliteral">"specify output file name"</span>);

ofstream OutFile;

<span class="comment">/*</span>
<span class="comment"> * Analysis routines</span>
<span class="comment"> */</span>
VOID Taken( <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT TakenIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR );
    OutFile &lt;&lt; <span class="stringliteral">"Taken: IP = "</span> &lt;&lt; hex &lt;&lt; TakenIP &lt;&lt; dec &lt;&lt; endl;
}

VOID Before(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT BeforeIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR);
    OutFile &lt;&lt; <span class="stringliteral">"Before: IP = "</span> &lt;&lt; hex &lt;&lt; BeforeIP &lt;&lt; dec &lt;&lt; endl;
}


VOID After(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT AfterIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR);
    OutFile &lt;&lt; <span class="stringliteral">"After: IP = "</span> &lt;&lt; hex &lt;&lt; AfterIP &lt;&lt; dec &lt;&lt; endl;
}

    
<span class="comment">/*</span>
<span class="comment"> * Instrumentation routines</span>
<span class="comment"> */</span>
VOID ImageLoad(IMG img, VOID *v)
{
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#g33f7761534eeb9e0d8caffa9dd9c7b29">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#g75fc1b62fe6f1d67d36e3215e464f000">SEC_Next</a>(sec))
    {
        <span class="comment">// RTN_InsertCall() and INS_InsertCall() are executed in order of</span>
        <span class="comment">// appearance.  In the code sequence below, the IPOINT_AFTER is</span>
        <span class="comment">// executed before the IPOINT_BEFORE.</span>
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g1a81afab78e506eb52b3c4d5fa81584d">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7">RTN_Next</a>(rtn))
        {
            <span class="comment">// Open the RTN.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>( rtn );
            
            <span class="comment">// IPOINT_AFTER is implemented by instrumenting each return</span>
            <span class="comment">// instruction in a routine.  Pin tries to find all return</span>
            <span class="comment">// instructions, but success is not guaranteed.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>( rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)After,
                            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
            
            <span class="comment">// Examine each instruction in the routine.</span>
            <span class="keywordflow">for</span>( INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins) )
            {
                <span class="keywordflow">if</span>( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g487a70954c5adee0c5084995819a513d">INS_IsRet</a>(ins) )
                {
                    <span class="comment">// instrument each return instruction.</span>
                    <span class="comment">// IPOINT_TAKEN_BRANCH always occurs last.</span>
                    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>( ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Before,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
                    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>( ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21e3df50f902d3b951e0a8ab8afbcf2902">IPOINT_TAKEN_BRANCH</a>, (AFUNPTR)Taken,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
                }
            }
            <span class="comment">// Close the RTN.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>( rtn );
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This is the invocation pintool"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Register ImageLoad to be called to instrument instructions</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(ImageLoad, 0);
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
<span class="comment">/* ===================================================================== */</span>
    
</pre></div><h3><a class="anchor" name="FunctionArguments">
Finding the Value of Function Arguments</a></h3>
Often one needs the know the value of the argument passed into a function, or the return value. You can use Pin to find this information. Using the <a class="el" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall()</a> function, you can specify the arguments of interest.<p>
The example below prints the input argument for malloc() and free(), and the return value from malloc().<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/malloctrace.so -- /bin/cp makefile obj-ia32/malloctrace.so.makefile.copy
$ head malloctrace.out
malloc(0x24d)
  returns 0x6504f8
malloc(0x57)
  returns 0x650748
malloc(0xc)
  returns 0x6507a0
malloc(0x3c0)
  returns 0x6507b0
malloc(0xc)
  returns 0x650b70
</pre></div><p>
The example can be found in source/tools/ManualExamples/malloctrace.cpp.<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Names of malloc and free */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="preprocessor">#if defined(TARGET_MAC)</span>
<span class="preprocessor"></span><span class="preprocessor">#define MALLOC "_malloc"</span>
<span class="preprocessor"></span><span class="preprocessor">#define FREE "_free"</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#define MALLOC "malloc"</span>
<span class="preprocessor"></span><span class="preprocessor">#define FREE "free"</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Global Variables */</span>
<span class="comment">/* ===================================================================== */</span>

std::ofstream TraceFile;

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Commandline Switches */</span>
<span class="comment">/* ===================================================================== */</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"malloctrace.out"</span>, <span class="stringliteral">"specify trace file name"</span>);

<span class="comment">/* ===================================================================== */</span>


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Analysis routines                                                     */</span>
<span class="comment">/* ===================================================================== */</span>
 
VOID Arg1Before(CHAR * name, ADDRINT size)
{
    TraceFile &lt;&lt; name &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
}

VOID MallocAfter(ADDRINT ret)
{
    TraceFile &lt;&lt; <span class="stringliteral">"  returns "</span> &lt;&lt; ret &lt;&lt; endl;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Instrumentation routines                                              */</span>
<span class="comment">/* ===================================================================== */</span>
   
VOID Image(IMG img, VOID *v)
{
    <span class="comment">// Instrument the malloc() and free() functions.  Print the input argument</span>
    <span class="comment">// of each malloc() or free(), and the return value of malloc().</span>
    <span class="comment">//</span>
    <span class="comment">//  Find the malloc() function.</span>
    RTN mallocRtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, MALLOC);
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(mallocRtn))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(mallocRtn);

        <span class="comment">// Instrument malloc() to print the input argument value and the return value.</span>
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(mallocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Arg1Before,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, MALLOC,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       IARG_END);
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(mallocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)MallocAfter,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681bfe16dc65390153dcbaea818fb0f77da">IARG_FUNCRET_EXITPOINT_VALUE</a>, IARG_END);

        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(mallocRtn);
    }

    <span class="comment">// Find the free() function.</span>
    RTN freeRtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, FREE);
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(freeRtn))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(freeRtn);
        <span class="comment">// Instrument free() to print the input argument value.</span>
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(freeRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Arg1Before,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, FREE,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       IARG_END);
        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(freeRtn);
    }
}

<span class="comment">/* ===================================================================== */</span>

VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>
   
INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool produces a trace of calls to malloc."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile &lt;&lt; hex;
    TraceFile.setf(ios::showbase);
    
    <span class="comment">// Register Image to be called to instrument functions.</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(Image, 0);
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* eof */</span>
<span class="comment">/* ===================================================================== */</span>
</pre></div><h3><a class="anchor" name="FindSymbol">
Finding Functions By Name on Windows</a></h3>
Finding functions by name on Windows requires a different methodology. Several symbols could resolve to the same function address. It is important to check all symbol names.<p>
The following example finds the function name in the symbol table, and uses the symbol address to find the appropriate RTN.<p>
<div class="fragment"><pre class="fragment">$ ..\..\..\pin -t obj-ia32\w_malloctrace.dll -- ..\Tests\obj-ia32\cp-pin.exe makefile w_malloctrace.makefile.copy
$ head *.out
Before: RtlAllocateHeap(00150000, 0, 0x94)
After: RtlAllocateHeap  returns 0x153440
After: RtlAllocateHeap  returns 0x153440
Before: RtlAllocateHeap(00150000, 0, 0x20)
After: RtlAllocateHeap  returns 0
After: RtlAllocateHeap  returns 0x1567c0
Before: RtlAllocateHeap(019E0000, 0x8, 0x1800)
After: RtlAllocateHeap  returns 0x19e0688
Before: RtlAllocateHeap(00150000, 0, 0x1a)thread begin 0

After: RtlAllocateHeap  returns 0
</pre></div><p>
The example can be found in source/tools/ManualExamples/w_malloctrace.cpp.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/* ===================================================================== */</span>
<span class="comment">/* This example demonstrates finding a function by name on Windows.      */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="keyword">namespace </span>WINDOWS
{
<span class="preprocessor">#include&lt;Windows.h&gt;</span>
}
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Global Variables */</span>
<span class="comment">/* ===================================================================== */</span>

std::ofstream TraceFile;

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Commandline Switches */</span>
<span class="comment">/* ===================================================================== */</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"w_malloctrace.out"</span>, <span class="stringliteral">"specify trace file name"</span>);

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool produces a trace of calls to RtlAllocateHeap."</span>;
    cerr &lt;&lt; endl &lt;&lt; endl;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();
    cerr &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Analysis routines                                                     */</span>
<span class="comment">/* ===================================================================== */</span>
 
VOID Before(CHAR * name, WINDOWS::HANDLE hHeap,
            WINDOWS::DWORD dwFlags, WINDOWS::DWORD dwBytes) 
{
    TraceFile &lt;&lt; <span class="stringliteral">"Before: "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; hex &lt;&lt; hHeap &lt;&lt; <span class="stringliteral">", "</span>
              &lt;&lt; dwFlags &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; dwBytes &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; dec &lt;&lt; endl;
}

VOID After(CHAR * name, ADDRINT ret)
{
    TraceFile &lt;&lt; <span class="stringliteral">"After: "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"  returns "</span> &lt;&lt; hex
              &lt;&lt; ret &lt;&lt; dec &lt;&lt; endl;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Instrumentation routines                                              */</span>
<span class="comment">/* ===================================================================== */</span>
   
VOID Image(IMG img, VOID *v)
{
    <span class="comment">// Walk through the symbols in the symbol table.</span>
    <span class="comment">//</span>
    <span class="keywordflow">for</span> (SYM sym = <a class="code" href="group__IMG__BASIC__API.html#g348cdf7a038afa17459b49efac8ce4f1">IMG_RegsymHead</a>(img); <a class="code" href="group__SYM__BASIC__API.html#ge83aad6ccb150a96e6bde242326a8ad4">SYM_Valid</a>(sym); sym = <a class="code" href="group__SYM__BASIC__API.html#ge180d8ef29e941662eae416f92adbd72">SYM_Next</a>(sym))
    {
        string undFuncName = <a class="code" href="group__SYM__BASIC__API.html#gd02e31773f5a8aef5e5a70be7f09dd17">PIN_UndecorateSymbolName</a>(<a class="code" href="group__SYM__BASIC__API.html#g2322cb4a1c052fa27420f66b1f3eb8e3">SYM_Name</a>(sym), <a class="code" href="group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aa7ac5b7ca1c9423fbe3d44bfbda828c43">UNDECORATION_NAME_ONLY</a>);

        <span class="comment">//  Find the RtlAllocHeap() function.</span>
        <span class="keywordflow">if</span> (undFuncName == <span class="stringliteral">"RtlAllocateHeap"</span>)
        {
            RTN allocRtn = <a class="code" href="group__RTN__BASIC__API.html#gc9d3d0a9e51f251da80910c74d4118c9">RTN_FindByAddress</a>(<a class="code" href="group__IMG__BASIC__API.html#g08c181dc4776ed954ebda9c5c28ce6c4">IMG_LowAddress</a>(img) + <a class="code" href="group__SYM__BASIC__API.html#g00de931c3077bdbfa72bb16c49fc007d">SYM_Value</a>(sym));
            
            <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(allocRtn))
            {
                <span class="comment">// Instrument to print the input argument value and the return value.</span>
                <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(allocRtn);
                
                <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(allocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Before,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, <span class="stringliteral">"RtlAllocateHeap"</span>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 1,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 2,
                               IARG_END);
                <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(allocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)After,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, <span class="stringliteral">"RtlAllocateHeap"</span>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681bfe16dc65390153dcbaea818fb0f77da">IARG_FUNCRET_EXITPOINT_VALUE</a>,
                               IARG_END);
                
                <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(allocRtn);
            }
        }
    }
}

<span class="comment">/* ===================================================================== */</span>

VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile &lt;&lt; hex;
    TraceFile.setf(ios::showbase);
    
    <span class="comment">// Register Image to be called to instrument functions.</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(Image, 0);
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* eof */</span>
<span class="comment">/* ===================================================================== */</span>
</pre></div><h3><a class="anchor" name="MallocMT">
Instrumenting Threaded Applications</a></h3>
The following example demonstrates using the ThreadStart() and ThreadFini() notification callbacks. Although ThreadStart() and ThreadFini() are executed under the VM and client locks, they could still contend with resources that are shared by other analysis routines. Using <a class="el" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock()</a> prevents this.<p>
Note that there is known isolation issue when using Pin on Windows. On Windows, a deadlock can occur if a tool opens a file in a callback when run on a multi-threaded application. To work around this problem, open one file in main, and tag the data with the thread ID. See source/tools/ManualExamples/buffer_windows.cpp as an example. This problem does not exist on Linux.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/malloc_mt.so -- obj-ia32/thread_lin
$ head malloc_mt.out
thread begin 0
thread 0 entered malloc(24d)
thread 0 entered malloc(57)
thread 0 entered malloc(c)
thread 0 entered malloc(3c0)
thread 0 entered malloc(c)
thread 0 entered malloc(58)
thread 0 entered malloc(56)
thread 0 entered malloc(19)
thread 0 entered malloc(25c)
</pre></div><p>
The example can be found in source/tools/ManualExamples/malloc_mt.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"malloc_mt.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">//==============================================================</span>
<span class="comment">//  Analysis Routines</span>
<span class="comment">//==============================================================</span>
<span class="comment">// Note:  threadid+1 is used as an argument to the PIN_GetLock()</span>
<span class="comment">//        routine as a debugging aid.  This is the value that</span>
<span class="comment">//        the lock is set to, so it must be non-zero.</span>

<span class="comment">// lock serializes access to the output file.</span>
FILE * out;
PIN_LOCK lock;

<span class="comment">// Note that opening a file in a callback is only supported on Linux systems.</span>
<span class="comment">// See buffer-win.cpp for how to work around this issue on Windows.</span>
<span class="comment">//</span>
<span class="comment">// This routine is executed every time a thread is created.</span>
VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread begin %d\n"</span>,threadid);
    fflush(out);
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);
}

<span class="comment">// This routine is executed every time a thread is destroyed.</span>
VOID ThreadFini(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread end %d code %d\n"</span>,threadid, code);
    fflush(out);
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);
}

<span class="comment">// This routine is executed each time malloc is called.</span>
VOID BeforeMalloc( <span class="keywordtype">int</span> size, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid )
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread %d entered malloc(%d)\n"</span>, threadid, size);
    fflush(out);
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);
}


<span class="comment">//====================================================================</span>
<span class="comment">// Instrumentation Routines</span>
<span class="comment">//====================================================================</span>

<span class="comment">// This routine is executed for each image.</span>
VOID ImageLoad(IMG img, VOID *)
{
    RTN rtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, <span class="stringliteral">"malloc"</span>);
    
    <span class="keywordflow">if</span> ( <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>( rtn ))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
        
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, AFUNPTR(BeforeMalloc),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);

        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
    }
}

<span class="comment">// This routine is executed once at the end.</span>
VOID Fini(INT32 code, VOID *v)
{
    fclose(out);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This Pintool prints a trace of malloc calls in the guest application\n"</span>
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <span class="comment">// Initialize the pin lock</span>
    <a class="code" href="group__LOCK.html#ga07949dcd22a1c5d8fe209767b4dd490">PIN_InitLock</a>(&amp;lock);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    out = fopen(KnobOutputFile.Value().c_str(), <span class="stringliteral">"w"</span>);

    <span class="comment">// Register ImageLoad to be called when each image is loaded.</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register Analysis routines to be called when a thread begins/ends</span>
    <a class="code" href="group__PIN__CONTROL.html#g0549831d0b423aea93768b1bc491938b">PIN_AddThreadStartFunction</a>(ThreadStart, 0);
    <a class="code" href="group__PIN__CONTROL.html#gc3f2c06e525bd0f23e8aa55f801989df">PIN_AddThreadFiniFunction</a>(ThreadFini, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="InscountTLS">
Using TLS</a></h3>
Pin provides efficient thread local storage (TLS) APIs. These APIs allow a tool to create thread-specific data. The example below demonstrates how to use these APIs.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/inscount_tls.so -- obj-ia32/thread_lin
$ head
Count[0]= 237993
Count[1]= 213296
Count[2]= 209223
Count[3]= 209223
Count[4]= 209223
Count[5]= 209223
Count[6]= 209223
Count[7]= 209223
Count[8]= 209223
Count[9]= 209223
</pre></div><p>
The example can be found in source/tools/ManualExamples/inscount_tls.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount_tls.out"</span>, <span class="stringliteral">"specify output file name"</span>);

PIN_LOCK lock;
INT32 numThreads = 0;
ofstream OutFile;

<span class="comment">// Force each thread's data to be in its own data cache line so that</span>
<span class="comment">// multiple threads do not contend for the same data cache line.</span>
<span class="comment">// This avoids the false sharing problem.</span>
<span class="preprocessor">#define PADSIZE 56  // 64 byte line size: 64-8</span>
<span class="preprocessor"></span>
<span class="comment">// a running count of the instructions</span>
<span class="keyword">class </span>thread_data_t
{
  <span class="keyword">public</span>:
    thread_data_t() : _count(0) {}
    UINT64 _count;
    UINT8 _pad[PADSIZE];
};


<span class="comment">// key for accessing TLS storage in the threads. initialized once in main()</span>
<span class="keyword">static</span>  <a class="code" href="group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c">TLS_KEY</a> tls_key;

<span class="comment">// function to access thread-specific data</span>
thread_data_t* get_tls(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid)
{
    thread_data_t* tdata = 
          static_cast&lt;thread_data_t*&gt;(<a class="code" href="group__DEPRECATED__PIN__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>(tls_key, threadid));
    <span class="keywordflow">return</span> tdata;
}

<span class="comment">// This function is called before every block</span>
VOID <a class="code" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a> docount(UINT32 c, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid)
{
    thread_data_t* tdata = get_tls(threadid);
    tdata-&gt;_count += c;
}

VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    numThreads++;
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);

    thread_data_t* tdata = <span class="keyword">new</span> thread_data_t;

    <a class="code" href="group__DEPRECATED__PIN__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(tls_key, tdata, threadid);
}


<span class="comment">// Pin calls this function every time a new basic block is encountered.</span>
<span class="comment">// It inserts a call to docount.</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a2198931604835e0f9ad1cd29cc1bc1f384">IPOINT_ANYWHERE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);
    }
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile &lt;&lt; <span class="stringliteral">"Total number of threads = "</span> &lt;&lt; numThreads &lt;&lt; endl;
    
    <span class="keywordflow">for</span> (INT32 t=0; t&lt;numThreads; t++)
    {
        thread_data_t* tdata = get_tls(t);
        OutFile &lt;&lt; <span class="stringliteral">"Count["</span> &lt;&lt; <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(t) &lt;&lt; <span class="stringliteral">"]= "</span> &lt;&lt; tdata-&gt;_count &lt;&lt; endl;
    }

    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    <span class="comment">// Initialize the lock</span>
    <a class="code" href="group__LOCK.html#ga07949dcd22a1c5d8fe209767b4dd490">PIN_InitLock</a>(&amp;lock);

    <span class="comment">// Obtain  a key for TLS storage.</span>
    tls_key = <a class="code" href="group__PIN__THREAD__API.html#g36b79c1845d1874b1d6fbe7c8e7f3e91">PIN_CreateThreadDataKey</a>(0);

    <span class="comment">// Register ThreadStart to be called when a thread starts.</span>
    <a class="code" href="group__PIN__CONTROL.html#g0549831d0b423aea93768b1bc491938b">PIN_AddThreadStartFunction</a>(ThreadStart, 0);

    <span class="comment">// Register Instruction to be called to instrument instructions.</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits.</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="Buffering">
Using the Fast Buffering APIs</a></h3>
Pin provides support for buffering data for processing. If all that your analysis callback does is to store its arguments into a buffer, then you should be able to use the buffering API instead, with some performance benefit. <a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer()</a> defines the buffer that will be used. The buffer is allocated by each thread when it starts up, and deallocated when the thread exits. <a class="el" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer()</a> writes the requested data directly to the given buffer. The callback delineated in the <a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer()</a> call is used to process the buffer when the buffer is nearly full, and when the thread exits. Pin does <b>not</b> serialize the calls to this callback, so it is the tool writers responsibilty to make sure this function is thread safe. This example records the PC of all instructions that access memory, and the effective address accessed by the instruction. Note that IARG_REG_REFERENCE, IARG_REG_CONST_REFERENCE and IARG_CONTEXT can NOT be used in the Fast Buffering APIs<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-ia32/buffer_linux.so -- obj-ia32/thread_lin
$ tail buffer.out.*.*
3263df   330108
3263df   330108
3263f1   a92f43fc
3263f7   a92f4d7d
326404   a92f43fc
32640a   a92f4bf8
32640a   a92f4bf8
32640f   a92f4d94
32641b   a92f43fc
326421   a92f4bf8
</pre></div><p>
The example can be found in source/tools/ManualExamples/buffer_linux.cpp. This example is appropriate for Linux tools. If you are writing a tool for Windows, please see source/tools/ManualExamples/buffer_windows.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Sample buffering tool</span>
<span class="comment"> * </span>
<span class="comment"> * This tool collects an address trace of instructions that access memory</span>
<span class="comment"> * by filling a buffer.  When the buffer overflows,the callback writes all</span>
<span class="comment"> * of the collected records to a file.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stddef.h&gt;</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include "portability.H"</span>
<span class="keyword">using namespace </span>std;

<span class="comment">/*</span>
<span class="comment"> * Name of the output file</span>
<span class="comment"> */</span>
KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>, <span class="stringliteral">"o"</span>, <span class="stringliteral">"buffer.out"</span>, <span class="stringliteral">"output file"</span>);

<span class="comment">/*</span>
<span class="comment"> * The ID of the buffer</span>
<span class="comment"> */</span>
BUFFER_ID bufId;

<span class="comment">/*</span>
<span class="comment"> * Thread specific data</span>
<span class="comment"> */</span>
<a class="code" href="group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c">TLS_KEY</a> mlog_key;

<span class="comment">/*</span>
<span class="comment"> * Number of OS pages for the buffer</span>
<span class="comment"> */</span>
<span class="preprocessor">#define NUM_BUF_PAGES 1024</span>
<span class="preprocessor"></span>

<span class="comment">/*</span>
<span class="comment"> * Record of memory references.  Rather than having two separate</span>
<span class="comment"> * buffers for reads and writes, we just use one struct that includes a</span>
<span class="comment"> * flag for type.</span>
<span class="comment"> */</span>
<span class="keyword">struct </span>MEMREF
{
    ADDRINT     pc;
    ADDRINT     ea;
    UINT32      size;
    BOOL        read;
};


<span class="comment">/*</span>
<span class="comment"> * MLOG - thread specific data that is not handled by the buffering API.</span>
<span class="comment"> */</span>
<span class="keyword">class </span>MLOG
{
  <span class="keyword">public</span>:
    MLOG(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid);
    ~MLOG();

    VOID DumpBufferToFile( <span class="keyword">struct</span> MEMREF * reference, UINT64 numElements, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid );

  <span class="keyword">private</span>:
    ofstream _ofile;
};


MLOG::MLOG(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)
{
    string filename = KnobOutputFile.Value() + <span class="stringliteral">"."</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(getpid_portable()) + <span class="stringliteral">"."</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(tid);
    
    _ofile.open(filename.c_str());
    
    <span class="keywordflow">if</span> ( ! _ofile )
    {
        cerr &lt;&lt; <span class="stringliteral">"Error: could not open output file."</span> &lt;&lt; endl;
        exit(1);
    }
    
    _ofile &lt;&lt; hex;
}


MLOG::~MLOG()
{
    _ofile.close();
}


VOID MLOG::DumpBufferToFile( <span class="keyword">struct</span> MEMREF * reference, UINT64 numElements, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid )
{
    <span class="keywordflow">for</span>(UINT64 i=0; i&lt;numElements; i++, reference++)
    {
        <span class="keywordflow">if</span> (reference-&gt;ea != 0)
            _ofile &lt;&lt; reference-&gt;pc &lt;&lt; <span class="stringliteral">"   "</span> &lt;&lt; reference-&gt;ea &lt;&lt; endl;
    }
}



<span class="comment">/**************************************************************************</span>
<span class="comment"> *</span>
<span class="comment"> *  Instrumentation routines</span>
<span class="comment"> *</span>
<span class="comment"> **************************************************************************/</span>

<span class="comment">/*</span>
<span class="comment"> * Insert code to write data to a thread-specific buffer for instructions</span>
<span class="comment"> * that access memory.</span>
<span class="comment"> */</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="keywordflow">for</span>(BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl=<a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="keywordflow">for</span>(INS ins = <a class="code" href="group__BBL__BASIC__API.html#gc87b625878d4ba42dfbeac2c81ac48bc">BBL_InsHead</a>(bbl); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins=<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
        {
            <span class="keywordflow">if</span> (!<a class="code" href="group__INS__BASIC__API__IA32.html#g2bfb17c6ec47cfc44627d3b6b09a5c63">INS_IsStandardMemop</a>(ins) &amp;&amp; !<a class="code" href="group__INS__BASIC__API__IA32.html#g56a84169084f4ba2a6c07d881acb165c">INS_HasMemoryVector</a>(ins))
            {
                <span class="comment">// We don't know how to treat these instructions</span>
                <span class="keywordflow">continue</span>;
            }

            UINT32 memoryOperands = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g5ee651cd69d153bb2ee86594a37e3ad6">INS_MemoryOperandCount</a>(ins);

            <span class="keywordflow">for</span> (UINT32 memOp = 0; memOp &lt; memoryOperands; memOp++)
            {
                UINT32 refSize = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ga7cbec34f1fc0e6387b44304f38f41c8">INS_MemoryOperandSize</a>(ins, memOp);

                <span class="comment">// Note that if the operand is both read and written we log it once</span>
                <span class="comment">// for each.</span>
                <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins, memOp))
                {
                    <a class="code" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, bufId,
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, offsetof(<span class="keyword">struct</span> MEMREF, pc),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp, offsetof(<span class="keyword">struct</span> MEMREF, ea),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, refSize, offsetof(<span class="keyword">struct</span> MEMREF, size), 
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, TRUE, offsetof(<span class="keyword">struct</span> MEMREF, read),
                                         IARG_END);
                }

                <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g0cb7a4138a881972c59ca8c855765fba">INS_MemoryOperandIsWritten</a>(ins, memOp))
                {
                    <a class="code" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, bufId,
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, offsetof(<span class="keyword">struct</span> MEMREF, pc),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp, offsetof(<span class="keyword">struct</span> MEMREF, ea),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, refSize, offsetof(<span class="keyword">struct</span> MEMREF, size), 
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, FALSE, offsetof(<span class="keyword">struct</span> MEMREF, read),
                                         IARG_END);
                }
            }
        }
    }
}


<span class="comment">/**************************************************************************</span>
<span class="comment"> *</span>
<span class="comment"> *  Callback Routines</span>
<span class="comment"> *</span>
<span class="comment"> **************************************************************************/</span>

VOID * BufferFull(BUFFER_ID <span class="keywordtype">id</span>, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *buf,
                  UINT64 numElements, VOID *v)
{
    <span class="keyword">struct </span>MEMREF * reference=(<span class="keyword">struct </span>MEMREF*)buf;

    MLOG * mlog = static_cast&lt;MLOG*&gt;( <a class="code" href="group__DEPRECATED__PIN__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>( mlog_key, tid ) );

    mlog-&gt;DumpBufferToFile( reference, numElements, tid );
    
    <span class="keywordflow">return</span> buf;
}


<span class="comment">/*</span>
<span class="comment"> * Note that opening a file in a callback is only supported on Linux systems.</span>
<span class="comment"> * See buffer-win.cpp for how to work around this issue on Windows.</span>
<span class="comment"> */</span>
VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <span class="comment">// There is a new MLOG for every thread.  Opens the output file.</span>
    MLOG * mlog = <span class="keyword">new</span> MLOG(tid);

    <span class="comment">// A thread will need to look up its MLOG, so save pointer in TLS</span>
    <a class="code" href="group__DEPRECATED__PIN__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(mlog_key, mlog, tid);

}


VOID ThreadFini(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)
{
    MLOG * mlog = static_cast&lt;MLOG*&gt;(<a class="code" href="group__DEPRECATED__PIN__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>(mlog_key, tid));

    <span class="keyword">delete</span> mlog;

    <a class="code" href="group__DEPRECATED__PIN__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(mlog_key, 0, tid);
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates the basic use of the buffering API."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize PIN library. Print help message if -h(elp) is specified</span>
    <span class="comment">// in the command line or the command line is invalid</span>
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Initialize the memory reference buffer;</span>
    <span class="comment">// set up the callback to process the buffer.</span>
    <span class="comment">//</span>
    bufId = <a class="code" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MEMREF), NUM_BUF_PAGES,
                                  BufferFull, 0);

    <span class="keywordflow">if</span>(bufId == BUFFER_ID_INVALID)
    {
        cerr &lt;&lt; <span class="stringliteral">"Error: could not allocate initial buffer"</span> &lt;&lt; endl;
        <span class="keywordflow">return</span> 1;
    }

    <span class="comment">// Initialize thread-specific data not handled by buffering api.</span>
    mlog_key = <a class="code" href="group__PIN__THREAD__API.html#g36b79c1845d1874b1d6fbe7c8e7f3e91">PIN_CreateThreadDataKey</a>(0);
   
    <span class="comment">// add an instrumentation function</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// add callbacks</span>
    <a class="code" href="group__PIN__CONTROL.html#g0549831d0b423aea93768b1bc491938b">PIN_AddThreadStartFunction</a>(ThreadStart, 0);
    <a class="code" href="group__PIN__CONTROL.html#gc3f2c06e525bd0f23e8aa55f801989df">PIN_AddThreadFiniFunction</a>(ThreadFini, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}


</pre></div><h3><a class="anchor" name="StaticInstructionCounts">
Finding the Static Properties of an Image</a></h3>
It is also possible to use pin to examine binaries without instrumenting them. This is useful when you need to know static properties of an image. The sample tool below counts the number of instructions in an image, but does not insert any instrumentation.<p>
The example can be found in source/tools/ManualExamples/staticcount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example merely</span>
<span class="comment">// counts the number of static instructions in the image</span>

VOID ImageLoad(IMG img, VOID *v)
{
    UINT32 count = 0;
    
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#g33f7761534eeb9e0d8caffa9dd9c7b29">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#g75fc1b62fe6f1d67d36e3215e464f000">SEC_Next</a>(sec))
    { 
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g1a81afab78e506eb52b3c4d5fa81584d">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7">RTN_Next</a>(rtn))
        {
            <span class="comment">// Prepare for processing of RTN, an  RTN is not broken up into BBLs,</span>
            <span class="comment">// it is merely a sequence of INSs </span>
            <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
            <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
            {
                count++;
            }

            <span class="comment">// to preserve space, release data associated with RTN after we have processed it</span>
            <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
        }
    }
    fprintf(stderr, <span class="stringliteral">"Image %s has  %d instructions\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(img).c_str(), count);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool prints a log of image load and unload events"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" along with static instruction counts for each image."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// prepare for image instrumentation mode</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="DetachPin">
Detaching Pin from the Application</a></h3>
Pin can relinquish control of application any time when invoked via <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>. Control is returned to the original uninstrumented code and the application runs at native speed. Thereafter no instrumented code is ever executed.<p>
The example can be found in source/tools/ManualExamples/detach.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// This tool shows how to detach Pin from an </span>
<span class="comment">// application that is under Pin's control.</span>

UINT64 icount = 0;

<span class="preprocessor">#define N 10000</span>
<span class="preprocessor"></span>VOID docount() 
{
    icount++;

    <span class="comment">// Release control of application if 10000 </span>
    <span class="comment">// instructions have been executed</span>
    <span class="keywordflow">if</span> ((icount % N) == 0) 
    {
        <a class="code" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>();
    }
}
 
VOID Instruction(INS ins, VOID *v)
{
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, IARG_END);
}

VOID ByeWorld(VOID *v)
{
    std::cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Detached at icount = "</span> &lt;&lt; N &lt;&lt; endl;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates how to detach Pin from an "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">"application that is under Pin's control"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Callback function to invoke for every </span>
    <span class="comment">// execution of an instruction</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, 0);
    
    <span class="comment">// Callback functions to invoke before</span>
    <span class="comment">// Pin releases control of the application</span>
    <a class="code" href="group__PIN__CONTROL.html#g4c85e2907788d57d10241d4f8b86a170">PIN_AddDetachFunction</a>(ByeWorld, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ReplaceSigProbed">
Replacing a Routine in Probe Mode</a></h3>
Probe mode is a method of using Pin to insert probes at the start of specified routines. A probe is a jump instruction that is placed at the start of the specified routine. The probe redirects the flow of control to the replacement function. Before the probe is inserted, the first few instructions of the specified routine are relocated. It is not uncommon for the replacement function to call the replaced routine. Pin provides the relocated address to facilitate this. See the example below.<p>
In probe mode, the application and the replacement routine are run natively. This improves performance, but it puts more responsibility on the tool writer. Probes can only be placed on RTN boundaries.<p>
Many of the PIN APIs that are available in JIT mode are not applicable in Probe mode. In particular, the Pin thread APIs are not supported in Probe mode, because Pin has no information about the threads when the application is run natively. For more information, check the RTN API documentation.<p>
The tool writer must guarantee that there is no jump target where the probe is placed. A probe may be up to 14 bytes long.<p>
Also, it is the tool writer's responsibility to ensure that no thread is currently executing the code where a probe is inserted. Tool writers are encouraged to insert probes when an image is loaded to avoid this problem. Pin will automatically remove the probes when an image is unloaded.<p>
When using probes, Pin must be started with the <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> API.<p>
The example can be found in source/tools/ManualExamples/replacesigprobed.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make replacesigprobed.test
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="comment">//  Replace an original function with a custom function defined in the tool using</span>
<span class="comment">//  probes.  The replacement function has a different signature from that of the </span>
<span class="comment">//  original replaced function.</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>std;

<span class="keyword">typedef</span> VOID * ( *FP_MALLOC )( size_t );

<span class="comment">// This is the replacement routine.</span>
<span class="comment">//</span>
VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )
{
    <span class="comment">// Normally one would do something more interesting with this data.</span>
    <span class="comment">//</span>
    cout &lt;&lt; <span class="stringliteral">"NewMalloc ("</span>
         &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; <span class="stringliteral">")"</span>
         &lt;&lt; endl &lt;&lt; flush;

    <span class="comment">// Call the relocated entry point of the original (replaced) routine.</span>
    <span class="comment">//</span>
    VOID * v = orgFuncptr( arg0 );

    <span class="keywordflow">return</span> v;
}


<span class="comment">// Pin calls this function every time a new img is loaded.</span>
<span class="comment">// It is best to do probe replacement when the image is loaded,</span>
<span class="comment">// because only one thread knows about the image at this time.</span>
<span class="comment">//</span>
VOID ImageLoad( IMG img, VOID *v )
{
    <span class="comment">// See if malloc() is present in the image.  If so, replace it.</span>
    <span class="comment">//</span>
    RTN rtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>( img, <span class="stringliteral">"malloc"</span> );
    
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn))
    {
        cout &lt;&lt; <span class="stringliteral">"Replacing malloc in "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(img) &lt;&lt; endl;
        
        <span class="comment">// Define a function prototype that describes the application routine</span>
        <span class="comment">// that will be replaced.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#gaa40d7e36e9ad7a07ee68adb5b312377">PROTO</a> proto_malloc = <a class="code" href="group__PROTO__API.html#g49300accd53f8e574af0b706ee553625">PROTO_Allocate</a>( <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">void</span> *), CALLINGSTD_DEFAULT,
                                             <span class="stringliteral">"malloc"</span>, <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">int</span>), <a class="code" href="group__PROTO__API.html#gb8a98de8d0939ae762c9b890097a350b">PIN_PARG_END</a>() );
        
        <span class="comment">// Replace the application routine with the replacement function.</span>
        <span class="comment">// Additional arguments have been added to the replacement routine.</span>
        <span class="comment">//</span>
        <a class="code" href="group__RTN__BASIC__API.html#g5cc8019660f41cae2449c826a878afe0">RTN_ReplaceSignatureProbed</a>(rtn, AFUNPTR(NewMalloc),
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681f007683926859b1cfd7c10c66a3555e2">IARG_PROTOTYPE</a>, proto_malloc,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812a8d49dccc99d1dfaeb26d8b3e583505">IARG_ORIG_FUNCPTR</a>,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681a9f63b1e494a1c86d00e4836f845c0c5">IARG_RETURN_IP</a>,
                                   IARG_END);

        <span class="comment">// Free the function prototype.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#g0affd7dbe19f86b3b3ffb260540d37e4">PROTO_Free</a>( proto_malloc );
    }
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates how to replace an original"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" function with a custom function defined in the tool "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" using probes.  The replacement function has a different "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" signature from that of the original replaced function."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main: Initialize and start Pin in Probe mode.                         */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main( INT32 argc, CHAR *argv[] )
{
    <span class="comment">// Initialize symbol processing</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <span class="comment">//</span>
    <a class="code" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a>( ImageLoad, 0 );
    
    <span class="comment">// Start the program in probe mode, never returns</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed</a>();
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><h3><a class="anchor" name="FollowChild">
Instrumenting Child Processes</a></h3>
The <a class="el" href="group__PIN__CONTROL.html#g4f667d78b5533ec07b15ef4df0d7a78e">PIN_AddFollowChildProcessFunction()</a> allows you to define the function you will like to execute before an execv'd process starts. Use the -follow_execv option on the command line to instrument the child processes, like this:<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -follow_execv -t obj-intel64/follow_child_tool.so -- obj-intel64/follow_child_app1 obj-intel64/follow_child_app2
</pre></div><p>
The example can be found in source/tools/ManualExamples/follow_child_tool.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make follow_child_tool.test
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Command line Switches */</span>
<span class="comment">/* ===================================================================== */</span>


BOOL FollowChild(<a class="code" href="group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2">CHILD_PROCESS</a> childProcess, VOID * userData)
{
    fprintf(stdout, <span class="stringliteral">"before child:%u\n"</span>, getpid());
    <span class="keywordflow">return</span> TRUE;
}        

<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <a class="code" href="group__PIN__CONTROL.html#g4f667d78b5533ec07b15ef4df0d7a78e">PIN_AddFollowChildProcessFunction</a>(FollowChild, 0);

    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();

    <span class="keywordflow">return</span> 0;
}

</pre></div><h3><a class="anchor" name="ForkOnLinux">
Instrumenting Before and After Forks</a></h3>
Pin allows Pintools to register for notification callbacks around forks. The <a class="el" href="group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4">PIN_AddForkFunction()</a> and PIN_AddForkFunctionProbed() callbacks allow you to define the function you want to execute at one of these FPOINTs: <div class="fragment"><pre class="fragment">    FPOINT_BEFORE            Call-back in parent, just before fork.
    FPOINT_AFTER_IN_PARENT   Call-back in parent, immediately after fork.
    FPOINT_AFTER_IN_CHILD    Call-back in child, immediately after fork.
</pre></div><p>
Note that <a class="el" href="group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4">PIN_AddForkFunction()</a> is used for JIT mode and PIN_AddForkFunctionProbed() is used for Probed mode. If the fork() fails, the FPOINT_AFTER_IN_PARENT callback, if it is defined, will execute anyway.<p>
The example can be found in source/tools/ManualExamples/fork_jit_tool.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make fork_jit_tool.test
</pre></div><p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="preprocessor">#include "pin.H"</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="keyword">using namespace </span>std;


INT32 Usage()
{
    cerr &lt;&lt;
        <span class="stringliteral">"This pin tool registers callbacks around fork().\n"</span>
        <span class="stringliteral">"\n"</span>;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();
    cerr &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}


pid_t parent_pid;
PIN_LOCK lock;

VOID BeforeFork(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: Before fork."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);
    parent_pid = <a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>();
}

VOID AfterForkInParent(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: After fork in parent."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);

    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>() != parent_pid)
    {
        cerr &lt;&lt; <span class="stringliteral">"PIN_GetPid() fails in parent process"</span> &lt;&lt; endl;
        exit(-1);
    }
}

VOID AfterForkInChild(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#gc7b6e6ed4fb7e14452b85b96d5c42c10">PIN_GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: After fork in child."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#g85d4faf75e968d46ca52986058ebd8c7">PIN_ReleaseLock</a>(&amp;lock);
    
    <span class="keywordflow">if</span> ((<a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>() == parent_pid) || (getppid() != parent_pid))
    {
        cerr &lt;&lt; <span class="stringliteral">"PIN_GetPid() fails in child process"</span> &lt;&lt; endl;
        exit(-1);
    }
}

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Initialize the pin lock</span>
    <a class="code" href="group__LOCK.html#ga07949dcd22a1c5d8fe209767b4dd490">PIN_InitLock</a>(&amp;lock);
    
    <span class="comment">// Register a notification handler that is called when the application</span>
    <span class="comment">// forks a new process.</span>
    <a class="code" href="group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf">FPOINT_BEFORE</a>, BeforeFork, 0);  
    <a class="code" href="group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35">FPOINT_AFTER_IN_PARENT</a>, AfterForkInParent, 0);
    <a class="code" href="group__PIN__CONTROL.html#ga141366d36aec81e19f4576de1c3f2e4">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88">FPOINT_AFTER_IN_CHILD</a>, AfterForkInChild, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="JitApiTools">
Managed platforms support</a></h3>
Pin allows Pintools to indentify dynamically created code using <a class="el" href="group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b">RTN_IsDynamic()</a> API (only code of functions which are reported by <a href="http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-17D7238B-DD19-45DB-B5E0-D9B344D1BE96.htm">Jit Profiling API</a>). The following example demonstrates use of <a class="el" href="group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b">RTN_IsDynamic()</a> API. This example instruments a program to count the total number of instructions discovered and executed. The instructions are divided to three categories: native instructions, dynamic instructions and instructions without any known routine.<p>
Here is how to run it and display its output with a 32 bit OpenCL sample on Windows:<p>
<div class="fragment"><pre class="fragment">$ set CL_CONFIG_USE_VTUNE=True
$ set INTEL_JIT_PROFILER32=ia32\bin\pinjitprofiling.dll
$ ia32\bin\pin.exe -t source\tools\JitProfilingApiTests\obj-ia32\DynamicInsCount.dll -support_jit_api -o DynamicInsCount.out -- ..\OpenCL\Win32\Debug\BitonicSort.exe
No command line arguments specified, using default values.
Initializing OpenCL runtime...
Trying to run on a CPU
OpenCL data alignment is 128 bytes.
Reading file 'BitonicSort.cl' (size 3435 bytes)
Sort order is ascending
Input size is 1048576 items
Executing OpenCL kernel...
Executing reference...
Performing verification...
Verification succeeded.
NDRange perf. counter time 12994.272962 ms.
Releasing resources...
$ type JitInsCount.out
===============================================
Number of executed native instructions: 7631596649
Number of executed jitted instructions: 438983207
Number of executed instructions without any known routine: 12246
===============================================
Number of discovered native instructions: 870531
Number of discovered jitted instructions: 223
Number of discovered instructions without any known routine: 36
===============================================

$
</pre></div><p>
The example can be found in source.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">// ==================================================================</span>
<span class="comment">// Global variables</span>
<span class="comment">// ==================================================================</span>

UINT64 insNativeDiscoveredCount = 0;  <span class="comment">//number of discovered native instructions</span>
UINT64 insDynamicDiscoveredCount = 0; <span class="comment">//number of discovered dynamic instructions</span>
UINT64 insNoRtnDiscoveredCount = 0;   <span class="comment">//number of discovered instructions without any known routine</span>

UINT64 insNativeExecutedCount = 0;  <span class="comment">//number of executed native instructions</span>
UINT64 insDynamicExecutedCount = 0; <span class="comment">//number of executed dynamic instructions</span>
UINT64 insNoRtnExecutedCount = 0;   <span class="comment">//number of executed instructions without any known routine</span>

std::ostream * out = &amp;cerr;

<span class="comment">// =====================================================================</span>
<span class="comment">// Command line switches</span>
<span class="comment">// =====================================================================</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>,  <span class="stringliteral">"pintool"</span>, <span class="stringliteral">"o"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"specify file name for output"</span>);

<span class="comment">// =====================================================================</span>
<span class="comment">// Utilities</span>
<span class="comment">// =====================================================================</span>

<span class="comment">// Print out help message.</span>
INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool prints out the number of native and dynamic instructions"</span> &lt;&lt; endl;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">// =====================================================================</span>
<span class="comment">// Analysis routines</span>
<span class="comment">// =====================================================================</span>

<span class="comment">// This function is called before every native instruction is executed</span>
VOID InsNativeCount()
{
    ++insNativeExecutedCount;
}

<span class="comment">// This function is called before every dynamic instruction is executed</span>
VOID InsDynamicCount()
{
    ++insDynamicExecutedCount;
}

<span class="comment">// This function is called before every instruction without any known routine is executed</span>
VOID InsNoRtnCount()
{
    ++insNoRtnExecutedCount;
}

<span class="comment">// =====================================================================</span>
<span class="comment">// Instrumentation callbacks</span>
<span class="comment">// =====================================================================</span>

<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    RTN rtn = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ge180d58ae453f61a939b1c4c5a66c129">INS_Rtn</a>(ins);
    <span class="keywordflow">if</span> (!<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn))
    {
        ++insNoRtnDiscoveredCount;
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)InsNoRtnCount, IARG_END);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b">RTN_IsDynamic</a>(rtn))
    {
        ++insDynamicDiscoveredCount;
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)InsDynamicCount, IARG_END);
    }
    <span class="keywordflow">else</span>
    {
        ++insNativeDiscoveredCount;
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)InsNativeCount, IARG_END);
    }
}

<span class="comment">// Print out analysis results.</span>
<span class="comment">// This function is called when the application exits.</span>
<span class="comment">// @param[in]   code            exit code of the application</span>
<span class="comment">// @param[in]   v               value specified by the tool in the</span>
<span class="comment">//                              PIN_AddFiniFunction function call</span>
VOID Fini(INT32 code, VOID *v)
{
    *out &lt;&lt;  <span class="stringliteral">"==============================================="</span> &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of executed native instructions: "</span> &lt;&lt; insNativeExecutedCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of executed dynamic instructions: "</span> &lt;&lt; insDynamicExecutedCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of executed instructions without any known routine: "</span> &lt;&lt; insNoRtnExecutedCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"==============================================="</span> &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of discovered native instructions: "</span> &lt;&lt; insNativeDiscoveredCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of discovered dynamic instructions: "</span> &lt;&lt; insDynamicDiscoveredCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"Number of discovered instructions without any known routine: "</span> &lt;&lt; insNoRtnDiscoveredCount &lt;&lt; endl;
    *out &lt;&lt;  <span class="stringliteral">"==============================================="</span> &lt;&lt; endl;

    string fileName = KnobOutputFile.Value();
    <span class="keywordflow">if</span> (!fileName.empty())
    {
        <span class="keyword">delete</span> out;
    }
}

<span class="comment">// The main procedure of the tool.</span>
<span class="comment">// This function is called when the application image is loaded but not yet started.</span>
<span class="comment">// @param[in]   argc            total number of elements in the argv array</span>
<span class="comment">// @param[in]   argv            array of command line arguments,</span>
<span class="comment">//                              including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize PIN library. Print help message if -h(elp) is specified</span>
    <span class="comment">// in the command line or the command line is invalid</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv))
    {
        <span class="keywordflow">return</span> Usage();
    }

    string fileName = KnobOutputFile.Value();

    <span class="keywordflow">if</span> (!fileName.empty())
    {
        out = <span class="keyword">new</span> std::ofstream(fileName.c_str());
    }

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, NULL);

    <span class="comment">// Register function to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, NULL);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Pin allows Pintools to instrument just compiled functions using <a class="el" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a> API. Following example instruments a program to log Jitting and running of dynamic functions which are reported by <a href="http://software.intel.com/sites/products/documentation/doclib/iss/2013/amplifier/lin/ug_docs/GUID-17D7238B-DD19-45DB-B5E0-D9B344D1BE96.htm">Jit Profiling API</a>.<p>
Here is how to run it with a 64 bit OpenCL sample on Linux:<p>
<div class="fragment"><pre class="fragment">$ setenv CL_CONFIG_USE_VTUNE True
$ setenv INTEL_JIT_PROFILER64 intel64/lib/libpinjitprofiling.so
$ ./pin -t source/tools/JitProfilingApiTests/obj-intel64/DynamicFuncInstrument.so -support_jit_api -o DynamicFuncInstrument.out -- ..\OpenCL\Win32\Debug\BitonicSort.exe
No command line arguments specified, using default values.
Initializing OpenCL runtime...
Trying to run on a CPU
OpenCL data alignment is 128 bytes.
Reading file 'BitonicSort.cl' (size 3435 bytes)
Sort order is ascending
Input size is 1048576 items
Executing OpenCL kernel...
Executing reference...
Performing verification...
Verification succeeded.
NDRange perf. counter time 12994.272962 ms.
Releasing resources...
$
</pre></div><p>
The example can be found in source.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">// =====================================================================</span>
<span class="comment">// Global variables</span>
<span class="comment">// =====================================================================</span>

std::ostream * out = &amp;cerr;

<span class="comment">// =====================================================================</span>
<span class="comment">// Command line switches</span>
<span class="comment">// =====================================================================</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>,  <span class="stringliteral">"pintool"</span>, <span class="stringliteral">"o"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"specify file name for output"</span>);

<span class="comment">// =====================================================================</span>
<span class="comment">// Utilities</span>
<span class="comment">// =====================================================================</span>

<span class="comment">// Print out help message.</span>
INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool prints out the stack filtered by the dynamicaly created functions only"</span> &lt;&lt; endl;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">// =====================================================================</span>
<span class="comment">// Analysis routines</span>
<span class="comment">// =====================================================================</span>

VOID RtnCallPrint(CHAR * rtnName)
{
    *out &lt;&lt; <span class="stringliteral">"Before run "</span> &lt;&lt; rtnName &lt;&lt; endl;
}

<span class="comment">// =====================================================================</span>
<span class="comment">// Instrumentation callbacks</span>
<span class="comment">// =====================================================================</span>

<span class="comment">// Pin calls this function every time a new rtn is executed</span>
VOID Routine(RTN rtn, VOID *v)
{
    <span class="keywordflow">if</span> (!<a class="code" href="group__RTN__BASIC__API.html#gb36b828dc06d754e79780245d938dc7b">RTN_IsDynamic</a>(rtn))
    {
        <span class="keywordflow">return</span>;
    }

    *out &lt;&lt; <span class="stringliteral">"Just discovered "</span> &lt;&lt; <a class="code" href="group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1">RTN_Name</a>(rtn) &lt;&lt; endl;

    <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);

    <span class="comment">// Insert a call at the entry point of a routine to increment the call count</span>
    <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RtnCallPrint, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, <a class="code" href="group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1">RTN_Name</a>(rtn).c_str(), IARG_END);

    <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
}

<span class="comment">// Print out analysis results.</span>
<span class="comment">// This function is called when the application exits.</span>
<span class="comment">// @param[in]   code            exit code of the application</span>
<span class="comment">// @param[in]   v               value specified by the tool in the</span>
<span class="comment">//                              PIN_AddFiniFunction function call</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="keyword">const</span> string fileName = KnobOutputFile.Value();
    <span class="keywordflow">if</span> (!fileName.empty())
    {
        <span class="keyword">delete</span> out;
    }
}

<span class="comment">// The main procedure of the tool.</span>
<span class="comment">// This function is called when the application image is loaded but not yet started.</span>
<span class="comment">// @param[in]   argc            total number of elements in the argv array</span>
<span class="comment">// @param[in]   argv            array of command line arguments,</span>
<span class="comment">//                              including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize PIN library. Print help message if -h(elp) is specified</span>
    <span class="comment">// in the command line or the command line is invalid</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv))
    {
        <span class="keywordflow">return</span> Usage();
    }

    <span class="keyword">const</span> string fileName = KnobOutputFile.Value();

    <span class="keywordflow">if</span> (!fileName.empty())
    {
        out = <span class="keyword">new</span> std::ofstream(fileName.c_str());
    }

    <span class="comment">// Register Routine to be called to instrument rtn</span>
    <a class="code" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a>(Routine, 0);

    <span class="comment">// Register function to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, NULL);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="CALLBACK">
Callbacks</a></h2>
========================================================================================<p>
The examples in the previous section have introduced a number of ways to register callback functions via the Pin API, such as:<p>
<ul>
<li><a class="el" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a> (INSCALLBACK fun, VOID *val)</li><li><a class="el" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a> (TRACECALLBACK fun, VOID *val)</li><li><a class="el" href="group__RTN__BASIC__API.html#g50b3794c06a99774ed62abec8ad3b173">RTN_AddInstrumentFunction</a> (RTNCALLBACK fun, VOID *val)</li><li><a class="el" href="group__IMG__BASIC__API.html#g4867c865fcf260951b7d750aaaaa0007">IMG_AddInstrumentFunction</a> (IMGCALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a> (FINICALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g4c85e2907788d57d10241d4f8b86a170">PIN_AddDetachFunction</a> (DETACHCALLBACK fun, VOID *val)</li></ul>
<p>
The extra parameter <code>val</code> (shared by all the registration functions) will be passed to <code>fun</code> as its second argument whenever it is "called back". This is a standard mechanism used in GUI programming with callbacks.<p>
If this feature is not needed, it is safe to pass 0 for <code>val</code> when registering a callback. The expected use of <code>val</code> is to pass a pointer to an instance of a class. Since <code>val</code> is a generic pointer, <code>fun</code> must cast it back to an object before dereferencing the pointer.<p>
Note that all callback registration functions return a <a class="el" href="group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074">PIN_CALLBACK</a> object which can later be used to manipulate the properties of the registered callback (for example change the order in which PIN executes callback functions of the same type). This can be done by calling API functions that manipulates the <a class="el" href="group__PIN__CALLBACKS.html#g0a4ffb30eef7af84cb12b46e37ac4074">PIN_CALLBACK</a> object (see <a class="el" href="group__PIN__CALLBACKS.html">PIN callbacks</a>)<p>
======================================================================================== <h2><a class="anchor" name="MODIFYING">
Modifying Application Instructions</a></h2>
========================================================================================<p>
Although Pin is most commonly used for instrumenting applications, it is also possible to change the application's instructions. The simplest way to do this is to insert an analysis routine to emulate an instruction, and then use <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a">INS_Delete()</a> to remove the original instruction. It is also possible to insert direct or indirect branches (using <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g85b5d845590e666a8424e3793a2cdf33">INS_InsertDirectJump</a> and <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g001c169ec3e061fc6436b63af220d81d">INS_InsertIndirectJump</a>), which makes it easier to emulate instructions that change the control flow.<p>
The memory addresses accessed by an instruction can be modified to refer to a value calculated by an analysis routine using <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g9309f9f665d0d01b9c880eeaf2955d33">INS_RewriteMemoryOperand</a>.<p>
Note that in all of the cases where an instruction is modified, the modification is only made after all of the instrumentation routines have been executed. Therefore all of the instrumentation routines see the original, un-modified instruction.<p>
======================================================================================== <h2><a class="anchor" name="APPDEBUG">
The Pin Advanced Debugging Extensions</a></h2>
========================================================================================<p>
Pin's advanced debugging extensions allow you to debug an application, even while it runs under Pin in JIT mode. Moreover, your Pin tool can add support for new debugger commands, without making any changes to GDB or Visual Studio. This allows you to interactively control your Pin tool from within a live debugger session. Finally, Pin tools can add powerful new debugger features that are enabled via instrumentation. For example, a Pin tool can use instrumentation to look for an interesting condition (like a memory buffer overwrite) and then stop at a live debugger session when that condition occurs.<p>
This section illustrates these three concepts:<p>
<ul>
<li>Enabling all the traditional debugger features even while running an application under Pin in JIT mode.</li></ul>
<p>
<ul>
<li>Recognizing new debugger commands in your Pin tool to allow interactive control of the tool from a live debugger session.</li></ul>
<p>
<ul>
<li>Adding support for new debugger features by writing a Pin tool.</li></ul>
<p>
These features are available on both Linux (using GDB) and on Windows (using Visual Studio). The Pin APIs are the same in both cases, but their usage from within the debugger is different because each debugger has a different UI. The following tutorial is divided into two sections: one that is Linux centric and another that is Windows centric. They both describe the same example, so you can continue by reading either section.<p>
<ul>
<li><a class="el" href="index.html#APPDEBUG_LINUX">Tutorial for Linux</a></li><li><a class="el" href="index.html#APPDEBUG_WINDOWS">Tutorial for Windows</a></li><li><a class="el" href="index.html#APPDEBUG_OSX">Tutorial for OS X*</a></li></ul>
<p>
Finally, note that these advanced debugging extensions are not at all related to debugging your Pintool. If you have a bug in your tool and need to debug it, see the section <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a> instead.<h3><a class="anchor" name="APPDEBUG_LINUX">
Advanced Debugging Extensions on Linux</a></h3>
Pin's debugging extensions on Linux work with nearly all modern versions of GDB, so you can probably use whatever version of GDB is already installed on your system. Pin uses GDB's remote debugger features, so it should work with any version of GDB that supports that feature.<p>
Throughout this section, we demonstrate the debugging extensions in Pin with the example tool "stack-debugger.cpp", which is available in the directory "source/tools/ManualExamples". You may want to compile that tool and follow along:<p>
<div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make DEBUG=1 stack-debugger.test
</pre></div><p>
The tool and its associated test application, "fibonacci", are built in a directory named "obj-ia32", "obj-intel64", etc., depending on your machine type.<p>
To enable the debugging extensions, run Pin with the <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG">-appdebug</a> command line switch. This causes Pin to start the application and stop immediately before the first instruction. Pin then prints a message telling you to start GDB.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -appdebug -t obj-intel64/stack-debugger.so -- obj-intel64/fibonacci 1000
Application stopped until continued from debugger.
Start GDB, then issue this command at the (gdb) prompt:
  target remote :33030
</pre></div><p>
In another window, start GDB and enter the command that Pin printed:<p>
<div class="fragment"><pre class="fragment">$ gdb fibonacci
(gdb) target remote :33030
</pre></div><p>
At this point, the debugger is attached to the application that is running under Pin. You can set breakpoints, continue execution, print out variables, disassemble code, etc.<p>
<div class="fragment"><pre class="fragment">(gdb) break main
Breakpoint 1 at 0x401194: file fibonacci.cpp, line 12.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=2, argv=0x7fbffff3c8) at fibonacci.cpp:12
12          if (argc &gt; 2)
(gdb) print argc
$1 = 2
(gdb) x/4i $pc
0x401194 &lt;main+27&gt;:     cmpl   $0x2,0xfffffffffffffe5c(%rbp)
0x40119b &lt;main+34&gt;:     je     0x4011c8 &lt;main+79&gt;
0x40119d &lt;main+36&gt;:     mov    $0x402080,%esi
0x4011a2 &lt;main+41&gt;:     mov    $0x603300,%edi
</pre></div><p>
Of course, any information you observe in the debugger shows the application's "pure" state. The details of Pin and the tool's instrumentation are hidden. For example, the disassembly you see above shows only the application's instructions, not any of the instructions inserted by the tool. However, when you use commands like "cont" or "step" to advance execution of the application, your tool's instrumentation runs as it normally would under Pin.<p>
<dl compact><dt><b>Note:</b></dt><dd>After connecting GDB with the "target remote" command, you should NOT use the "run" command. The application is already running and stopped at the first instruction. Instead, use the "cont" command to continue execution.</dd></dl>
<h4><a class="anchor" name="APPDEBUG_LINUX_COMMANDS">
Adding New Debugger Commands</a></h4>
The previous section illustrated how you can enable the normal debugger features while running an application under Pin. Now, let's see how your Pintool can add new custom debugger commands, even without changing GDB. Custom debugger commands are useful because they allow you to control your Pintool interactively from within a live debugger session. For example, you can ask your Pintool to print out information that it has collected, or you can interactively enable instrumentation only for certain phases of the application.<p>
To illustrate, see the call to <a class="el" href="group__APPDEBUG__API.html#g5c3c5c6220acfad8860218b41410b07a">PIN_AddDebugInterpreter()</a> in the stack-debugger tool. That API sets up the following call-back function:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> BOOL DebugInterpreter(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <span class="keyword">const</span> string &amp;cmd, string *result, VOID *)
{
    TINFO_MAP::iterator it = ThreadInfos.find(tid);
    <span class="keywordflow">if</span> (it == ThreadInfos.end())
        <span class="keywordflow">return</span> FALSE;
    TINFO *tinfo = it-&gt;second;

    std::string line = TrimWhitespace(cmd);
    *result = <span class="stringliteral">""</span>;

    <span class="comment">// [...]</span>

    <span class="keywordflow">if</span> (line == <span class="stringliteral">"stats"</span>)
    {
        ADDRINT sp = <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
        tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
        <span class="keywordflow">if</span> (sp &lt;= tinfo-&gt;_stackBase)
            tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Current stack usage: "</span> &lt;&lt; std::dec &lt;&lt; (tinfo-&gt;_stackBase - sp) &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        <span class="keywordflow">else</span>
            tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Current stack usage: -"</span> &lt;&lt; std::dec &lt;&lt; (sp - tinfo-&gt;_stackBase) &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Maximum stack usage: "</span> &lt;&lt; tinfo-&gt;_max &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        *result = tinfo-&gt;_os.str();
        <span class="keywordflow">return</span> TRUE;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (line == <span class="stringliteral">"stacktrace on"</span>)
    {
        <span class="keywordflow">if</span> (!EnableInstrumentation)
        {
            <a class="code" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation</a>();
            EnableInstrumentation = <span class="keyword">true</span>;
            *result = <span class="stringliteral">"Stack tracing enabled.\n"</span>;
        }
        <span class="keywordflow">return</span> TRUE;
    }

    <span class="comment">// [...]</span>

    <span class="keywordflow">return</span> FALSE;  <span class="comment">// Unknown command</span>

}
</pre></div><p>
The <a class="el" href="group__APPDEBUG__API.html#g5c3c5c6220acfad8860218b41410b07a">PIN_AddDebugInterpreter()</a> API allows a Pintool to establish a handler for extended GDB commands. For example, the code snippet above implements the new commands "stats" and "stacktrace on". You can execute these commands in GDB by using the "monitor" command:<p>
<div class="fragment"><pre class="fragment">(gdb) monitor stats
Current stack usage: 688 bytes.
Maximum stack usage: 0 bytes.
</pre></div><p>
A Pintool can do various things when the user types an extended debugger command. For example, the "stats" command prints out some information that the tool has collected. Any text that the tool writes to the "result" parameter is printed to the GDB console. Note that the CONTEXT parameter has the register state for the debugger's "focus" thread, so the tool can easily display information about this focus thread.<p>
You can also use an extended debugger command to interactively enable or disable instrumentation in your Pintool, as demonstrated by the "stacktrace on" command. For example, if you wanted to quickly run your Pintool over the application's initial start-up phase, you could run with your Pintool's instrumentation disabled until a breakpoint is triggered. Then, you could use an extended command to enable instrumentation only during the interesting part of the application. In the stack-debugger example above, the call to <a class="el" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation()</a> causes Pin to discard any previous instrumentation, so the tool re-instruments the code when the debugger continues execution of the application. As we will see later, the tool's global variable "EnableInstrumentation" adjusts the instrumentation that it inserts.<h4><a class="anchor" name="APPDEBUG_LINUX_BREAK">
Semantic Breakpoints</a></h4>
The last major feature of the advanced debugging extensions is the ability to stop execution at a breakpoint by calling an API from your tool's analysis code. This may sound simple, but it is very powerful. Your Pintool can use instrumentation to look for a complex condition and then stop at a breakpoint when that condition occurs.<p>
The "stack-debugger" tool illustrates this by using instrumentation to observe all the instructions that allocate stack space, and then it stops at a breakpoint whenever the application's stack usage reaches some threshold. In effect, this adds a new feature to the debugger that could not be practically implemented using traditional debugger technology because a traditional debugger can not reasonably find all the instructions that allocate stack space. A Pintool, however, can do this quite easily via instrumentation.<p>
The example code below from the "stack-debugger" tool uses Pin instrumentation to identify all the instructions that allocate stack space.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> VOID Instruction(INS ins, VOID *)
{
    <span class="keywordflow">if</span> (!EnableInstrumentation)
        <span class="keywordflow">return</span>;

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain</a>(ins, REG_STACK_PTR))
    {
        <a class="code" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>;
        <span class="keywordflow">if</span> (!<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g85371f49008f053ffa09ac242ae1c9e3">INS_HasFallThrough</a>(ins))
            where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21e3df50f902d3b951e0a8ab8afbcf2902">IPOINT_TAKEN_BRANCH</a>;

        <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, where, (AFUNPTR)OnStackChangeIf, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, REG_STACK_PTR,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, RegTinfo, IARG_END);
        <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, where, (AFUNPTR)DoBreakpoint, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568152f3e4ae9dfb93f4691d7342ee937c4d">IARG_CONST_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);
    }
}
</pre></div><p>
The call to <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain()</a> tests whether an instruction modifies the stack pointer. If it does, we insert an analysis call immediately after the instruction, which checks to see if the application's stack usage exceeds a threshold.<p>
Also notice that all the instrumentation is gated by the global flag "EnableInstrumentation", which we saw earlier in the "stacktrace on" command. Thus, the user can disable instrumentation (with "stacktrace off") in order to execute quickly through uninteresting parts of the application, and then re-enable it (with "stacktrace on") for the interesting parts.<p>
The analysis routine OnStackChangeIf() returns TRUE if the application's stack usage has exceeded the threshold. When this happens, the tool calls the DoBreakpoint() analysis routine, which will stop at the debugger breakpoint. Notice that we use if / then instrumentation here because the call to DoBreakpoint() requires a "CONTEXT *" parameter, which can be slow.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> ADDRINT OnStackChangeIf(ADDRINT sp, ADDRINT addrInfo)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(addrInfo);

    <span class="comment">// The stack pointer may go above the base slightly.  (For example, the application's dynamic</span>
    <span class="comment">// loader does this briefly during start-up.)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (sp &gt; tinfo-&gt;_stackBase)
        <span class="keywordflow">return</span> 0;

    <span class="comment">// Keep track of the maximum stack usage.</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - sp;
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_max)
        tinfo-&gt;_max = size;

    <span class="comment">// See if we need to trigger a breakpoint.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (BreakOnNewMax &amp;&amp; size &gt; tinfo-&gt;_maxReported)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">if</span> (BreakOnSize &amp;&amp; size &gt;= BreakOnSize)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> VOID DoBreakpoint(<span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, RegTinfo));

    <span class="comment">// Keep track of the maximum reported stack usage for "stackbreak newmax".</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_maxReported)
        tinfo-&gt;_maxReported = size;

    ConnectDebugger();  <span class="comment">// Ask the user to connect a debugger, if it is not already connected.</span>

    <span class="comment">// Construct a string that the debugger will print when it stops.  If a debugger is</span>
    <span class="comment">// not connected, no breakpoint is triggered and execution resumes immediately.</span>
    <span class="comment">//</span>
    tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
    tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Thread "</span> &lt;&lt; std::dec &lt;&lt; tid &lt;&lt; <span class="stringliteral">" uses "</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">" bytes of stack."</span>;
    <a class="code" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, tinfo-&gt;_os.str());
}
</pre></div><p>
The analysis routine OnStackChangeIf() keeps track of some metrics on stack usage and tests whether the threshold has been reached. If the threshold is crossed, it returns non-zero, and Pin executes the DoBreakpoint() analysis routine.<p>
The interesting part of DoBreakpoint() is at the very end, where it calls <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>. This API causes Pin to stop the execution of all threads and triggers a breakpoint in the debugger. There is also a string parameter to <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>, which GDB prints at the console when the breakpoint triggers. A Pintool can use this string to tell the user why a breakpoint triggered. In our example tool, this string says something like "Thread 10 uses 4000 bytes of stack".<p>
We can see the breakpoint feature in action in our example tool by using the "stackbreak 4000" command like this:<p>
<div class="fragment"><pre class="fragment">(gdb) monitor stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.
(gdb) c
Continuing.
Thread 0 uses 4000 bytes of stack.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:34
(gdb)
</pre></div><p>
When you are done, you can either continue the application and let it terminate, or you can quit from the debugger:<p>
<div class="fragment"><pre class="fragment">(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre></div><h4><a class="anchor" name="APPDEBUG_LINUX_LATER">
Connecting the Debugger Later</a></h4>
In the previous example, we used the Pin switch <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG">-appdebug</a> to stop the application and debug it from the first instruction. You can also enable Pin's debugging extensions without stopping at the first instruction. The following example shows how you can use the stack-debugger tool to start the application and attach with the debugger only after it triggers a stack limit breakpoint.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -appdebug_enable -appdebug_silent -t obj-intel64/stack-debugger.so -stackbreak 4000 -- obj-intel64/fibonacci 1000
</pre></div><p>
The <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_ENABLE">-appdebug_enable</a> switch tells Pin to enable application debugging without stopping at the first instruction. The <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_SILENT">-appdebug_silent</a> switch disables the message that tells how to connect with GDB. As we will see later, the Pintool can print a custom message instead. Finally, the "-stackbreak 4000" switch tells the stack-debugger tool to trigger a breakpoint when the stack grows to 4000 bytes. When the tool does trigger a breakpoint, it prints a message like this:<p>
<div class="fragment"><pre class="fragment">Triggered stack-limit breakpoint.
Start GDB and enter this command:
  target remote :45462
</pre></div><p>
You can now connect with GDB as you did before, except now GDB stops the application at the point where the stack-debugger tool triggered the stack-limit breakpoint.<p>
<div class="fragment"><pre class="fragment">gdb fibonacci
(gdb) target remote :45462
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:37
(gdb)
</pre></div><p>
Let's look at the code in the tool that connects to the debugger now.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> ConnectDebugger()
{
    <span class="keywordflow">if</span> (<a class="code" href="group__APPDEBUG__API.html#gf5d23fef76d1846b74cc1c4b61813e93">PIN_GetDebugStatus</a>() != <a class="code" href="group__APPDEBUG__API.html#gg2873b12faab265843028e2f388009e98dd4a10be1cb388a9ab2d82855be8fcfc">DEBUG_STATUS_UNCONNECTED</a>)
        <span class="keywordflow">return</span>;

    <a class="code" href="structDEBUG__CONNECTION__INFO.html">DEBUG_CONNECTION_INFO</a> info;
    <span class="keywordflow">if</span> (!<a class="code" href="group__APPDEBUG__API.html#g88a899a52d6a26fb8d43f239fe0b7518">PIN_GetDebugConnectionInfo</a>(&amp;info) || info.<a class="code" href="structDEBUG__CONNECTION__INFO.html#208cf456b6613ddc3c964386f8bbbbff">_type</a> != <a class="code" href="group__APPDEBUG__API.html#gg0ed05063ceaa339416ac7156e97de9db08b522b6be460c66d44a60258dbbdcd5">DEBUG_CONNECTION_TYPE_TCP_SERVER</a>)
        <span class="keywordflow">return</span>;

    *Output &lt;&lt; <span class="stringliteral">"Triggered stack-limit breakpoint.\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"Start GDB and enter this command:\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"  target remote :"</span> &lt;&lt; std::dec &lt;&lt; info.<a class="code" href="structDEBUG__CONNECTION__INFO.html#6db2e405e179244e88f096a69b78a3ea">_tcpServer</a>.<a class="code" href="struct__tcpServerStruct.html#2282227ed88e7a4cc12c6df5d9abf76e">_tcpPort</a> &lt;&lt; <span class="stringliteral">"\n"</span>;
    *Output &lt;&lt; std::flush;

    <span class="keywordflow">if</span> (<a class="code" href="group__APPDEBUG__API.html#g10470a2efb23fe149125a72fcf6ac337">PIN_WaitForDebuggerToConnect</a>(1000*KnobTimeout.Value()))
        <span class="keywordflow">return</span>;

    *Output &lt;&lt; <span class="stringliteral">"No debugger attached after "</span> &lt;&lt; KnobTimeout.Value() &lt;&lt; <span class="stringliteral">" seconds.\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"Resuming application without stopping.\n"</span>;
    *Output &lt;&lt; std::flush;
}
</pre></div><p>
The ConnectDebugger() function is called each time the tool wants to stop at a breakpoint. It first calls <a class="el" href="group__APPDEBUG__API.html#gf5d23fef76d1846b74cc1c4b61813e93">PIN_GetDebugStatus()</a> to see if Pin is already connected to a debugger. If not, it uses <a class="el" href="group__APPDEBUG__API.html#g88a899a52d6a26fb8d43f239fe0b7518">PIN_GetDebugConnectionInfo()</a> to get the TCP port number that is needed to connect GDB to Pin. This is, for example, the "45462" number that the user types in the "target remote" command. After asking the user to start GDB, the tool then calls <a class="el" href="group__APPDEBUG__API.html#g10470a2efb23fe149125a72fcf6ac337">PIN_WaitForDebuggerToConnect()</a> to wait for GDB to connect. If the user doesn't start GDB after a timeout period, the tool prints a message and then continues executing the application.<p>
As before, you can either continue the application and let it terminate, or you can quit from the debugger:<p>
<div class="fragment"><pre class="fragment">(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre></div><h3><a class="anchor" name="APPDEBUG_WINDOWS">
Advanced Debugging Extensions on Windows</a></h3>
On Windows, the advanced debugging extensions work with Microsoft Visual Studio 2012. There is no support for earlier versions of Visual Studio, so make sure you have that version installed. Also, the Express edition of Visual Studio doesn't support IDE extensions, so it will not work with the Pin debugger extensions. Therefore, you must install the Professional edition (or greater). If you are a student, you may be able to get the Professional edition for free. Check the Microsoft web site or with your school's IT department for details.<p>
After you have installed Visual Studio, you must also install the Pin extension for Visual Studio. Look for an installer named "pinadx-vsextension-X.Y.Z.msi" in the root of the Pin kit.<p>
If you are developing a Pintool, you must also use Visual Studio to build the tool. However, there is not yet support for building Pintools with Visual Studio 2012. As a result, you must also install either Visual Studio 2010 or 2008 in order to build your tool. You can use any edition to build a Pintool, even the free Express edition.<p>
The remainder of this section assumes that you are able to build the "stack-debugger" tool, so if you want to follow along, you must have the following software installed:<p>
<ul>
<li>Visual Studio 2012, Professional edition (or greater).</li><li>The Pin debugger extension for Visual Studio 2012 (pinadx-vsextension-X.Y.Z.msi).</li><li>Either Visual Studio 2010 or 2008, any edition.</li></ul>
<p>
In order to start this tutorial, you will probably want to build the example tool "stack-debugger.cpp", which is available in the directory "source\tools\ManualExamples". To do this, open a Visual Studio command shell and type the following commands. (Use "TARGET=intel64" instead, if you want to build a 64-bit version of the tool.)<p>
<div class="fragment"><pre class="fragment">C:\&gt; cd source\tools\ManualExamples
C:\&gt; make TARGET=ia32 obj-ia32/stack-debugger.dll
</pre></div><p>
After you have done this, start Visual Studio 2012 and open the sample solution file at "source\tools\ManualExamples\stack-debugger-tutorial.sln". Then build the sample application "fibonacci" by pressing F7. Make sure you can run the application natively by pressing CTRL-F5.<p>
Now let's try running the "fibonacci" application under Pin with the "stack-debugger" tool. To do this, you must first set the "Pin Kit Directory" from TOOLS-&gt;Options-&gt;Pin Debugger.<p>
<div align="center">
<img src="pin-debugger-option-pages-properties.png" alt="pin-debugger-option-pages-properties.png">
</div>
<p>
Then you have to adjust the "fibonacci" project properties in Visual Studio 2012: right-click on the "fibonacci" project in the Solution Explorer, choose Properties, and then click on Debugging. Change the drop-down titled "Debugger to launch" to "Pin Debugger" as shown in the figure below.<p>
<div align="center">
<img src="pin-debugger-project-properties1.png" alt="pin-debugger-project-properties1.png">
</div>
<p>
Then, set the "Pin Tool Path" property by browsing to the "stack-debugger.dll". Press OK when you are done.<p>
<div align="center">
<img src="pin-debugger-project-properties2.png" alt="pin-debugger-project-properties2.png">
</div>
<p>
Visual Studio is now configured to run the "fibonacci" application under your Pin tool. However, before you continue, set a breakpoint in "main()" so that execution stops in the debugger. Then press F5 to start debugging.<p>
You should now see a normal-looking debugger session, although your application is really running under control of Pin. All of the debugger features still work as you would expect. You can set breakpoints, continue execution, display the values of variables, and even view the disassembled code. All of the information that you observe in the debugger shows the application's "pure" state. The details of Pin and the tool's instrumentation are hidden. For example, the disassembly view shows only the application's instructions, not any of the instructions inserted by the tool. However, when you continue execution (e.g. with F5 or F10), the application executes along with your tool's instrumentation code.<p>
Now, let's see an alternative way to debug the "fibonacci" application under Pin with the "stack-debugger" tool in Visual Studio 2012. After you have built the "stack-debugger" tool, open a command shell and start the application with the debugging extensions enabled. This will cause Pin to stop immediately before the first instruction.<p>
<div class="fragment"><pre class="fragment">C:\&gt; cd source\tools\ManualExamples
C:\&gt; ..\..\..\pin -appdebug -t obj-ia32\stack-debugger.dll -- debug\fibonacci.exe 1000
Application stopped until continued from debugger.
Pin ready to accept debugger connection on port 30840
</pre></div><p>
Open the source.cpp in Visual Studio 2012 and set a breakpoint to stop the execution in the debugger. To attach with Visual Studio to the process that is running under Pin, select "Attach to Pin Process" on the DEBUG menu. Select from the Available Processes table the "fibonacci" process, enter the port number that Pin printed and click Attach.<p>
<div align="center">
<img src="pin-debugger-attach.png" alt="pin-debugger-attach.png">
</div>
<h4><a class="anchor" name="APPDEBUG_WINDOWS_COMMANDS">
Adding New Debugger Commands</a></h4>
The previous section illustrated how you can enable the normal debugger features while running an application under Pin. Now, let's see how your Pintool can add new custom debugger commands, even without changing Visual Studio. Custom debugger commands are useful because they allow you to control your Pintool interactively from within a live debugger session. For example, you can ask your Pintool to print out information that it has collected, or you can interactively enable instrumentation only for certain phases of the application.<p>
To illustrate, see the call to <a class="el" href="group__APPDEBUG__API.html#g5c3c5c6220acfad8860218b41410b07a">PIN_AddDebugInterpreter()</a> in the stack-debugger tool. That API sets up the following call-back function:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> BOOL DebugInterpreter(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <span class="keyword">const</span> string &amp;cmd, string *result, VOID *)
{
    TINFO_MAP::iterator it = ThreadInfos.find(tid);
    <span class="keywordflow">if</span> (it == ThreadInfos.end())
        <span class="keywordflow">return</span> FALSE;
    TINFO *tinfo = it-&gt;second;

    std::string line = TrimWhitespace(cmd);
    *result = <span class="stringliteral">""</span>;

    <span class="comment">// [...]</span>

    <span class="keywordflow">if</span> (line == <span class="stringliteral">"stats"</span>)
    {
        ADDRINT sp = <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
        tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
        <span class="keywordflow">if</span> (sp &lt;= tinfo-&gt;_stackBase)
            tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Current stack usage: "</span> &lt;&lt; std::dec &lt;&lt; (tinfo-&gt;_stackBase - sp) &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        <span class="keywordflow">else</span>
            tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Current stack usage: -"</span> &lt;&lt; std::dec &lt;&lt; (sp - tinfo-&gt;_stackBase) &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Maximum stack usage: "</span> &lt;&lt; tinfo-&gt;_max &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        *result = tinfo-&gt;_os.str();
        <span class="keywordflow">return</span> TRUE;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (line == <span class="stringliteral">"stacktrace on"</span>)
    {
        <span class="keywordflow">if</span> (!EnableInstrumentation)
        {
            <a class="code" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation</a>();
            EnableInstrumentation = <span class="keyword">true</span>;
            *result = <span class="stringliteral">"Stack tracing enabled.\n"</span>;
        }
        <span class="keywordflow">return</span> TRUE;
    }

    <span class="comment">// [...]</span>

    <span class="keywordflow">return</span> FALSE;  <span class="comment">// Unknown command</span>

}
</pre></div><p>
The <a class="el" href="group__APPDEBUG__API.html#g5c3c5c6220acfad8860218b41410b07a">PIN_AddDebugInterpreter()</a> API allows a Pintool to establish a handler for extended debugger commands. For example, the code snippet above implements the new commands "stats" and "stacktrace on". You can execute these commands in Visual Studio by opening "DEBUG-&gt;Windows-&gt;Pin Console" in the IDE.<p>
<div align="center">
<img src="stack-debugger-commands.png" alt="stack-debugger-commands.png">
</div>
<p>
A Pintool can do various things when the user types an extended debugger command. For example, the "stats" command prints out some information that the tool has collected. Any text that the tool writes to the "result" parameter is printed to the Visual Studio Pin Console window. Note that the CONTEXT parameter has the register state for the debugger's "focus" thread, so the tool can easily display information about this focus thread.<p>
You can also use an extended debugger command to interactively enable or disable instrumentation in your Pintool, as demonstrated by the "stacktrace on" command. For example, if you wanted to quickly run your Pintool over the application's initial start-up phase, you could run with your Pintool's instrumentation disabled until a breakpoint is triggered. Then, you could use an extended command to enable instrumentation only during the interesting part of the application. In the stack-debugger example above, the call to <a class="el" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation()</a> causes Pin to discard any previous instrumentation, so the tool re-instruments the code when the debugger continues execution of the application. As we will see later, the tool's global variable "EnableInstrumentation" adjusts the instrumentation that it inserts.<h4><a class="anchor" name="APPDEBUG_WINDOWS_BREAK">
Semantic Breakpoints</a></h4>
The last major feature of the advanced debugging extensions is the ability to stop execution at a breakpoint by calling an API from your tool's analysis code. This may sound simple, but it is very powerful. Your Pintool can use instrumentation to look for a complex condition and then stop at a breakpoint when that condition occurs.<p>
The "stack-debugger" tool illustrates this by using instrumentation to observe all the instructions that allocate stack space, and then it stops at a breakpoint whenever the application's stack usage reaches some threshold. In effect, this adds a new feature to the debugger that could not be practically implemented using traditional debugger technology because a traditional debugger can not reasonably find all the instructions that allocate stack space. A Pintool, however, can do this quite easily via instrumentation.<p>
The example code below from the "stack-debugger" tool uses Pin instrumentation to identify all the instructions that allocate stack space.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> VOID Instruction(INS ins, VOID *)
{
    <span class="keywordflow">if</span> (!EnableInstrumentation)
        <span class="keywordflow">return</span>;

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain</a>(ins, REG_STACK_PTR))
    {
        <a class="code" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>;
        <span class="keywordflow">if</span> (!<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g85371f49008f053ffa09ac242ae1c9e3">INS_HasFallThrough</a>(ins))
            where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21e3df50f902d3b951e0a8ab8afbcf2902">IPOINT_TAKEN_BRANCH</a>;

        <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, where, (AFUNPTR)OnStackChangeIf, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, REG_STACK_PTR,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, RegTinfo, IARG_END);
        <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, where, (AFUNPTR)DoBreakpoint, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568152f3e4ae9dfb93f4691d7342ee937c4d">IARG_CONST_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);
    }
}
</pre></div><p>
The call to <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain()</a> tests whether an instruction modifies the stack pointer. If it does, we insert an analysis call immediately after the instruction, which checks to see if the application's stack usage exceeds a threshold.<p>
Also notice that all the instrumentation is gated by the global flag "EnableInstrumentation", which we saw earlier in the "stacktrace on" command. Thus, the user can disable instrumentation (with "stacktrace off") in order to execute quickly through uninteresting parts of the application, and then re-enable it (with "stacktrace on") for the interesting parts.<p>
The analysis routine OnStackChangeIf() returns TRUE if the application's stack usage has exceeded the threshold. When this happens, the tool calls the DoBreakpoint() analysis routine, which will stop at the debugger breakpoint. Notice that we use if / then instrumentation here because the call to DoBreakpoint() requires a "CONTEXT *" parameter, which can be slow.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> ADDRINT OnStackChangeIf(ADDRINT sp, ADDRINT addrInfo)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(addrInfo);

    <span class="comment">// The stack pointer may go above the base slightly.  (For example, the application's dynamic</span>
    <span class="comment">// loader does this briefly during start-up.)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (sp &gt; tinfo-&gt;_stackBase)
        <span class="keywordflow">return</span> 0;

    <span class="comment">// Keep track of the maximum stack usage.</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - sp;
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_max)
        tinfo-&gt;_max = size;

    <span class="comment">// See if we need to trigger a breakpoint.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (BreakOnNewMax &amp;&amp; size &gt; tinfo-&gt;_maxReported)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">if</span> (BreakOnSize &amp;&amp; size &gt;= BreakOnSize)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> VOID DoBreakpoint(<span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, RegTinfo));

    <span class="comment">// Keep track of the maximum reported stack usage for "stackbreak newmax".</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_maxReported)
        tinfo-&gt;_maxReported = size;

    ConnectDebugger();  <span class="comment">// Ask the user to connect a debugger, if it is not already connected.</span>

    <span class="comment">// Construct a string that the debugger will print when it stops.  If a debugger is</span>
    <span class="comment">// not connected, no breakpoint is triggered and execution resumes immediately.</span>
    <span class="comment">//</span>
    tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
    tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Thread "</span> &lt;&lt; std::dec &lt;&lt; tid &lt;&lt; <span class="stringliteral">" uses "</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">" bytes of stack."</span>;
    <a class="code" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, tinfo-&gt;_os.str());
}
</pre></div><p>
The analysis routine OnStackChangeIf() keeps track of some metrics on stack usage and tests whether the threshold has been reached. If the threshold is crossed, it returns non-zero, and Pin executes the DoBreakpoint() analysis routine.<p>
The interesting part of DoBreakpoint() is at the very end, where it calls <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>. This API causes Pin to stop the execution of all threads and triggers a breakpoint in the debugger. There is also a string parameter to <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>, which is displayed in Visual Studio when the breakpoint triggers. A Pintool can use this string to tell the user why a breakpoint triggered. In our example tool, this string says something like "Thread 10 uses 4000 bytes of stack".<p>
We can see the breakpoint feature in action in our example tool by typing this command in the Pin Console window:<p>
<div class="fragment"><pre class="fragment">&gt;stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.
</pre></div><p>
Then press F5 to continue execution. The application should stop in the debugger again with a message like this:<p>
<div align="center">
<img src="stack-debugger-custom-break.png" alt="stack-debugger-custom-break.png">
</div>
<p>
When you are done, you can either continue the application with F5 or terminate it with SHIFT-F5.<h3><a class="anchor" name="APPDEBUG_OSX">
Advanced Debugging Extensions on OS X*</a></h3>
Pin's debugging extensions on OS X are very similar to Linux, with the one exception that the debugger used is LLDB. To work with LLDB, the -appdebug_lldb_options flag must be specified at the pin command line.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -appdebug -appdebug_lldb_options -t obj-intel64/stack-debugger.dylib -- obj-intel64/fibonacci 1000
Application stopped until continued from debugger.
Start GDB, then issue this command at the (gdb) prompt:
  target remote :33030
</pre></div><p>
<dl compact><dt><b>Warning:</b></dt><dd>For the debugger extensions to work properly, they require the target application symbols. Make sure to call <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> in your pintool.</dd></dl>
======================================================================================== <h2><a class="anchor" name="EX">
Applying a Pintool to an Application</a></h2>
========================================================================================<p>
An application and a tool are invoked as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..
</pre></div><p>
These are a few of the Pin options are currently available. See <a class="el" href="group__KNOBS.html">Command Line Switches</a> for the complete list. <ul>
<li>
-t <em>toolname</em>: Specifies the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an Intel(R) 64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 &lt;64-bit toolname&gt; to specify the 64-bit tool binary followed by -t &lt;32-bit toolname&gt; to specify the 32-bit tool binary and the tool options. For more information, see <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-t64 <em>toolname</em>: Specify 64-bit tool binary for Intel(R) 64 architecture. If you are running an application on an Intel(R) 64 architecture, where components in the chain are both 32-bit and 64-bit, use -t64 together with -t as described above. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a>. <br>
 <b>Important</b>: Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool. </li>
<li>
-p32 <em>toolname</em>: Specify Pin binary for IA-32 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-p64 <em>toolname</em>: Specify Pin binary for Intel(R) 64 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-pause_tool n: is a useful Pin-option which prints out the process id and pauses Pin for n seconds to permit attaching with gdb. See <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a>. </li>
<li>
-follow_execv: Execute with Pin all processes spawned by execv class system calls. </li>
<li>
-injection <em>mode</em>: Where <em>mode</em> is one of dynamic, self, child, parent. <em>UNIX-only</em> See <a class="el" href="index.html#INJECTION">Injection</a>.<p>
</li>
</ul>
<p>
The tool-options follow immediately after the tool specification and depend on the tool used.<p>
Everything following the <code>--</code> is the command line for the application.<p>
For example, to apply the itrace example (<a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a>) to a run of the "ls" program:<p>
<div class="fragment"><pre class="fragment">../../../pin -t obj-intel64/itrace.so -- /bin/ls
</pre></div><p>
To get a listing of the available command line options for Pin:<p>
<div class="fragment"><pre class="fragment">pin -help
</pre></div><p>
To get a listing of the available command line options for the itrace example:<p>
<div class="fragment"><pre class="fragment">../../../pin -t obj-intel64/itrace.so -help -- /bin/ls
</pre></div><p>
Note that in the last case <code>/bin/ls</code> is necessary on the command line but will not be executed.<h3><a class="anchor" name="MIXED-MODE">
Instrumenting Applications on Intel(R) 64 Architectures</a></h3>
The Pin kit for IA-32 and Intel(R) 64 architectures is a combined kit. Both a 32-bit version and a 64-bit version of Pin are present in the kit. This allows Pin to instrument complex applications on Intel(R) 64 architectures which may have 32-bit and 64-bit components.<p>
An application and a tool are invoked in "mixed-mode" as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t64 &lt;64-bit toolname&gt; -t &lt;32-bit toolname&gt; [tool-options]...
-- &lt;application&gt; [application-option]..
</pre></div><p>
Please note:<ul>
<li>The -t64 option must precede the -t option.</li><li>When using -t64 together with -t, -t specifies the 32-bit tool. Using -t64 without -t is not recommended, since in this case when given a 32-bit application, Pin will run the application without applying any tool.</li><li>The <em>[tool-options]</em> apply to both the 64-bit and the 32-bit tools and <b>must</b> be specified <b>after</b> <em>-t &lt;32-bit toolname&gt;</em>. It is not possible to specify different set of options for the 64-bit and the 32-bit tools.</li></ul>
<p>
See source/tools/CrossIa32Intel64/makefile for a few examples.<p>
The file "pin" is a c-based launcher executable that expects the Pin binary "pinbin" to be in the architecture-specific "bin" subdirectory (i.e. intel64/bin). The "pin" launcher distinguishes the 32-bit version of the Pin binary from the 64-bit version of the Pin binary by using the -p32/-p64 switches, respectively. Today, the 32-bit version of the Pin binary is invoked, and the path of the 64-bit version of Pin is passed as an argument using the -p64 switch. However, one could change this to invoke the 64-bit version of the Pin binary, and pass the 32-bit version of the Pin binary as an argument using the -p32 switch.<h3><a class="anchor" name="INJECTION">
Injection</a></h3>
The -injection switch is UNIX-only and controls the way pin is injected into the application process. The default, dynamic, is recommended for all users. It uses parent injection unless it is unsupported (Linux 2.4 kernels). Child injection creates the application process as a child of the pin process so you will see both a pin process and the application process running. In parent injection, the pin process exits after injecting the application and is less likely to cause a problem. Using parent injection on an unsupported platform may lead to nondeterministic errors.<p>
IMPORTANT: The description about invoking assumes that the application is a program binary (and not a shell script). If your application is invoked indirectly (from a shell script or using 'exec') then you need to change the actual invocation of the program binary by prefixing it with pin/pintool options. Here's one way of doing that:<p>
<div class="fragment"><pre class="fragment"> # Track down the actual application binary, say it is 'application_binary'.
 % mv application_binary application_binary.real

 # Write a shell script named 'application_binary' with the following contents.
 # (change 'itrace' to your desired tool)

 #!/bin/sh
 ../../../pin -t obj-intel64/itrace.so -- application_binary.real $*
</pre></div><p>
After you do this, whenever 'application_binary' is invoked indirectly (from some shell script or using 'exec'), the real binary will get invoked with the right pin/pintool options.<h3><a class="anchor" name="PINTOOL_RESTRICTIONS">
Restrictions</a></h3>
There is a known problem of using pin on systems protected by the "McAfee Host Intrusion Prevention"* antivirus software. We did not test coexistence of pin with other antivirus products that perform run-time execution monitoring.<p>
There is a known limitation of using Pin on Linux systems that prevent the use of ptrace attach via the sysctl /proc/sys/kernel/yama/ptrace_scope. Pin will still work when launching applications with the pin command line. However, Pin will fail in attach mode (that is, using the -pid knob). To resolve this, do the following (as root): <div class="fragment"><pre class="fragment">$ echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="DEBUGGING">
Tips for Debugging a Pintool</a></h2>
========================================================================================<h3><a class="anchor" name="XXX">
Using gdb on Linux</a></h3>
When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The pintool is normally a shared object loaded by Pin. This section describes how to use gdb to find bugs in a Pintool. You cannot run Pin directly from gdb since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use gdb to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds.<p>
Pin searches for the tool in an internal search algorithm. Therefore in many cases gdb is unable to load the debug info for the tool. There are several options to help gdb find the debug info.<p>
Option 1 is to use full path to the tool when running pin.<p>
Option 2 is to tell gdb to load the debugging information of the tool. Pin prompts with the exact gdb command to be used in this case.<p>
To check that gdb loaded the debugging info to the tool use the command "info sharedlibrary" and you should see that gdb has read the symbols for your tool (as in the example below).<p>
<div class="fragment"><pre class="fragment">(gdb) info sharedlibrary
From        To          Syms Read   Shared Object Library
0x001b3ea0  0x001b4d80  Yes         /lib/libdl.so.2
0x003b3820  0x00431d74  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libstdc++.so.6
0x0084f4f0  0x00866f8c  Yes         /lib/i686/libm.so.6
0x00df8760  0x00dffcc4  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libgcc_s.so.1
0x00e5fa00  0x00f60398  Yes         /lib/i686/libc.so.6
0x40001c50  0x4001367f  Yes         /lib/ld-linux.so.2
0x008977f0  0x00af7784  Yes         ./dcache.so
</pre></div><p>
For example, if your tool is called opcodemix and the application is /bin/ls, you can use gdb as described below. The following example is for the Intel(R) 64 Linux platform. Substitute "ia32" for the IA-32 architecture.<p>
Change directory to the directory where your tool resides, and start gdb with pin, but do not use the run command.<p>
<div class="fragment"><pre class="fragment">$ /usr/bin/gdb ../../../intel64/bin/pinbin
GNU gdb Red Hat Linux (6.3.0.0-1.132.EL4rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu"...Using host libthread_db library "/lib64/tls/libthread_db.so.1"
(gdb)
</pre></div><p>
In another window, start your application with the -pause_tool switch.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -pause_tool 10 -t obj-intel64/opcodemix.so -- /bin/ls
Pausing for 10 seconds to attach to process with pid 28769
To load the tool's debug info to gdb use:
   add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
</pre></div><p>
Then go back to gdb and attach to the process.<p>
<div class="fragment"><pre class="fragment">(gdb) attach 28769
Attaching to program: .../intel64/bin/pinbin, process 28769
0x000000314b38f7a2 in ?? ()
(gdb)
</pre></div><p>
Now, you should tell gdb to load the Pintool debugging information, by copying the debugging message we got when invoking pin with the -pause_tool switch..<p>
<div class="fragment"><pre class="fragment">(gdb) add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
add symbol table from file ".../source/tools/SimpleExamples/obj-intel64/opcodemix.so" at
        .text_addr = 0x2a959e9830
        (y or n) y
        Reading symbols from .../source/tools/SimpleExamples/obj-intel64/opcodemix.so...done.
(gdb)
</pre></div><p>
Now, instead of using the gdb run command, you use the <code>cont</code> command to continue execution. You can also set breakpoints as normal.<p>
<div class="fragment"><pre class="fragment">(gdb) b opcodemix.cpp:447
Breakpoint 1 at 0x2a959ecf60: file opcodemix.cpp, line 447.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=7, argv=0x3ff00f12f8) at opcodemix.cpp:447
447     int main(int argc, CHAR *argv[])
(gdb)
</pre></div><p>
If the program does not exit, then you should detach so gdb will release control.<p>
<div class="fragment"><pre class="fragment">(gdb) detach
Detaching from program: .../intel64/bin/pinbin, process 28769
(gdb)
</pre></div><p>
If you recompile your program and then use the run command, gdb will notice that the binary has been changed and reread the debug information from the file. This does not always happen automatically when using attach. In this case you must use the "add-symbol-file" command again to make gdb reread the debug information.<h3><a class="anchor" name="DBG">
Using the Visual Studio Debugger on Windows</a></h3>
When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The pintool is a dynamically loaded library (.dll) loaded by Pin. This section describes how to use the Visual Studio Debugger to find bugs in a Pintool. You cannot run Pin directly from the debugger since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use Visual Studio to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds. You have n seconds (20 in our example) to attach the application with the debugger. Note, application resumes once the timeout expires. Attaching debugger later will not have the desired effect.<p>
<div class="fragment"><pre class="fragment"> % pin &lt;pin options&gt; -pause_tool 20 -t &lt;tool name&gt;  &lt;tool options&gt; -- &lt;app name&gt; &lt;app options&gt;
Pausing for 20 seconds to attach to process with pid 28769
</pre></div><p>
In the Visual Studio window, attach to the application process using the "Debug"-&gt;"Attach to Process" menu selection and wait until a breakpoint occurs. Then you can set breakpoints in your tool in the usual way.<p>
Note, it is necessary to build your pin tool with debug symbols if you want symbolic information.<p>
======================================================================================== <h2><a class="anchor" name="LOGGING">
Logging Messages from a Pintool</a></h2>
========================================================================================<p>
Pin provides a mechanism to write messages from a Pintool to a logfile. To use this capability, call the LOG() API with your message. The default filename is pintool.log, and it is created in the currently working directory. Use the -logfile switch after the tool name to change the path and file name of the log file.<p>
<div class="fragment"><pre class="fragment">LOG( <span class="stringliteral">"Replacing function in "</span> + <a class="code" href="group__IMG__BASIC__API.html#g491b26d161526b35498839f5cdf30a76">IMG_Name</a>(img) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Address = "</span> + <a class="code" href="group__MISC__PRINT.html#g87f513d501545295d33610f0d81dac5f">hexstr</a>( <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn)) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Image ID = "</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>( <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img) ) + <span class="stringliteral">"\n"</span> );
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="PERFORMANCE">
Performance Considerations When Writing  a Pintool</a></h2>
========================================================================================<p>
The way a Pintool is written can have great impact on the performace of the tool, i.e. how much it slows down the applications it is instrumenting. This section demonstrates some techniques that can be used to improve tool performance. Let's start with an example. The following piece of code is derived from the source/tools/SimpleExamples/edgcnt.cpp:<p>
The instrumentation component of the tool is show below<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

      <span class="keywordflow">if</span> ( [ins is a branch or a call instruction] )
      {


        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       IARG_END);
      }

      ...
}
</pre></div><p>
The analysis component looks like this: <div class="fragment"><pre class="fragment">VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken )
{
    <span class="keywordflow">if</span>(!taken) <span class="keywordflow">return</span>;
    COUNTER *pedg = Lookup( src,dst );
    pedg-&gt;_count++;
}
</pre></div><p>
The purpose of the tool is to count how often each controlflow changing edge in the control flowgraph is traversed. The tool considers both calls and branches but for brevity we will not mention branches in our description. The tool works as follows: The instrumentation component instruments each branch with a call to docount2. As parameters we pass in the origin and the target of the branch and whether the branch was taken or not. Branch origin and target represent of the source and destination of the controlflow edges. If a branch is not taken the controlflow does not change and hence the analysis routine returns right away. If the branch is taken we use the src and dst parameters to look up the counter associated with this edge (Lookup will create a new one if this edge has not been seen before) and increment the counter. Note, that the tool could have been simplified somewhat by using IPOINT_TAKEN_BRANCH option with <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall()</a>.<h3><a class="anchor" name="shifting_computation">
Shifting Computation for Analysis to Instrumentation Code</a></h3>
About every 5th instruction executed in a typical application is a branch. Lookup will called whenever these instruction are executed, causing significant application slowdown. To improve the situation we note that the instrumentation code is typically called only once for every instruction, while the analysis code is called everytime the instruction is executed. If we can somehow shift computation from the analysis code to the instrumentation code we will improve the overall performance. Our example tools offer multiple such opportunites which will explore in turn. The first observation is that for most branches we can find out inside of Instruction() what the branch target will be . For those branches we can call Lookup inside of Instruction() rather than in docount2(), for indirect branches which are relatively rare we still have to use our original approach. All this is reflected in the folling code. We add a second "lighter" analsysis function, docount. While the original docount2() remains unchanged:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    <span class="keywordflow">if</span>( !taken ) <span class="keywordflow">return</span>;
    pedg-&gt;_count++;
}
</pre></div><p>
And the instrumentation will be somewhat more complex:<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g64333f9a28052aabc341a7a0d3c16aec">INS_IsDirectBranchOrCall</a>(ins))
    {
        COUNTER *pedg = Lookup( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#gd3b5f975c84b126531b38930b94b5544">INS_Address</a>(ins),  <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ga52df2852835cd0938a5f2c0e81aaecd">INS_DirectBranchOrCallTargetAddress</a>(ins) );

        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, pedg,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       IARG_END);
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       IARG_END);
    }

      ...
}
</pre></div><h3><a class="anchor" name="control_flow">
Eliminating Control Flow</a></h3>
The code for docount() is very compact which provides performance advantages; it may also allow it to be inlined by Pin, thereby avoiding the overhead of a call. The heuristics for when a analysis routine is inlined by Pin are subject to change. But small routines without any control flow (single basic block) are almost guaranteed to be inlined. Unfortunately, docount() does have (albeit limited) control flow. Observing that the parameter, 'taken', will be zero or one we can eliminate the remaining control flow as follows:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    pedg-&gt;_count += taken;
}
</pre></div><p>
Now docount() can be inlined.<h3><a class="anchor" name="compiler_inlining">
Compiler Considerations for Inlining</a></h3>
The way that the tool is built affects inlining as well. If an analysis routine has a function call to another function, it would not be a candidate for inlining by Pin unless the function call was inlined by the compiler. If the function call is inlined by the compiler, the analysis routine would be a candidate for inlining by Pin. Therefore, it is advisable to write any subroutines called by the analysis routine in a way that allows the compiler to inline the subroutines.<p>
On Linux IA-32 architectures, Pin tools are built non-PIC (Position Independent Code), which allows the compiler to inline both local and global functions. Tools for Linux Intel(R) 64 architectures are built PIC, but the compiler will not inline any globally visible function due to function pre-emption. Therefore, it is advisable to declare the subroutines called by the analysis function as 'static' on Linux Intel(R) 64 architectures.<h3><a class="anchor" name="let_pin_decide">
Letting Pin Decide Where to Instrument</a></h3>
At times we do not care about the exact point where calls to analysis code are being inserted as long as it is within a given basic block. In this case we can let Pin make the decission where to insert. This has the advantage that Pin can select am insertion point that requires minimal register saving and restoring. The following code from ManualExamples/inscount2.cpp shows how this is done for the instruction count example using IPOINT_ANYWHERE with <a class="el" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

ofstream OutFile;

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
<span class="comment">// Use the fast linkage for calls</span>
VOID <a class="code" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a> docount(ADDRINT c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        <span class="comment">// IPOINT_ANYWHERE allows Pin to schedule the call anywhere in the bbl to obtain best performance.</span>
        <span class="comment">// Use a fast linkage for the call.</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a2198931604835e0f9ad1cd29cc1bc1f384">IPOINT_ANYWHERE</a>, AFUNPTR(docount), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), IARG_END);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g0261da0abe384db4e2f97cd31cf986f7">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="fast_linkage">
Using Fast Call Linkages</a></h3>
For very small analysis functions, the overhead to call the function can be comparable to the work done in the function. Some compilers offer optimized call linkages that eliminate some of the overhead. For example, gcc for the IA-32 architecture has a regparm attribute for passing arguments in registers. Pin supports a limited number of alternate linkages. To use it, you must annotate the declaration of the analysis function with <a class="el" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a>. The InsertCall function must pass <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>. If you change one without changing the other, the arguments will not be passed correctly. See the inscount2.cpp example in the previous section for a sample use. For large analysis functions, the benefit may not be significant, but it is unlikely that PIN_FAST_ANALYSIS_CALL would ever cause a slowdown.<p>
Another call linkage optimization is to eliminate the frame pointer. We recommend using -fomit-frame-pointer to compile tools with gcc. See the gcc documentation for an explanation of what it does. The standard Pintool makefiles include -fomit-frame-pointer. Like PIN_FAST_ANALYSIS_CALL, the benefit is largest for small analysis functions. Debuggers rely on frame pointers to display stack traces, so eliminate this option when trying to debug a PinTool. If you are using a standard PinTool makefile, you can do this by overriding the definition of OPT on the command line with<p>
<div class="fragment"><pre class="fragment">make OPT=-O0
</pre></div><h3><a class="anchor" name="partial_inline">
Rewriting Conditional Analysis Code to Help Pin Inline</a></h3>
Pin improves instrumentation performance by automatically inlining analysis routines that have no control-flow changes. Of course, many analysis routines do have control-flow changes. One particularly common case is that an analysis routine has a single "if-then" test, where a small amount of analysis code plus the test is always executed but the "then" part is executed only once a while. To inline this common case, Pin provides a set of conditional instrumentation APIs for the tool writer to rewrite their analysis routines into a form that does not have control-flow changes. The following example from source/tools/ManualExamples/isampling.cpp illustrates how such rewriting can be done:<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains a Pintool for sampling the IPs of instruction executed.</span>
<span class="comment"> *  It serves as an example of a more efficient way to write analysis routines</span>
<span class="comment"> *  that include conditional tests.</span>
<span class="comment"> *  Currently, it works on IA-32 and Intel(R) 64 architectures.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="keyword">const</span> INT32 N = 100000;
<span class="keyword">const</span> INT32 M =  50000;

INT32 icount = N;

<span class="comment">/*</span>
<span class="comment"> *  IP-sampling could be done in a single analysis routine like:</span>
<span class="comment"> *</span>
<span class="comment"> *        VOID IpSample(VOID *ip)</span>
<span class="comment"> *        {</span>
<span class="comment"> *            --icount;</span>
<span class="comment"> *            if (icount == 0)</span>
<span class="comment"> *            {</span>
<span class="comment"> *               fprintf(trace, "%p\n", ip);</span>
<span class="comment"> *               icount = N + rand() % M;</span>
<span class="comment"> *            }</span>
<span class="comment"> *        }</span>
<span class="comment"> *</span>
<span class="comment"> *  However, we break IpSample() into two analysis routines,</span>
<span class="comment"> *  CountDown() and PrintIp(), to facilitate Pin inlining CountDown()</span>
<span class="comment"> *  (which is the much more frequently executed one than PrintIp()).</span>
<span class="comment"> */</span>

ADDRINT CountDown()
{
    --icount;
    <span class="keywordflow">return</span> (icount==0);
}


<span class="comment">// The IP of the current instruction will be printed and</span>
<span class="comment">// the icount will be reset to a random number between N and N+M.</span>
VOID PrintIp(VOID *ip)
{
    fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip);
    
    <span class="comment">// Prepare for next period</span>
    icount = N + rand() % M; <span class="comment">// random number from N to N+M</span>
}


<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// CountDown() is called for every instruction executed</span>
    <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)CountDown, IARG_END);
    
    <span class="comment">// PrintIp() is called only when the last CountDown() returns a non-zero value.</span>
    <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)PrintIp, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, IARG_END);
    
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR( <span class="stringliteral">"This Pintool samples the IPs of instruction executed\n"</span>
                + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"isampling.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#gad5fd5cdd6c1cd37e57a1264e93b0435">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g49a870141067fb2a4ae0c8fd09a04ccb">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In the above example, the original analysis routine IpSample() has a conditional control-flow change. It is rewritten into two analysis routines: CountDown() and PrintIp(). CountDown() is the simpler one of the two, which doesn't have control-flow change. It also performs the original conditional test and returns the test result. We use the conditional instrumentaton APIs <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> and <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> to tell Pin that tbe analysis routine specified by an <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> (i.e. PrintIp() in this example) is executed only if the result of the analysis routine specified by the previous <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> (i.e. CountDown() in this example) is non-zero. Now CountDown(), the common case, can be inlined by Pin, and only once a while does Pin need to execute PrintIp(), the non-inlined case.<h3><a class="anchor" name="handling_reps">
Optimizing Instrumentation of REP Prefixed Instructions</a></h3>
The IA-32 and Intel(R) 64 architectures include REP prefixed string instructions. These use a REP prefix on a string operation to repeat the execution of the inner operation. For some instructions the repeat count is determined solely by the value in the count register. For others (SCAS,CMPS), the count register provides an upper limit on the number of iterations, while the REP opcode provides a condition to be tested which can exit the REP loop before the full number of iterations has been executed.<p>
Pin treats REP prefixed instructions as an implicit loop around the inner instruction, so <a class="el" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a> and <a class="el" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a> instrumentation is executed for that instruction once for each iteration of the (implicit) loop. Since each execution of the inner instruction is instrumented, IARG_MEMORY{READ,READ2,WRITE}_SIZE can be determined statically from the instruction (1,2,4,8 bytes), and IARG_MEMORY{OP,READ,READ2,WRITE}_EA can also be determined (even if DF==1, so the inner instructions are decrementing their arguments and moving backwards through store).<p>
REP prefixed instructions are treated as predicated, where the predicate is that the count register is non-zero. Therefore canonical instrumentation for memory accesses such as<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins,memOp))
    {
        <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>,(AFUNPTR)logMemory,
                                 <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                                 <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ga7cbec34f1fc0e6387b44304f38f41c8">INS_MemoryOperandSize</a>(ins,memOp),
                                 IARG_END);
    }
</pre></div><p>
will see all of the memory accesses made by the REP prefixed operations.<p>
To allow tools to count entries into a REP prefixed instruction, and to optimize, Pin provides <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, which can be passed as an argument to an analysis routine. It is TRUE if this is the first iteration of a REP prefixed instruction, FALSE otherwise.<p>
Thus to perform an action only on the first iteration of a REP prefixed instruction, one can use code like this (assuming that "takeAction" wants to be called on the first iteration of all REP prefixed instructions, even ones with a zero repeat count):<p>
To obtain the repeat count, you can use <div class="fragment"><pre class="fragment">        IARG_REGISTER_VALUE, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
</pre></div> which will pass the value in the appropriate count register (one of REG_CX,REG_ECX,REG_RCX depending on the instruction).<p>
As an example, here is code which counts the number of times REP prefixed instructions are executed, optimizing cases in which the REP prefixed instruction only depends on the count register.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>stats
{
    UINT64 count;                               <span class="comment">// Times we start the REP prefixed op</span>
    UINT64 repeatedCount;                       <span class="comment">// Times we execute the inner instruction</span>
    UINT64 zeroLength;                          <span class="comment">// Times we start but don't execute the inner instruction because count is zero</span>
<span class="keyword">public</span>:
    stats() : count(0), repeatedCount(0), zeroLength(0) {}
    VOID output() <span class="keyword">const</span>;
    VOID add(UINT32 firstRep, UINT32 repCount)
    {
        count += firstRep;
        repeatedCount += repCount;
        <span class="keywordflow">if</span> (repCount == 0)
            zeroLength += 1;
    }
    BOOL empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> count == 0; }
    stats&amp; operator+= (<span class="keyword">const</span> stats &amp;other)
    {
        count += other.count;
        repeatedCount += other.repeatedCount;
        zeroLength += other.zeroLength;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
};

<span class="comment">// Trivial analysis routine to pass its argument back in an IfCall so that we can use it</span>
<span class="comment">// to control the next piece of instrumentation.</span>
<span class="keyword">static</span> ADDRINT returnArg (BOOL arg)
{
    <span class="keywordflow">return</span> arg;
}

<span class="comment">// Analysis functions for execution counts.</span>
<span class="comment">// Analysis routine, FirstRep and Executing tell us the properties of the execution.</span>
<span class="keyword">static</span> VOID addCount (UINT32 opIdx, UINT32 firstRep, UINT32 repCount)
{
    stats * s = &amp;statistics[opIdx];

    s-&gt;add(firstRep, repCount);
}

<span class="comment">// Instrumentation routines.</span>
<span class="comment">// Insert code for counting how many times the instruction is executed</span>
<span class="keyword">static</span> VOID insertRepExecutionCountInstrumentation (INS ins, UINT32 opIdx)
{
    <span class="keywordflow">if</span> (takesConditionalRep(opIdx))
    {
        <span class="comment">// We have no smart way to lessen the number of</span>
        <span class="comment">// instrumentation calls because we can't determine when</span>
        <span class="comment">// the conditional instruction will finish.  So we just</span>
        <span class="comment">// let the instruction execute and have our</span>
        <span class="comment">// instrumentation be called on each iteration.  This is</span>
        <span class="comment">// the simplest way of handling REP prefixed instructions, where</span>
        <span class="comment">// each iteration appears as a separate instruction, and</span>
        <span class="comment">// is independently instrumented.</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)addCount,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56810f0eb050dae80f622d800071bb3b9d69">IARG_EXECUTING</a>,
                       IARG_END);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// The number of iterations is determined solely by the count register value,</span>
        <span class="comment">// therefore we can log all we need at the start of each REP "loop", and skip the</span>
        <span class="comment">// instrumentation on all the other iterations of the REP prefixed operation. Simply use</span>
        <span class="comment">// IF/THEN instrumentation which tests IARG_FIRST_REP_ITERATION.</span>
        <span class="comment">//</span>
        <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)returnArg, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, IARG_END);
        <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)addCount,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, 1,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
                           IARG_END);
    }
}
</pre></div><p>
To perform this optimization when collecting memory access addresses, you will also need to worry about the state of EFLAGS.DF, since the string operations work from high address to low address when EFLAGS.DF==1.<p>
Here is an example which shows how to handle that. <div class="fragment"><pre class="fragment"><span class="comment">// Compute the base address of the whole access given the initial address,</span>
<span class="comment">// repeat count and element size. It has to adjust for DF if it is asserted.</span>
<span class="keyword">static</span> ADDRINT computeEA (ADDRINT firstEA, UINT32 eflags, UINT32 count, UINT32 elementSize)
{
    <span class="keyword">enum</span> {
        DF_MASK = 0x0400
    };

    <span class="keywordflow">if</span> (eflags &amp; DF_MASK)
    {
        ADDRINT size = elementSize*count;

        <span class="comment">// The string ops post-decrement, so the lowest address is one elementSize above</span>
        <span class="comment">// where you might think it should be.</span>
        <span class="keywordflow">return</span> firstEA - size + elementSize;
    }
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> firstEA;
}

<span class="keyword">static</span> VOID logMemoryAddress (UINT32 op,        <span class="comment">// Index of instruction</span>
                              BOOL first,       <span class="comment">// First iteration?</span>
                              ADDRINT baseEA,   <span class="comment">// Effective address being accessed on this iteration</span>
                              ADDRINT count,    <span class="comment">// Iteration count</span>
                              UINT32 size,      <span class="comment">// Size in bytes of the per-iteration access</span>
                              UINT32 eflags,    <span class="comment">// Eflags</span>
                              ADDRINT tag)      <span class="comment">// Name for the type of access</span>
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * tagString = reinterpret_cast&lt;const char *&gt;(tag);
    UINT32 width = 20;

    <span class="keywordflow">if</span> (!first)
    {
        out &lt;&lt; <span class="stringliteral">"  "</span>;                            <span class="comment">// Indent REP iterations</span>
        width -= 2;
    }
    out &lt;&lt; opcodes[op].name &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; tagString &lt;&lt; <span class="charliteral">' '</span>;
    out &lt;&lt; std::hex &lt;&lt; std::setw(width) &lt;&lt; computeEA(baseEA, eflags, count, size) &lt;&lt; <span class="charliteral">':'</span>;
    out &lt;&lt; std::dec &lt;&lt; std::setw(20) &lt;&lt; size*count &lt;&lt; endl;
}

<span class="comment">// Insert instrumentation to log memory addresses accessed.</span>
<span class="keyword">static</span> VOID insertRepMemoryTraceInstrumentation(INS ins, UINT32 opIdx)
{
    <span class="keyword">const</span> opInfo * op = &amp;opcodes[opIdx];

    <span class="keywordflow">if</span> (takesConditionalRep(opIdx))
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins))
        {
            <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)logMemoryAddress,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56810f0eb050dae80f622d800071bb3b9d69">IARG_EXECUTING</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, op-&gt;size,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, 0,      <span class="comment">// Fake Eflags, since we're called at each iteration it doesn't matter</span>
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, (ADDRINT)<span class="stringliteral">"Read "</span>,
                           IARG_END);
        }
        <span class="comment">// And similar code for MEMORYREAD2, MEMORYWRITE</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins))
        {
            <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)returnArg, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, IARG_END);
            <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)logMemoryAddress,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, TRUE,      <span class="comment">// First must be TRUE else we wouldn't be called</span>
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, op-&gt;size,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, REG_EFLAGS,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, (ADDRINT)<span class="stringliteral">"Read "</span>,
                               IARG_END);
        }
        <span class="comment">// And similar code for MEMORYREAD2, MEMORYWRITE</span>
    }
}
</pre></div><p>
Since there are real codes where a significant proportion of all instructions are REP prefixed, using <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a> to collect information at the beginning of the REP "loop" while skipping it for the later iterations can be a significant optimization.<p>
A tool which demonstrates all of these techniques can be found in source/tools/ManualExamples/countreps.cpp, from which these (slightly edited) code snippets were taken.<p>
======================================================================================== <h2><a class="anchor" name="MEMORY">
Memory management</a></h2>
========================================================================================<h3><a class="anchor" name="">
</a></h3>
Pin allows the Pin tool to dynamically allocate memory (e.g. using malloc()) without interfering with the execution of the application that is run under Pin. In order to achieve this, Pin implements its own memory allocator which is separate from the application's memory allocator, and allocates memory in different memory regions.<h3><a class="anchor" name="Restrict">
Pin's dynamic memory allocation regions</a></h3>
By default, the memory address region used by Pin to dynamically allocate memory for both Pin usage and Pin tool usage is unrestricted. However, if Pin memory allocation should be restricted to specific memory regions, the -pin_memory-range knob can be used in Pin's command line to make Pin allocate memory only inside the specified regions. Note that restricting Pin memory allocation to specific regions doesn't mean that it will allocate/reserve the entire memory available those regions!<h3><a class="anchor" name="Limit">
the maximum memory that Pin can allocate</a></h3>
Pin can be forced to limit the amount of memory it can allocate (in bytes) by using the -pin_memory_size knob in Pin's command line. When a Pin tool cannot allocate more memory due to -pin_memory_size limitation, its out of memory callback is called (see <a class="el" href="group__PIN__CONTROL.html#gcae8a563efbe6d5f2eff743d718e5ce0">PIN_AddOutOfMemoryFunction()</a>). By default, the number of bytes that Pin can allocate is unlimited. We recommend that if a memory limitation is specified, it will be at least 30MB.<h3><a class="anchor" name="JIT">
mode</a></h3>
In JIT mode, Pin needs to manage memory for the code cache in addition to the dynamically allocated memory. This means that the memory regions specified by -pin_memory-range restricts both the dynamically allocated memory and the code cache blocks allocated by Pin.<p>
In order to limit the code cache memory allocation, one can specify the -cc_memory_size knob in Pin's command line. Note that the specified limit must be a multiple of the code cache block size (specified with -cache_block_size).<h3><a class="anchor" name="Pin">
Pin</a></h3>
Another component that requires memory while running Pin on an application is the images of Pin, tool, and their shared libraries (aka dynamic link libraries). The shared libraries are usually built as position independent code and hence can be loaded anywhere in the memory space of the Pined process. On the other hand, the Pin executable is currently built as position independent code only on Linux. Note that Pin executable is injected to the Pined process memory space on the operating systems: OS X*, Android, and Linux. This means that on OS X* and Android Pin executable must be injected to a fixed address in the memory space and cannot be relocated.<p>
In order to restrict the memory that Pin image loader will use (while considering the limitation stated above), one can use the -restrict_memory knob in Pin's command line to specify memory region where Pin loader should not use. Note that the logic of the -restrict_memory knob is reversed from all the other memory range knobs for Pin - as it specifies which memory regions the Pin loader should *NOT* use.<p>
======================================================================================== <h2><a class="anchor" name="RESTRICTIONS">
Pintool Information and Restrictions</a></h2>
========================================================================================<h3><a class="anchor" name="General">
General</a></h3>
There are several things that a Pintool writer must be aware of.<ul>
<li>pthread functions cannot be called from an analysis or replacement routine (<a class="el" href="index.html#MT">Instrumenting Multi-threaded Applications</a>)</li><li>IARG_REG_VALUE cannot be used to pass floating point register values to an analysis routine.</li><li>Also, see the OS-specific restrictions below. <a class="el" href="index.html#WINDOWS_OS">Windows OS</a> or <a class="el" href="index.html#LINUX_OS">Linux OS</a></li></ul>
<p>
Often, a Pintool writer wants to run the SPEC benchmarks to see the results of their research. There are many ways one can update the scripts to invoke Pin on the SPEC tests; this is one. In your $SPEC/config file, add the following two lines:<p>
<div class="fragment"><pre class="fragment">   submit=$PIN_HOME/intel64/bin/pin -t /my/pin/tool -- $command
   use_submit_for_speed=yes
</pre></div><p>
Now the SPEC harness will automatically run Pin with whatever benchmarks it runs. Note that you need the full path name for Pin and Pintool binaries. Replace "intel64" with "ia32" if you are using a 32-bit system.<h3><a class="anchor" name="LINUX_OS">
Linux OS</a></h3>
Pin identifies system calls at the actual system call trap instruction, not the libc function call wrapper. Tools need to be aware of oddities like this when interpreting system call arguments, etc.<h3><a class="anchor" name="WINDOWS_OS">
Windows OS</a></h3>
On Windows, Pin has been compiled with /D_SECURE_SCL=0. Pintools must also be compiled with /D_SECURE_SCL=0, otherwise the STL containers shared between Pin and the Pintool can have different memory layouts.<p>
Pin on Windows guarantees safe usage of C/C++ run-time services in Pin tools, including indirect calls to Windows API through C run-time library. Any other use of Windows API in Pin tool is not guaranteed to be safe:<ul>
<li>reentrant use of shared system resources may cause crashes and lost of transparency</li><li>a tool that directly or indirectly locks shared resource by calling to a system API under Pin lock may cause deadlock</li><li>using alertable system calls or installing handlers of asynchronous system events in a tool may violate the logic of the application, cause recursive invocation of instrumentation/analysis callbacks in the tool.</li></ul>
<p>
Pin on Windows does not separate DLLs loaded by the tool from the application DLLs - it uses the same system loader. In order to avoid isolation problems, Pin tool should not load any DLL that can be shared with the application. For the same reason, Pin tool should avoid static links to any common DLL, except for those listed in PIN_COMMON_LIBS (see source.flags file).<p>
In probe mode, the application runs natively, and the probe is placed in the original code. If a tool replaces a function shared by the tool and the application, an undesirable behavior may occur. For example, if a tool replaces EnterCriticalSection() with an analysis routine that calls printf(), this could result in an infinite loop, because printf() can also call EnterCriticalSection(). The application would call EnterCriticalSection(), and the control flow would go to the replacement routine, and it would call EnterCriticalSection() (via printf) which would call the replacement routine, and so on.<h3><a class="anchor" name="namespace">
Conflicts between Pin and Windows</a></h3>
Pin uses some base types that conflict with Windows types. If you use "windows.h", you may see compilation errors. To avoid this problem, we recommend wrapping the windows.h file as follows. Items that reside in the windows.h file must be referenced using the WINDOWS:: prefix.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>WINDOWS
{
<span class="preprocessor">#include &lt;windows.h&gt;</span>
}
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="WINDOWS_TOOLS">
Building Tools on windows</a></h2>
========================================================================================<h3><a class="anchor" name="building">
Building Tools in Visual Studio</a></h3>
<ul>
<li>In order to use pin kit VC9, you must have Visual studio 2008 installed on your computer.</li><li>In order to use pin kit VC10, you must have Visual studio 2010 installed on your computer.</li><li>In order to use pin kit VC11, you must have Visual studio 2012 installed on your computer.</li></ul>
<p>
According to the Visual Studio version an example of visual studio project that builds pin tool in the Visual Studio IDE will be placed in the  directory. Enter this directory and open MyPinTool.vcproj project or MyPinTool.sln solution. To build the tool, select "Build Solution".<p>
To run an application, instrumented by MyPinTool, select Tool-&gt;External Tools. In the "Menu contents" window choose "run pin". Add to the "Arguments" box the path of the required application that you want to run with pin. For example: -t MyPinTool.dll -count 1 -- "C:\Users\..\my_app.exe" and select "OK". A Popup window may appear on the screen with the following message: "The command is not a valid executable. Would you like to change the command?" select "No". To start running your application select Tool-&gt;pin run.<p>
You can select another application and change tool's switches in the "MyPinTool Properties-&gt;Debugging" page.<p>
You can use MyPinTool as a template for your own project. Please, look carefully at the compilation and linking switches in the MyPinTool property pages. Mandatory switches can be found in the win.vars file in the kit's source/tools/Config directory. Also note the library order, as this is important, too. See <a class="el" href="index.html#MAKEFILES">Pin's makefile Infrastructure</a> for further details.<h3><a class="anchor" name="multi">
Constructing PinTools from multiple DLLs on Windows</a></h3>
A Pin tool can be composed from multiple DLLs:<ul>
<li>"main DLL", which is specified in the Pin command line after "-t" switch</li><li>a number of "secondary DLLs", linked to the "main DLL" statically.</li></ul>
<p>
When considering this configuration, take into account that multi-DLL Pin tool may increase memory fragmentation and cause layout conflicts with application images. If there is no compelling reasons for using multiple DLLs, build your tool as a single DLL to reduce the risk of memory conflicts.<p>
Limitations and instructions:<ul>
<li>Don't use any Pin API in "secondary DLLs". Only "main DLL" can use Pin API!</li><li>In order to run Pin tool put "main DLL" and its "secondary DLLs" in the same directory.</li><li>IMPORTANT: Build each DLL with the recommended pin tool building flags (see <a class="el" href="index.html#building">Building Tools in Visual Studio</a>).</li><li>Remove /EXPORT:main link flag for "secondary DLLs".</li><li>Specify different base address for each DLL (/BASE link flag). When choosing base addresses, try to minimize memory fragmentation and layout conflicts.</li></ul>
<h3><a class="anchor" name="supported">
Supported executables</a></h3>
Pin can instrument Windows* subsystem executables.<br>
 It can't instrument other executables (such as MS-DOS, Win16 or a POSIX subsystem executables).<p>
======================================================================================== <h2><a class="anchor" name="WINLIBRARIES">
Libraries for Windows</a></h2>
========================================================================================<p>
Pin on Windows uses dbghelp.dll by Microsoft* to provide symbolic information. dbghelp.dll version 6.11.1.404 is distributed with the kit. Please use the provided version, as other versions may not work properly with Pin.<p>
======================================================================================== <h2><a class="anchor" name="LIBRARIES">
Libraries for Linux</a></h2>
========================================================================================<h3><a class="anchor" name="PIN_LAUNCHER">
The "pin" Executable (Launcher)</a></h3>
The kit's root directory contains a "pin" executable. This is a 32-bit launcher, used for launching Pin in 32 and 64 bit modes. The launcher sets up the environment to find the libraries supplied with the kit. The kit's runtime directories will be searched first, followed by directories that are on the LD_LIBRARY_PATH. The launcher will then invoke the actual Pin executable - "pinbin".<p>
If you need to change the directory structure or copy pin to a different directory, then you should note the following. The "pin" launcher expects the binary "pinbin" to be in the architecture-specific "bin" subdirectory (e.g. ia32/bin). The launcher expects the libraries to be found in the architecture-specific "runtime" and subdirectory (i.e. ia32/runtime). If you need a different directory structure, you need to build your own launcher or find a different way to set up the environment to allow the pinbin executable to find the necessary runtime libraries. The pinbin binary itself makes no assumptions about the directory structure. The launcher's sources may be found in &lt;kit root&gt;=""&gt;/source/launcher.<p>
======================================================================================== <h2><a class="anchor" name="INSTALLATION">
Installing Pin</a></h2>
========================================================================================<p>
To install a kit, unpack a kit and change to the directory.<p>
Linux / OS X* / Android: <div class="fragment"><pre class="fragment">$ tar zxf pin-3.0-74555-gcc.4.9.2-linux.tar.gz
$ cd pin-3.0-74555-gcc.4.9.2-linux
</pre></div> Use the OS X* / Android kit names respectively.<p>
Windows: Unzip the installation files, extracting all files in the kit. <div class="fragment"><pre class="fragment">$ cd  pin-3.0-74555-msvc11-windows.zip
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="XEONPHIUSAGE">
Usage Instructions for Intel(R) Xeon Phi(TM)</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#InstallPinOnDevice">Installing Pin on the Device</a></li><li><a class="el" href="index.html#InstallEntireDirectory">Building and Installing an Entire Test Directory</a></li><li><a class="el" href="index.html#InstallSingleTool">Building and Installing a Single Tool</a></li><li><a class="el" href="index.html#RunningEntireDirectory">Running All the Tests in a Directory</a></li><li><a class="el" href="index.html#RunningSingleTestFromHost">Running a Single Test on the Device - Launched from the Host</a></li><li><a class="el" href="index.html#RunningTestNatively">Running a Single Test on the Device - Launched from the Device</a></li></ul>
<h3><a class="anchor" name="InstallPinOnDevice">
Installing Pin on the Device</a></h3>
<ul>
<li>Copy the mic-install.tar.gz tarball (located at the kit's root) to your preferred location on the device and unpack it. This will create a directory structure similar to that found on the host.</li><li>Make sure the following libraries are present on the device (copy manually if necessary):<br>
 libimf.so libintlc.so libintlc.so.5 libirng.so libsvml.so</li></ul>
<h3><a class="anchor" name="InstallEntireDirectory">
Building and Installing an Entire Test Directory</a></h3>
Perform the following on the host: <div class="fragment"><pre class="fragment">cd source/tools/ManualExamples
make CC=icc CXX=icpc TARGET=mic REMOTE_DEVICE=mic0 REMOTE_ROOT=pin install
</pre></div><p>
Notes:<ul>
<li>The above will build all the tools and test applications in the ManualExamples library and pack them in a tarball. Then, the tarball will be copied to the device and will be unpacked.</li><li>The device is identified by the REMOTE_DEVICE flag.</li><li>The install location on the device is specified by the REMOTE_ROOT flag. REMOTE_ROOT should be the same location where the mic-install.tar.gz tarball was unpacked.</li><li>The makefile will automatically add the "-mmic" directive to the compilation flags when TARGET=mic is specified.</li></ul>
<h3><a class="anchor" name="InstallSingleTool">
Building and Installing a Single Tool</a></h3>
Compile the tool on the host as follows: <div class="fragment"><pre class="fragment">make CC=icc CXX=icpc TARGET=mic obj-mic/MyPinTool.so
</pre></div> Copy the tool to your preferred location on the device.<p>
Notes:<ul>
<li>The makefile will automatically add the "-mmic" directive to the compilation flags when TARGET=mic is specified.</li></ul>
<h3><a class="anchor" name="RunningEntireDirectory">
Running All the Tests in a Directory</a></h3>
Perform the following on the host: <div class="fragment"><pre class="fragment">cd source/tools/ManualExamples
make TARGET=mic REMOTE_DEVICE=mic0 REMOTE_ROOT=pin test
</pre></div><p>
Notes:<ul>
<li>The above will run all tests in the ManualExamples library.</li><li>The directory should be installed prior to running the tests (follow the directions in <a class="el" href="index.html#InstallEntireDirectory">Building and Installing an Entire Test Directory</a>).</li><li>See <a class="el" href="index.html#InstallEntireDirectory">Building and Installing an Entire Test Directory</a> for details of the flags used in the make command.</li></ul>
<h3><a class="anchor" name="RunningSingleTestFromHost">
Running a Single Test on the Device - Launched from the Host</a></h3>
Copy the tool, application and any other dependencies of the test (as they appear in the makefile) to the device. Make sure to keep the same directory structure as on the host (this is expected by the makefile). Run the following: <div class="fragment"><pre class="fragment">cd source/tools/ManualExamples
make REMOTE_DEVICE=mic0 REMOTE_ROOT=pin inscount0.wrap
</pre></div><p>
Notes:<ul>
<li>The ".wrap" suffix should be used instead of the ".test" suffix. This will result in running the ".test" make target on the device. The ".wrap" make target is automatically generated by Pin's make configuration. It's purpose is to set the environment for launching the test on the device.</li><li>See <a class="el" href="index.html#InstallEntireDirectory">Building and Installing an Entire Test Directory</a> for details of the flags used in the make command.</li></ul>
<h3><a class="anchor" name="RunningTestNatively">
Running a Single Test on the Device - Launched from the Device</a></h3>
Copy Pin, tool and application to the device. Then simply log in to the device and launch Pin regularly.<p>
======================================================================================== <h2><a class="anchor" name="BUILDINGTOOLS">
Building Your Own Tool</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#BuildingInsideKit">Building a Tool From Within the Kit Directory Tree</a></li><li><a class="el" href="index.html#BuildingOutOfKit">Building a Tool Out of the Kit Directory Tree</a></li></ul>
<p>
To write your own tool, copy one of the example directories and edit the makefile.rules file to add your tool. The sample tool MyPinTool is recommended. This tool allows you to build either inside or outside the kit directory tree. See <a class="el" href="index.html#AddingTests">Adding Tests, Tools and Applications to the makefile</a> and <a class="el" href="index.html#DefiningbuildRules">Defining Build Rules for Tools and Applications</a> for further details on makefile modification.<h3><a class="anchor" name="BuildingInsideKit">
Building a Tool From Within the Kit Directory Tree</a></h3>
You may either modify MyPinTool or copy it as directed above. If you're using MyPinTool, and the default build rule suffices, you may not have to change makefile.rules. If you are adding a new tool, or you require special build flags for your tool, you will need to modify the makefile.rules file to add your tool and/or specify a customized build rule.<p>
Building YourTool.so (from YourTool.cpp): <div class="fragment"><pre class="fragment">make obj-intel64/YourTool.so
</pre></div> For the IA-32 architecture, use "obj-ia32" instead of "obj-intel64". See  for commonly used make flags to add to your build.<h3><a class="anchor" name="BuildingOutOfKit">
Building a Tool Out of the Kit Directory Tree</a></h3>
Copy the MyPinTool directory to a place of your choosing. This directory will serve as a basis for your tool. Modify the makefile.rules file to add your tool and/or specify a customized build rule.<p>
Building YourTool.so (from YourTool.cpp): <div class="fragment"><pre class="fragment">make PIN_ROOT=&lt;path to Pin kit&gt; obj-intel64/YourTool.so
</pre></div> For the IA-32 architecture, use "obj-ia32" instead of "obj-intel64". See  for commonly used make flags to add to your build.<p>
For changing the directory where the tool will be created, override the OBJDIR variable from the command line: <div class="fragment"><pre class="fragment">make PIN_ROOT=&lt;path to Pin kit&gt; OBJDIR=&lt;path to output dir&gt; &lt;path to output dir&gt;/YourTool.so
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="MAKEFILES">
Pin's makefile Infrastructure</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#MakefileUsage">Using Pin's makefile Infrastructure</a></li><li><a class="el" href="index.html#ConfigDirectory">The Config Directory</a></li><li><a class="el" href="index.html#TestDirectories">The Test Directories</a></li><li><a class="el" href="index.html#AddingTests">Adding Tests, Tools and Applications to the makefile</a></li><li><a class="el" href="index.html#DefiningbuildRules">Defining Build Rules for Tools and Applications</a></li><li><a class="el" href="index.html#DefiningTestRecipes">Defining Test Recipes in makefile.rules</a></li><li><a class="el" href="index.html#UsefulVariables">Useful make Variables and Flags</a></li></ul>
<h3><a class="anchor" name="MakefileUsage">
Using Pin's makefile Infrastructure</a></h3>
Pintools are built using make on all target platforms. This section describes the basic flags available in Pin's makefile infrastructure. This is not a makefile tutorial. For general information about makefiles, refer to the makefile manual available at <em><a href="http://www.gnu.org/software/make/manual/make.html">http://www.gnu.org/software/make/manual/make.html</a></em>.<h3><a class="anchor" name="ConfigDirectory">
The Config Directory</a></h3>
The source/tools/Config directory holds the common make configuration files which should not be changed and template files which may serve as a basis for your own makefiles. This sections gives a short overview of the most notable files in the directory. The experienced user is welcome to read through the complete set of configuration files for better understanding the tools' build process.<p>
<code>makefile.config</code>: This is the first file to be included in the make include chain. It holds documentation of all the relevant flags and variables available to users, both within the makefile and from the command shell. Also, this file includes the OS-specific configuration files.<p>
<code>makefile.unix.config</code>: This file holds the Unix definitions of the makefile variables. See <code>makefile.win.config</code> for the Windows definitions.<p>
<code>unix.vars</code>: This file holds the Unix definitions of some architectural variables and utilities used by the makefiles. See <code>win.vars</code> for the Windows definitions.<p>
<code>makefile.default.rules</code>: This file holds the default make targets, test recipes and build rules.<h3><a class="anchor" name="TestDirectories">
The Test Directories</a></h3>
Each test directory in source/tools/ contains two files in the makefile chain.<p>
<code>makefile</code>: This is the makefile which will be invoked when running make. This file should not be changed. It holds the include directives for all the relevant configuration files of the makefile chain in the correct order. Changing this order may result in unexpected behavior. This is a generic file, it is identical in all test directories.<p>
<code>makefile.rules</code>: This is the directory-specific makefile. It holds the logic of the current directory. All tools, applications and tests that should be built and run in a directory are defined in this file. See <a class="el" href="index.html#AddingTests">Adding Tests, Tools and Applications to the makefile</a> for adding tests, tools and applications to makefile.rules.<h3><a class="anchor" name="AddingTests">
Adding Tests, Tools and Applications to the makefile</a></h3>
This section describes how to define your applications, tools and tests in the makefile. The sections below describe how to build the binaries and how to run the tests.<p>
The variables detailed below, hold the tests, applications and tools definitions. They are defined in the "Test targets" section of makefile.rules. See this section for additional variables and more detailed documentation for each variable.<p>
<code>TOOL_ROOTS</code>: Define the name of your tool here, without the file extension. The correct extension, according to the OS, will be added automatically by make. For example, for adding YourTool.so: <div class="fragment"><pre class="fragment">TOOL_ROOTS := YourTool
</pre></div><p>
<code>APP_ROOTS</code>: Define your application here, without the file extension. The correct extension according to the OS, will be added automatically by make. For example, for adding YourApp.exe: <div class="fragment"><pre class="fragment">APP_ROOTS := YourApp
</pre></div><p>
<code>TEST_ROOTS</code>: Define your tests here without the .test suffix. This suffix will be added automatically by make. For example, for adding YourTest.test: <div class="fragment"><pre class="fragment">TEST_ROOTS := YourTest
</pre></div><h3><a class="anchor" name="DefiningbuildRules">
Defining Build Rules for Tools and Applications</a></h3>
Default build rules for tools and applications are defined in source/tools/Config/makefile.default.rules. The default tool requires a single c/cpp source file and will generate a tool of the same name. For example, for YourTool.cpp make will generate YourTool.so with the default build rule. However, if your tool requires more than one source file, or you need a customized build rule, add your rule at the bottom of makefile.rules in the "Build rules" section". There is no need to add the $(OBJDIR) dependency to the build rule, it will be added automatically. This dependency creates the build output directory obj-intel64 (or obj-ia32 for the IA-32 architecture). See source/tools/Config/makefile.config for all available compilation and link flags.<p>
Here are a few useful examples:<p>
Building an unoptimized tool from a single source: <div class="fragment"><pre class="fragment"># Build the intermediate object file.
$(OBJDIR)YourTool$(OBJ_SUFFIX): YourTool.cpp
    $(CXX) $(TOOL_CXXFLAGS_NOOPT) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)YourTool$(OBJ_SUFFIX)
    $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $&lt; $(TOOL_LPATHS) $(TOOL_LIBS)
</pre></div><p>
Building an optimized tool from several source files: <div class="fragment"><pre class="fragment"># Build the intermediate object file.
$(OBJDIR)Source1$(OBJ_SUFFIX): Source1.cpp
    $(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the intermediate object file.
$(OBJDIR)Source2$(OBJ_SUFFIX): Source2.c Source2.h
    $(CC) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $&lt;

# Build the tool as a dll (shared object).
$(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)Source1$(OBJ_SUFFIX) $(OBJDIR)Source2$(OBJ_SUFFIX) Source2.h
    $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $(^:%.h=) $(TOOL_LPATHS) $(TOOL_LIBS)
</pre></div><h3><a class="anchor" name="DefiningTestRecipes">
Defining Test Recipes in makefile.rules</a></h3>
A default test recipe is defined in source/tools/Config/makefile.default.rules. For most users, this recipe is insufficient. You may specify your own test recipes in makefile.rules in the "Test recipes" section. There is no need to add the $(OBJDIR) dependency to the build rule, it will be added automatically. This dependency creates the build output directory obj-intel64 (or obj-ia32 for the IA-32 architecture).<p>
Example: <div class="fragment"><pre class="fragment">YourTest.test: $(OBJDIR)YourTool$(PINTOOL_SUFFIX) $(OBJDIR)YourApp$(EXE_SUFFIX)
    $(PIN) -t $&lt; -- $(OBJDIR)YourApp$(EXE_SUFFIX)
</pre></div><h3><a class="anchor" name="UsefulVariables">
Useful make Variables and Flags</a></h3>
For a complete list of all the available variables and flags, see source/tools/Config/makefile.config . Here is a short list of the most useful flags: <br>
<code>PIN_ROOT</code>: Specify the location for the Pin kit when building a tool outside of the kit. <br>
<code>CC</code>: Override the default c compiler for tools. <br>
<code>CXX</code>: Override the default c++ compiler for tools <br>
<code>APP_CC</code>: Override the default c compiler for applications. If not defined, APP_CC will be the same as CC. <br>
<code>APP_CXX</code>: Override the default c++ compiler for applications. If not defined, APP_CXX will be the same as CXX. <br>
<code>TARGET</code>: Override the default target architecture e.g. for cross-compilation. <br>
<code>ICC</code>: Specify ICC=1 when building tools with the Intel Compiler. <br>
<code>DEBUG</code>: When DEBUG=1 is specified, debug information will be generated when building tools and applications. Also, no compilation and/or link optimizations will be performed.<p>
======================================================================================== <h2><a class="anchor" name="FEEDBACK">
Questions? Bugs?</a></h2>
========================================================================================<p>
Send bugs and questions to <a href="mailto:pinheads@yahoogroups.com">pinheads@yahoogroups.com</a>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us.<p>
======================================================================================== <h2><a class="anchor" name="LEGAL">
Disclaimer and Legal Information</a></h2>
========================================================================================<p>
The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.<p>
EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.<p>
Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them.<p>
The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.<p>
Copyright (c) 2004-2016, Intel Corporation. All rights reserved.<p>
Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.<p>
Microsoft, Windows, and the Windows logo are trademarks, or registered trademarks of Microsoft Corporation in the United States and/or other countries.<p>
Java is a registered trademark of Oracle and/or its affiliates.<p>
Other names and brands may be claimed as the property of others.<p>
Copyright Intel Corporation. All rights reserved. Intel Corporation, 2200 Mission College Blvd., Santa Clara, CA 95052-8119, USA.<p>
======================================================================================== <hr size="1"><address style="align: right;"><small>Generated on Thu Mar 17 10:18:44 2016 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
