### Publication
"Accurate High-level Modeling and Automated Hardware/Software Co-design for Effective SoC Design Space Exploration" Wei Zuo, Louis-Noel Pouchet, Andrey Ayupov, Taemin Kim, Chung-Wei Lin, Shinichi Shiraishi, Deming Chen. (DAC'17)

### Introduction
#### RIP: Randomized Iterative ILP
RIP is a framework to enable hardware acceleration of performance-critical parts of an application, by addressing the problem of hardware/software partitioning under power and area constraints to minimize the overall program latency. Experimental results demonstrate the capability of our approach to consider complex designs and yet produce optimal or near-optimal partitioning decisions. 

### Installation

This framework requires 

1. LLVM 3.9.0 (and Clang 3.9.0). The famework is compatable with LLVM 3.9.0, but not tested for other versions.

2. The hardware modeling and software modeling framework installed, which is provided in this project.

3. This framework also requires matlab R2015b installed.


After the LLVM is installed, we can integrate RIP to LLVM

1. Copy the ./install/SoC folder to <llvm_src_dir>/lib
	
```
 cd <llvm_src_dir>/lib
 cp ./install/SoC .
```
2. Add the subdirctory to CMakeLists.txt. Put the following line to the file.

```
add_subdirectory(SoC)
```

3. Replace the following files with the files in our folder

```
cp ./install/clang/include/clang/Basic/Attr.td <llvm_src_dir>/tools/clang/include/clang/Basic/
cp ./install/clang/include/clang/Basic/DiagnosticParseKinds.td <llvm_src_dir>/tools/clang/include/clang/Basic/
cp ./install/clang/lib/CodeGen/CGLoopInfo.cpp <llvm_src_dir>/tools/clang/lib/CodeGen
cp ./install/clang/lib/CodeGen/CGLoopInfo.h <llvm_src_dir>/tools/clang/lib/CodeGen
cp ./install/clang/lib/Parse/ParsePragma.cpp <llvm_src_dir>/tool/clang/lib/Parse/
cp ./install/clang/lib/Sema/SemaAttr.cpp <llvm_src_dir>/tool/clang/lib/Sema
cp ./install/clang/lib/Sema/SemaStmtAttr.cpp <llvm_src_dir>/tool/clang/lib/Sema
```
3. rebuild LLVM tool. 

```
cd <llvm_build_dir>
make
```


### Running the tool

We provided  an running example in folder ./run/main.c

1. Profling the source code

	Once identified the critical loops in the code, place the following pragma right before the loop structure.
	
	```
	#pragma clang loop critical(disable)
	```
2. Within each loop, insert the following annotation data. 

	```
	int InLine = i;
	double lat_hw = LAT_HW_i;  
	double lat_sw = LAT_SW_i;
	double power_hw = POW_HW_i;
	double power_sw = POW_SW_i;
	int BRAM = BRAM_HW_i;
	int DSP = DSP_HW_i;
	int LUT = LUT_HW_i;
	int FF = FF_HW_i;
	```
	Explanation: 
		
	* Inline: the reuse group number, starting from 1. for the loops that can share the same module, assign the same value. For loops with different module, assign different value. 
	* lat_hw: LAT_HW_i is the latency of the hardware implementation of i-th critical node. The value of the LAT_HW_i is defined in PLA.h, which is generated by the framework. So number the critical loops in order from i=1, and insert the "double lat_hw = LAT_HW_i" in each loop
	* lat_sw: is the latency of the software implementation of i-th critical node. Similar to lat_hw.
	* power_hw: is the power of the hardware implementation of i-th critical node.
	* power_sw: is the power of the software implementation of i-th critical node.
	
2. Use the hardware_model and software_model tool to generate the characterization data for each of the loop. Put the results in file frontier_i.txt. Where i is the i-th critical loop.

3. Sorting the frontier to generate an order pareto-curve list

```
python sortFrontier.py --fileNames=frontier_1.txt,frontier_2.txt,...
```
4. run the RIP solver

```
python runILP.py  		[options] [values]
	--sampleNum :		number of sampled points per iteration
	--PowerBudget:		power budget for the system (w)
	--LUTBudget:		number of LUT limits for the system
	--BRAMBudget:		number of BRAM budget for the system
	--FFBudget:			number of FF budget for the system
	--DSPBudget:		number of DSPs budget for the syste
	--benchmarkName:	the name of the benchmkark file
	--loopIndexes:		the list of numbers of the hot loops
	--cpp:				whether the testing file is a cpp file (1) or c file (0).
```

### Contact
weizuo (at) illinois (dot) edu


