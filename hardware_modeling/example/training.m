%% This script takes in the csv file which is generated by PolyRose simulation, the sampled points in the csv file is logrithimically increassing along tile size , unroll factor 
%% It does two things:
%%    1. Extrapolate the entire design space using triangulation. Implemented by the matlab function "griddatan". The stride of the space is controlled by spacing vector
%%    2. Generate the pareto point considering power and latency

clc;
clear all;
clf;
close all;

inputCSVFile = 'data_points.csv';
sampleSpaceCSVFile = 'sampled_space.csv';
degenerate_level  = 1;
thickness = [0.001, 100000];

%%%
data_points = csvread(inputCSVFile);
data_point_size = size(data_points);
x = data_points(:, 1: end-2); %the sample points and the associated tile size, unroll factors
x = x(:, 1:(end-degenerate_level));
x_unq = unique(x, 'rows');
assert(length(x_unq) == length(x));

power = data_points(:, end-1);
latency = data_points(:, end);

x1_org = csvread(sampleSpaceCSVFile);
x1 = x1_org(:, 1:(end-degenerate_level));
x1_unq = unique(x1_org(:, 1:(end-degenerate_level)), 'rows');

assert(length(x1_unq) == length(x1));
power_surface = griddatan(x, power, x1);
latency_surface = griddatan(x, latency, x1);

full_design_space = [x1_org, power_surface, latency_surface];

%There should be no NaN, every points should be in the convhull.
assert(sum(isnan(power_surface))==0)
assert(sum(isnan(latency_surface))==0);

front = paretofront([power_surface, latency_surface]);

front_points = [];
for i = 1:length(front)
    if(front(i))
        front_points = [front_points; full_design_space(i,:)];
    end
end
  
front_curve_latency = fit(front_points(:, end-1), front_points(:, end), 'linearinterp');
front_curve_power = fit(front_points(:, end), front_points(:, end-1),'linearinterp');

%thicken
front_line_latency = feval(front_curve_latency,power_surface) + thickness(2); %the latency thicked frontier
front_line_power = feval(front_curve_power, latency_surface) + thickness(1);

figure(1)
plot(front_curve_latency);
hold on
scatter(power_surface, front_line_latency);


figure(2)
plot(front_curve_power);
hold on
scatter(latency_surface, front_line_power);


front_points_thick = [];


space_size = size(x1_org);

for i = 1:space_size(1)
    latency =latency_surface(i);
    power = power_surface(i);
    if(latency <= front_line_latency(i) || power <= front_line_power(i))
        front_points_thick = [front_points_thick; full_design_space(i,:)];
    end
end

figure(3)
scatter(front_points(:, end-1), front_points(:, end), 'o','r');
hold on
scatter(front_points_thick(:, end-1), front_points_thick(:, end), '*','b');


csvwrite('thicked_points.csv', front_points_thick(:, 1:end-2));
csvwrite('thicked_points_full.csv', front_points_thick);
%csvwrite('thicked_power.csv', power_front_thick);
%csvwrite('thicked_latency.csv', latency_front_thick);

